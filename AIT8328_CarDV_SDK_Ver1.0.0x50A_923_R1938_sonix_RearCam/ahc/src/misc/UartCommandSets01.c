/*
  C-file generated by Bin2C
  Compiled:    Aug  9 2004 at 15:18:55

  Copyright (C) 2004
  Segger Microcontroller Systeme GmbH
  www.segger.com

  Solutions for real time microcontroller applications
*/
#if 0		 
void _____HEADER_____(){}
#endif

// isp related layer
#include "Hdm_ctl.h"
#include "AE.h"
#include "ISP_IF.h" // Yanwei

// mmpf layer
#include "includes_fw.h"
#include "mmpf_typedef.h"
#include "mmp_reg_vif.h"

#include "mmpf_fdtc.h"
#include "mmpf_hw_counter.h"
#include "mmpf_nand.h"
#include "Mmpf_pio.h"
#include "mmpf_sensor.h"
#include "mmpf_storage_api.h"
#include "mmpf_timingmark.h"
#include "mmpf_eis.h"
#include "mmpd_bayerscaler.h"

// mmps & mmpd layer
#include "ait_utility.h"
#include "mmps_3gprecd.h"
#include "mmps_audio.h"
#include "mmps_dsc.h"
#include "mmps_usb.h"
#include "mmps_sensor.h"
#include "mmps_aui.h"
// AHC layer
#include "AHC_Capture.h" // chenchu
#include "AHC_Display.h"
#include "AHC_General.h"
#include "AHC_GUI.h"
#include "AHC_isp.h"
#include "AHC_GSensor.h"
#include "AHC_media.h"
#include "AHC_menu.h"
#include "AHC_message.h"
#include "AHC_Parameter.h"//Mark
#include "AHC_OS.h"
#include "AHC_Sensor.h"
#include "ahc_warningmsg.h"
#include "AHC_PMU.h"
#include "AHC_Version.h"
#include "AHC_DebugEx.h"
#include "MenuDrawCommon.h"
#include "ProductLineCali.h"
#include "MenuSetting.h"
#include "dsc_key.h"
#include "UartShell.h"
#include "MemPool.h"   
#include "R2A30440NP.h"
#include "AHC_video.h"
// AHC internal layer
#include "AHC_UF.h"
#include "AIHC_DCF.h"
#include "stateHDMIFunc.h"
#include "stateTVFunc.h"
#include "AHC_USB.h"
#if (GPS_CONNECT_ENABLE)
#include "GPS_ctl.h"
#if (EDOG_ENABLE)
#include "EDOG_ctl.h"
#endif
#endif
#include "controlIC_M24SR04Y_NFC.h" 

#include "MenuSetting.h"
#include "MediaPlaybackCtrl.h"
#include "adas.h"
#include "ldws_cfg.h"
#include "IconPosition.h"
#include "AHC_MIMF.h"
#if (SUPPORT_ADAS)
#include "mmpf_adas_ctl.h"
#endif
#if (REAR_CAM_TYPE != REAR_CAM_TYPE_NONE)
#include "AHC_USBHost.h"
#endif
#define MotorCtrl_RegWrite(a, b, c)		// Andy Liu TBD
#define MotorCtrl_RegRead(a, b, c, d)	// TY Miao - TBD

#if 1 //Andy Liu TBD
unsigned char acbayer_pattern[] = {
  0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x60, 0x00, 0x60, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A,
  0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F,
  0x27, 0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xDB, 0x00, 0x43, 0x01, 0x09, 0x09, 0x09, 0x0C, 0x0B, 0x0C, 0x18, 0x0D, 0x0D, 0x18, 0x32, 0x21, 0x1C, 0x21, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
  0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0xFF,
  0xC0, 0x00, 0x11, 0x08, 0x01, 0x52, 0x01, 0x4B, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
  0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71,
  0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
  0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
  0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
  0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
  0xF8, 0xF9, 0xFA, 0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
  0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22,
  0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A,
  0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65,
  0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA,
  0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5,
  0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0xA7, 0xF1, 0x33, 0xE2, 0x67, 0x8D, 0x74, 0x3F, 0x89, 0x5A, 0xB6, 0x8F, 0xA3, 0xEB, 0x22, 0xDA, 0xCA, 0xDC, 0x42, 0x63, 0x88,
  0xDB, 0x42, 0xFB, 0x77, 0x44, 0x8C, 0x79, 0x64, 0x24, 0xF2, 0xC4, 0xF2, 0x6B, 0x96, 0xFF, 0x00, 0x85, 0xBB, 0xF1, 0x27, 0xFE, 0x86, 0x34, 0xFF, 0x00, 0xC0, 0x38, 0x3F, 0xF8, 0xDD, 0x1F, 0x17, 0x7F, 0xE4, 0xB3, 0x6B, 0xDF, 0xEE, 0xC1, 0xFF,
  0x00, 0xA2, 0x22, 0xAE, 0x46, 0xBE, 0xD7, 0x22, 0xC8, 0xB0, 0x98, 0xDC, 0x22, 0xAD, 0x59, 0x3B, 0xDD, 0xF5, 0x39, 0xAA, 0xD5, 0x94, 0x65, 0x64, 0x75, 0xDF, 0xF0, 0xB7, 0x7E, 0x24, 0xFF, 0x00, 0xD0, 0xC6, 0x9F, 0xF8, 0x07, 0x07, 0xFF, 0x00,
  0x1B, 0xA3, 0xFE, 0x16, 0xEF, 0xC4, 0x9F, 0xFA, 0x18, 0xD3, 0xFF, 0x00, 0x00, 0xE0, 0xFF, 0x00, 0xE3, 0x75, 0xC8, 0xD1, 0x5E, 0xCF, 0xFA, 0xAB, 0x97, 0x76, 0x7F, 0x79, 0x9F, 0xB7, 0x99, 0xD7, 0x7F, 0xC2, 0xDD, 0xF8, 0x93, 0xFF, 0x00, 0x43,
  0x1A, 0x7F, 0xE0, 0x1C, 0x1F, 0xFC, 0x6E, 0x8F, 0xF8, 0x5B, 0xBF, 0x12, 0x7F, 0xE8, 0x63, 0x4F, 0xFC, 0x03, 0x83, 0xFF, 0x00, 0x8D, 0xD7, 0x23, 0x45, 0x1F, 0xEA, 0xAE, 0x5D, 0xD9, 0xFD, 0xE1, 0xED, 0xE6, 0x75, 0xDF, 0xF0, 0xB7, 0x7E, 0x24,
  0xFF, 0x00, 0xD0, 0xC6, 0x9F, 0xF8, 0x07, 0x07, 0xFF, 0x00, 0x1B, 0xAD, 0x8D, 0x03, 0xC7, 0x3F, 0x15, 0x7C, 0x47, 0x60, 0xF7, 0x96, 0x7E, 0x27, 0xB5, 0x48, 0xD2, 0x53, 0x11, 0x13, 0x5A, 0xC2, 0x0E, 0x40, 0x07, 0xB4, 0x47, 0x8E, 0x45, 0x79,
  0xCD, 0x7A, 0x0F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAF, 0x88, 0xE3, 0x6C, 0x1D, 0x2C, 0x9F, 0x0F, 0x4E, 0xA6, 0x13, 0x47, 0x26, 0xEF, 0x7D, 0x76, 0xB7, 0xF9, 0x9C, 0x39, 0x96, 0x3A, 0xB6, 0x1F, 0x0A,
  0xEA, 0xD3, 0xDD, 0x34, 0x6D, 0x7F, 0x6C, 0xFC, 0x5F, 0xFF, 0x00, 0xA1, 0xAF, 0x4E, 0xFF, 0x00, 0xC0, 0x68, 0xBF, 0xF8, 0xCD, 0x1F, 0xDB, 0x3F, 0x17, 0xFF, 0x00, 0xE8, 0x6B, 0xD3, 0xBF, 0xF0, 0x1A, 0x2F, 0xFE, 0x33, 0x5B, 0xD4, 0x57, 0xE6,
  0xBF, 0xDB, 0x98, 0xBE, 0xEB, 0xEE, 0x3E, 0x67, 0xFD, 0x63, 0xC7, 0x77, 0x5F, 0x71, 0x83, 0xFD, 0xB3, 0xF1, 0x7F, 0xFE, 0x86, 0xBD, 0x3B, 0xFF, 0x00, 0x01, 0xA2, 0xFF, 0x00, 0xE3, 0x34, 0x7F, 0x6C, 0xFC, 0x5F, 0xFF, 0x00, 0xA1, 0xAF, 0x4E,
  0xFF, 0x00, 0xC0, 0x68, 0xBF, 0xF8, 0xCD, 0x6F, 0x51, 0x47, 0xF6, 0xE6, 0x2F, 0xBA, 0xFB, 0x83, 0xFD, 0x63, 0xC7, 0x77, 0x5F, 0x71, 0x83, 0xFD, 0xB3, 0xF1, 0x7F, 0xFE, 0x86, 0xBD, 0x3B, 0xFF, 0x00, 0x01, 0xA2, 0xFF, 0x00, 0xE3, 0x35, 0x47,
  0x58, 0xF1, 0x77, 0xC5, 0x8D, 0x13, 0x4A, 0x9B, 0x51, 0xB9, 0xF1, 0x4D, 0x93, 0xC3, 0x0E, 0xDD, 0xCB, 0x1D, 0xAC, 0x45, 0x8E, 0x58, 0x28, 0xC6, 0x61, 0x1D, 0xCD, 0x75, 0x95, 0xCC, 0xFC, 0x40, 0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6,
  0x5F, 0xFA, 0x31, 0x6B, 0x6C, 0x36, 0x71, 0x8A, 0xA9, 0x5A, 0x10, 0x93, 0x56, 0x6D, 0x2D, 0xBC, 0xCE, 0x8C, 0x26, 0x7F, 0x8C, 0xAB, 0x88, 0xA7, 0x4E, 0x4D, 0x59, 0xB4, 0xB6, 0xEE, 0xCE, 0x61, 0x3E, 0x2F, 0xFC, 0x48, 0x74, 0x56, 0x1E, 0x23,
  0x4C, 0x11, 0x9F, 0xF8, 0xF3, 0x83, 0xFF, 0x00, 0x8D, 0xD3, 0xBF, 0xE1, 0x6E, 0xFC, 0x49, 0xFF, 0x00, 0xA1, 0x8D, 0x3F, 0xF0, 0x0E, 0x0F, 0xFE, 0x37, 0x5C, 0x6C, 0x1F, 0xF1, 0xEF, 0x1F, 0xFB, 0xA3, 0xF9, 0x54, 0x95, 0xFB, 0xB5, 0x0E, 0x18,
  0xCB, 0xE7, 0x4A, 0x32, 0x69, 0xDD, 0xA5, 0xD4, 0xFA, 0xD7, 0x5E, 0x77, 0x3A, 0xEF, 0xF8, 0x5B, 0xBF, 0x12, 0x7F, 0xE8, 0x63, 0x4F, 0xFC, 0x03, 0x83, 0xFF, 0x00, 0x8D, 0xD1, 0xFF, 0x00, 0x0B, 0x77, 0xE2, 0x4F, 0xFD, 0x0C, 0x69, 0xFF, 0x00,
  0x80, 0x70, 0x7F, 0xF1, 0xBA, 0xE4, 0x68, 0xAD, 0x7F, 0xD5, 0x5C, 0xBB, 0xB3, 0xFB, 0xC5, 0xED, 0xE6, 0x75, 0xDF, 0xF0, 0xB7, 0x7E, 0x24, 0xFF, 0x00, 0xD0, 0xC6, 0x9F, 0xF8, 0x07, 0x07, 0xFF, 0x00, 0x1B, 0xA3, 0xFE, 0x16, 0xEF, 0xC4, 0x9F,
  0xFA, 0x18, 0xD3, 0xFF, 0x00, 0x00, 0xE0, 0xFF, 0x00, 0xE3, 0x75, 0xC8, 0xD1, 0x47, 0xFA, 0xAB, 0x97, 0x76, 0x7F, 0x78, 0x7B, 0x79, 0x9D, 0x7C, 0x3F, 0x16, 0xBE, 0x25, 0x4F, 0x7F, 0x6B, 0x66, 0xBE, 0x23, 0x8C, 0x49, 0x73, 0x2A, 0xC4, 0x84,
  0xD9, 0xC1, 0x80, 0x49, 0x00, 0x67, 0xF7, 0x7D, 0x39, 0xAE, 0xB3, 0xFB, 0x67, 0xE2, 0xFF, 0x00, 0xFD, 0x0D, 0x7A, 0x77, 0xFE, 0x03, 0x45, 0xFF, 0x00, 0xC6, 0x6B, 0xCA, 0x34, 0xEF, 0xF9, 0x19, 0xF4, 0x4F, 0xFA, 0xFD, 0x8B, 0xFF, 0x00, 0x43,
  0x5A, 0xF7, 0x5A, 0xFC, 0xA3, 0x8B, 0xEA, 0xCB, 0x2A, 0xCC, 0x5E, 0x1F, 0x0D, 0xF0, 0xD9, 0x6F, 0xAF, 0x44, 0xCF, 0x13, 0x38, 0xCD, 0x71, 0x38, 0x49, 0x41, 0x52, 0x6B, 0x54, 0xFA, 0x79, 0x98, 0x3F, 0xDB, 0x3F, 0x17, 0xFF, 0x00, 0xE8, 0x6B,
  0xD3, 0xBF, 0xF0, 0x1A, 0x2F, 0xFE, 0x33, 0x47, 0xF6, 0xCF, 0xC5, 0xFF, 0x00, 0xFA, 0x1A, 0xF4, 0xEF, 0xFC, 0x06, 0x8B, 0xFF, 0x00, 0x8C, 0xD6, 0xF5, 0x15, 0xF2, 0xBF, 0xDB, 0x98, 0xBE, 0xEB, 0xEE, 0x3C, 0x6F, 0xF5, 0x8F, 0x1D, 0xDD, 0x7D,
  0xC6, 0x0F, 0xF6, 0xCF, 0xC5, 0xFF, 0x00, 0xFA, 0x1A, 0xF4, 0xEF, 0xFC, 0x06, 0x8B, 0xFF, 0x00, 0x8C, 0xD1, 0xFD, 0xB3, 0xF1, 0x7F, 0xFE, 0x86, 0xBD, 0x3B, 0xFF, 0x00, 0x01, 0xA2, 0xFF, 0x00, 0xE3, 0x35, 0xBD, 0x45, 0x1F, 0xDB, 0x98, 0xBE,
  0xEB, 0xEE, 0x0F, 0xF5, 0x8F, 0x1D, 0xDD, 0x7D, 0xC6, 0x0F, 0xF6, 0xCF, 0xC5, 0xFF, 0x00, 0xFA, 0x1A, 0xF4, 0xEF, 0xFC, 0x06, 0x8B, 0xFF, 0x00, 0x8C, 0xD7, 0x33, 0xA9, 0x7C, 0x52, 0xF8, 0x99, 0xA5, 0xEB, 0x13, 0xE9, 0x93, 0xF8, 0x92, 0x26,
  0x9A, 0x10, 0xA5, 0x99, 0x2D, 0x20, 0x2A, 0x72, 0x01, 0xE3, 0x31, 0x03, 0xDC, 0x76, 0xAF, 0x44, 0xAF, 0x19, 0xF1, 0x87, 0xFC, 0x8F, 0xFA, 0x9F, 0xFB, 0xB1, 0xFF, 0x00, 0xE8, 0xB4, 0xAF, 0xA1, 0xE1, 0x6C, 0x4D, 0x4C, 0xCB, 0x32, 0x86, 0x1B,
  0x11, 0xF0, 0xBE, 0xDA, 0x76, 0x3D, 0x6C, 0x9F, 0x37, 0xC4, 0xE2, 0xEB, 0x4A, 0x15, 0x5A, 0xB2, 0x8D, 0xF6, 0xF3, 0x5F, 0xE6, 0x6D, 0xFF, 0x00, 0xC2, 0xDD, 0xF8, 0x93, 0xFF, 0x00, 0x43, 0x1A, 0x7F, 0xE0, 0x1C, 0x1F, 0xFC, 0x6E, 0x8F, 0xF8,
  0x5B, 0xBF, 0x12, 0x7F, 0xE8, 0x63, 0x4F, 0xFC, 0x03, 0x83, 0xFF, 0x00, 0x8D, 0xD7, 0x23, 0x45, 0x7E, 0xC1, 0xFE, 0xAA, 0xE5, 0xDD, 0x9F, 0xDE, 0x7B, 0xDE, 0xDE, 0x67, 0x5D, 0xFF, 0x00, 0x0B, 0x77, 0xE2, 0x4F, 0xFD, 0x0C, 0x69, 0xFF, 0x00,
  0x80, 0x70, 0x7F, 0xF1, 0xBA, 0x3F, 0xE1, 0x6E, 0xFC, 0x49, 0xFF, 0x00, 0xA1, 0x8D, 0x3F, 0xF0, 0x0E, 0x0F, 0xFE, 0x37, 0x5C, 0x8D, 0x14, 0x7F, 0xAA, 0xB9, 0x77, 0x67, 0xF7, 0x87, 0xB7, 0x99, 0xD7, 0x7F, 0xC2, 0xDD, 0xF8, 0x93, 0xFF, 0x00,
  0x43, 0x1A, 0x7F, 0xE0, 0x1C, 0x1F, 0xFC, 0x6E, 0x8F, 0xF8, 0x5B, 0xBF, 0x12, 0x7F, 0xE8, 0x63, 0x4F, 0xFC, 0x03, 0x83, 0xFF, 0x00, 0x8D, 0xD7, 0x23, 0x45, 0x1F, 0xEA, 0xAE, 0x5D, 0xD9, 0xFD, 0xE1, 0xED, 0xE6, 0x7A, 0x36, 0x81, 0xE3, 0x9F,
  0x8A, 0xBE, 0x23, 0xB0, 0x7B, 0xCB, 0x3F, 0x13, 0xDA, 0xA4, 0x69, 0x29, 0x88, 0x89, 0xAD, 0x61, 0x07, 0x20, 0x03, 0xDA, 0x23, 0xC7, 0x22, 0xB5, 0x7F, 0xB6, 0x7E, 0x2F, 0xFF, 0x00, 0xD0, 0xD7, 0xA7, 0x7F, 0xE0, 0x34, 0x5F, 0xFC, 0x66, 0xB1,
  0x7E, 0x15, 0xFF, 0x00, 0xC8, 0xB1, 0x73, 0xFF, 0x00, 0x5F, 0xAD, 0xFF, 0x00, 0xA0, 0x25, 0x77, 0x15, 0xF8, 0x3E, 0x37, 0x36, 0xC4, 0xD1, 0xC4, 0x4E, 0x9C, 0x1A, 0xB2, 0x7D, 0x8F, 0x97, 0xCC, 0x33, 0xDC, 0x5D, 0x0C, 0x54, 0xE9, 0x41, 0xAB,
  0x27, 0xD8, 0xC1, 0xFE, 0xD9, 0xF8, 0xBF, 0xFF, 0x00, 0x43, 0x5E, 0x9D, 0xFF, 0x00, 0x80, 0xD1, 0x7F, 0xF1, 0x9A, 0x3F, 0xB6, 0x7E, 0x2F, 0xFF, 0x00, 0xD0, 0xD7, 0xA7, 0x7F, 0xE0, 0x34, 0x5F, 0xFC, 0x66, 0xB7, 0xA8, 0xAE, 0x6F, 0xED, 0xCC,
  0x5F, 0x75, 0xF7, 0x1C, 0x7F, 0xEB, 0x1E, 0x3B, 0xBA, 0xFB, 0x8C, 0x1F, 0xED, 0x9F, 0x8B, 0xFF, 0x00, 0xF4, 0x35, 0xE9, 0xDF, 0xF8, 0x0D, 0x17, 0xFF, 0x00, 0x19, 0xA3, 0xFB, 0x67, 0xE2, 0xFF, 0x00, 0xFD, 0x0D, 0x7A, 0x77, 0xFE, 0x03, 0x45,
  0xFF, 0x00, 0xC6, 0x6B, 0x7A, 0x8A, 0x3F, 0xB7, 0x31, 0x7D, 0xD7, 0xDC, 0x1F, 0xEB, 0x1E, 0x3B, 0xBA, 0xFB, 0x8E, 0x4F, 0x58, 0xF1, 0x77, 0xC5, 0x8D, 0x13, 0x4A, 0x9B, 0x51, 0xB9, 0xF1, 0x4D, 0x93, 0xC3, 0x0E, 0xDD, 0xCB, 0x1D, 0xAC, 0x45,
  0x8E, 0x58, 0x28, 0xC6, 0x61, 0x1D, 0xCD, 0x7B, 0xEF, 0x84, 0xEF, 0xAE, 0x35, 0x3F, 0x06, 0xE8, 0x77, 0xF7, 0x92, 0x79, 0x97, 0x57, 0x5A, 0x7D, 0xBC, 0xD3, 0x3E, 0xD0, 0x37, 0x3B, 0x46, 0xA5, 0x8E, 0x07, 0x03, 0x24, 0x9E, 0x95, 0xE1, 0x1F,
  0x10, 0x3F, 0xE4, 0x48, 0xD4, 0x7F, 0xED, 0x97, 0xFE, 0x8C, 0x5A, 0xF6, 0xFF, 0x00, 0x02, 0x7F, 0xC9, 0x3C, 0xF0, 0xD7, 0xFD, 0x82, 0xAD, 0x7F, 0xF4, 0x52, 0xD7, 0xD0, 0x65, 0x58, 0xAA, 0x98, 0x9A, 0x2E, 0x75, 0x37, 0xBD, 0xBF, 0x04, 0x7D,
  0x46, 0x49, 0x8D, 0xAB, 0x8C, 0xC3, 0xBA, 0x95, 0x77, 0x4E, 0xDF, 0x82, 0xFF, 0x00, 0x33, 0xE6, 0xBF, 0x8B, 0xBF, 0xF2, 0x59, 0xB5, 0xEF, 0xF7, 0x60, 0xFF, 0x00, 0xD1, 0x11, 0x57, 0x23, 0x5D, 0x77, 0xC5, 0xDF, 0xF9, 0x2C, 0xDA, 0xF7, 0xFB,
  0xB0, 0x7F, 0xE8, 0x88, 0xAB, 0x91, 0xAF, 0xD8, 0x78, 0x57, 0xFE, 0x45, 0xCB, 0xD5, 0x9D, 0x95, 0xFE, 0x30, 0xA2, 0x8A, 0x2B, 0xE8, 0xCC, 0x42, 0x8A, 0x28, 0xA0, 0x02, 0xBD, 0x07, 0xE1, 0x5F, 0xFC, 0x8B, 0x17, 0x3F, 0xF5, 0xFA, 0xDF, 0xFA,
  0x02, 0x57, 0x9F, 0x57, 0xA0, 0xFC, 0x2B, 0xFF, 0x00, 0x91, 0x62, 0xE7, 0xFE, 0xBF, 0x5B, 0xFF, 0x00, 0x40, 0x4A, 0xFC, 0xBF, 0xC4, 0xFF, 0x00, 0xF7, 0x4A, 0x3E, 0xAF, 0xFF, 0x00, 0x6D, 0x3C, 0xBC, 0xEF, 0xFD, 0xC6, 0x5E, 0xA8, 0xEE, 0x28,
  0xA2, 0x8A, 0xFC, 0x4C, 0xF8, 0x70, 0xA2, 0x8A, 0x28, 0x00, 0xAE, 0x67, 0xE2, 0x07, 0xFC, 0x89, 0x1A, 0x8F, 0xFD, 0xB2, 0xFF, 0x00, 0xD1, 0x8B, 0x5D, 0x35, 0x73, 0x3F, 0x10, 0x3F, 0xE4, 0x48, 0xD4, 0x7F, 0xED, 0x97, 0xFE, 0x8C, 0x5A, 0xEA,
  0xC1, 0x7F, 0xBC, 0xD3, 0xFF, 0x00, 0x12, 0xFC, 0xCE, 0xCC, 0xBB, 0xFD, 0xF2, 0x97, 0xF8, 0xA3, 0xF9, 0xA3, 0xCA, 0x20, 0xFF, 0x00, 0x8F, 0x78, 0xFF, 0x00, 0xDD, 0x1F, 0xCA, 0xA4, 0xA8, 0xE0, 0xFF, 0x00, 0x8F, 0x78, 0xFF, 0x00, 0xDD, 0x1F,
  0xCA, 0xA4, 0xAF, 0xEA, 0xBC, 0x2F, 0xF0, 0x21, 0xE8, 0xBF, 0x23, 0xF4, 0x19, 0x6E, 0x14, 0x51, 0x45, 0x6E, 0x20, 0xA2, 0x8A, 0x28, 0x02, 0x4D, 0x3B, 0xFE, 0x46, 0x7D, 0x13, 0xFE, 0xBF, 0x62, 0xFF, 0x00, 0xD0, 0xD6, 0xBD, 0xD6, 0xBC, 0x2B,
  0x4E, 0xFF, 0x00, 0x91, 0x9F, 0x44, 0xFF, 0x00, 0xAF, 0xD8, 0xBF, 0xF4, 0x35, 0xAF, 0x75, 0xAF, 0xC0, 0x3C, 0x45, 0xFF, 0x00, 0x91, 0xC4, 0xBD, 0x17, 0xE4, 0x8F, 0x98, 0xE2, 0x4F, 0x8E, 0x97, 0xA3, 0xFC, 0xC2, 0x8A, 0x28, 0xAF, 0x82, 0x3E,
  0x68, 0x28, 0xA2, 0x8A, 0x00, 0x2B, 0xC6, 0x7C, 0x61, 0xFF, 0x00, 0x23, 0xFE, 0xA7, 0xFE, 0xEC, 0x7F, 0xFA, 0x2D, 0x2B, 0xD9, 0xAB, 0xC6, 0x7C, 0x61, 0xFF, 0x00, 0x23, 0xFE, 0xA7, 0xFE, 0xEC, 0x7F, 0xFA, 0x2D, 0x2B, 0xEC, 0x78, 0x13, 0xFE,
  0x47, 0x54, 0xFF, 0x00, 0xAE, 0xA8, 0xFA, 0x0E, 0x1C, 0xFF, 0x00, 0x79, 0x9F, 0xF8, 0x5F, 0xE6, 0x8C, 0xCA, 0x28, 0xA2, 0xBF, 0xA2, 0xCF, 0xAC, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0x28, 0xA2, 0x80, 0x3D, 0x07, 0xE1, 0x5F, 0xFC, 0x8B, 0x17, 0x3F, 0xF5, 0xFA, 0xDF, 0xFA, 0x02, 0x57, 0x71, 0x5C, 0x3F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAE, 0xE2, 0xBF, 0x94, 0x73, 0x2F, 0xF7, 0xBA, 0x9E,
  0xA7, 0xC2, 0xE7, 0x1F, 0xEF, 0xD5, 0x7D, 0x42, 0x8A, 0x28, 0xAE, 0x13, 0xCD, 0x0A,
  0x28, 0xA2, 0x80, 0x39, 0x9F, 0x88, 0x1F, 0xF2, 0x24, 0x6A, 0x3F, 0xF6, 0xCB, 0xFF, 0x00, 0x46, 0x2D, 0x7B, 0x7F, 0x81, 0x3F, 0xE4, 0x9E, 0x78, 0x6B, 0xFE, 0xC1, 0x56, 0xBF, 0xFA, 0x29, 0x6B, 0xC4, 0x3E, 0x20, 0x7F, 0xC8, 0x91, 0xA8, 0xFF,
  0x00, 0xDB, 0x2F, 0xFD, 0x18, 0xB5, 0xED, 0xFE, 0x04, 0xFF, 0x00, 0x92, 0x79, 0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF, 0xAF, 0xC8, 0x3F, 0xDD, 0xA5, 0xFE, 0x27, 0xF9, 0x23, 0xEE, 0xF8, 0x5F, 0xFD, 0xCE, 0x5F, 0xE2, 0x7F,
  0x92, 0x3E, 0x6B, 0xF8, 0xBB, 0xFF, 0x00, 0x25, 0x9B, 0x5E, 0xFF, 0x00, 0x76, 0x0F, 0xFD, 0x11, 0x15, 0x72, 0x35, 0xD7, 0x7C, 0x5D, 0xFF, 0x00, 0x92, 0xCD, 0xAF, 0x7F, 0xBB, 0x07, 0xFE, 0x88, 0x8A, 0xB9, 0x1A, 0xFD, 0xAB, 0x85, 0x7F, 0xE4,
  0x5C, 0xBD, 0x59, 0xEB, 0xD7, 0xF8, 0xC2, 0x8A, 0x28, 0xAF, 0xA3, 0x31, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0xF4, 0x1F, 0x85, 0x7F, 0xF2, 0x2C, 0x5C, 0xFF, 0x00, 0xD7, 0xEB, 0x7F, 0xE8, 0x09, 0x5E, 0x7D, 0x5E, 0x83, 0xF0, 0xAF, 0xFE, 0x45, 0x8B, 0x9F, 0xFA, 0xFD, 0x6F, 0xFD, 0x01, 0x2B, 0xF2, 0xFF, 0x00, 0x13, 0xFF, 0x00, 0xDD, 0x28, 0xFA, 0xBF,
  0xFD, 0xB4, 0xF2, 0xF3, 0xBF, 0xF7, 0x19, 0x7A, 0xA3, 0xB8, 0xA2, 0x8A, 0x2B, 0xF1, 0x33, 0xE1, 0xC2, 0x8A, 0x28, 0xA0, 0x02, 0xB9, 0x9F, 0x88, 0x1F, 0xF2, 0x24, 0x6A, 0x3F, 0xF6, 0xCB, 0xFF, 0x00, 0x46, 0x2D, 0x74, 0xD5, 0xCC, 0xFC, 0x40,
  0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6, 0x5F, 0xFA, 0x31, 0x6B, 0xAB, 0x05, 0xFE, 0xF3, 0x4F, 0xFC, 0x4B, 0xF3, 0x3B, 0x32, 0xEF, 0xF7, 0xCA, 0x5F, 0xE2, 0x8F, 0xE6, 0x8F, 0x28, 0x83, 0xFE, 0x3D, 0xE3, 0xFF, 0x00, 0x74, 0x7F, 0x2A,
  0x92, 0xA3, 0x83, 0xFE, 0x3D, 0xE3, 0xFF, 0x00, 0x74, 0x7F, 0x2A, 0x92, 0xBF, 0xAA, 0xF0, 0xBF, 0xC0, 0x87, 0xA2, 0xFC, 0x8F, 0xD0, 0x65, 0xB8, 0x51, 0x45, 0x15, 0xB8, 0x82, 0x8A, 0x28, 0xA0, 0x09, 0x34, 0xEF, 0xF9, 0x19, 0xF4, 0x4F, 0xFA,
  0xFD, 0x8B, 0xFF, 0x00, 0x43, 0x5A, 0xF7, 0x5A, 0xF0, 0xAD, 0x3B, 0xFE, 0x46, 0x7D, 0x13, 0xFE, 0xBF, 0x62, 0xFF, 0x00, 0xD0, 0xD6, 0xBD, 0xD6, 0xBF, 0x00, 0xF1, 0x17, 0xFE, 0x47, 0x12, 0xF4, 0x5F, 0x92, 0x3E, 0x63, 0x89, 0x3E, 0x3A, 0x5E,
  0x8F, 0xF3, 0x0A,
  0x28, 0xA2, 0xBE, 0x08, 0xF9, 0xA0, 0xA2, 0x8A, 0x28, 0x00, 0xAF, 0x19, 0xF1, 0x87, 0xFC, 0x8F, 0xFA, 0x9F, 0xFB, 0xB1, 0xFF, 0x00, 0xE8, 0xB4, 0xAF, 0x66, 0xAF, 0x19, 0xF1, 0x87, 0xFC, 0x8F, 0xFA, 0x9F, 0xFB, 0xB1, 0xFF, 0x00, 0xE8, 0xB4,
  0xAF, 0xB1, 0xE0, 0x4F, 0xF9, 0x1D, 0x53, 0xFE, 0xBA, 0xA3, 0xE8, 0x38, 0x73, 0xFD, 0xE6, 0x7F, 0xE1, 0x7F, 0x9A, 0x33, 0x28, 0xA2, 0x8A, 0xFE, 0x8B, 0x3E, 0xB0, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0xF4, 0x1F, 0x85, 0x7F, 0xF2,
  0x2C, 0x5C, 0xFF, 0x00, 0xD7, 0xEB, 0x7F, 0xE8, 0x09, 0x5D, 0xC5, 0x70, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xE4, 0x58, 0xB9, 0xFF, 0x00, 0xAF, 0xD6, 0xFF, 0x00, 0xD0, 0x12, 0xBB, 0x8A, 0xFE, 0x51, 0xCC, 0xBF, 0xDE, 0xEA, 0x7A, 0x9F, 0x0B, 0x9C, 0x7F, 0xBF, 0x55, 0xF5, 0x0A,
  0x28, 0xA2, 0xB8, 0x4F, 0x34, 0x28, 0xA2, 0x8A, 0x00, 0xE6, 0x7E, 0x20, 0x7F, 0xC8, 0x91, 0xA8, 0xFF, 0x00, 0xDB, 0x2F, 0xFD, 0x18, 0xB5, 0xED, 0xFE, 0x04, 0xFF, 0x00, 0x92, 0x79, 0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF,
  0x10, 0xF8, 0x81, 0xFF, 0x00, 0x22, 0x46, 0xA3, 0xFF, 0x00, 0x6C, 0xBF, 0xF4, 0x62, 0xD7, 0xB7, 0xF8, 0x13, 0xFE, 0x49, 0xE7, 0x86, 0xBF, 0xEC, 0x15, 0x6B, 0xFF, 0x00, 0xA2, 0x96, 0xBE, 0xBF, 0x20, 0xFF, 0x00, 0x76, 0x97, 0xF8, 0x9F, 0xE4,
  0x8F, 0xBB, 0xE1, 0x7F, 0xF7, 0x39, 0x7F, 0x89, 0xFE, 0x48, 0xF9, 0xAF, 0xE2, 0xEF, 0xFC, 0x96, 0x6D, 0x7B, 0xFD, 0xD8, 0x3F, 0xF4, 0x44, 0x55, 0xC8, 0xD7, 0xA0, 0x7C, 0x41, 0xD0, 0x1B, 0xC4, 0x7F, 0x1C, 0xFC, 0x43, 0x66, 0xB7, 0x86, 0xD4,
  0xA4, 0x10, 0xCB, 0xBC, 0x26, 0xEC, 0xE2, 0x18, 0x46, 0x31, 0x91, 0xFD, 0xEF, 0xD2, 0xA8, 0xFF, 0x00, 0xC2, 0xAB, 0x97, 0xFE, 0x86, 0x07, 0xFF, 0x00, 0xC0, 0x63, 0xFF, 0x00, 0xC5, 0xD7, 0xDD, 0xE5, 0xDC, 0x65, 0x81, 0xCA, 0x68, 0x7D, 0x56,
  0xBA, 0x7C, 0xC9, 0xDF, 0xEF, 0xF9, 0x1D, 0x98, 0xDC, 0x7E, 0x12, 0x85, 0x5E, 0x4A, 0xB3, 0xB3, 0xF4, 0x6F, 0xF2, 0x47, 0x1B, 0x45, 0x76, 0x5F, 0xF0, 0xAA, 0xE5, 0xFF, 0x00, 0xA1, 0x81, 0xFF, 0x00, 0xF0, 0x18, 0xFF, 0x00, 0xF1, 0x74, 0x7F,
  0xC2, 0xAB, 0x97, 0xFE, 0x86, 0x07, 0xFF, 0x00, 0xC0, 0x63, 0xFF, 0x00, 0xC5, 0xD7, 0x77, 0xFC, 0x44, 0x9C, 0xAF, 0xF9, 0x5F, 0xE3, 0xFE, 0x47, 0x2F, 0xF6, 0xB6, 0x03, 0xFE, 0x7E, 0xFE, 0x12, 0xFF, 0x00, 0x23, 0x8D, 0xA2, 0xBB, 0x2F, 0xF8,
  0x55, 0x72, 0xFF, 0x00, 0xD0, 0xC0, 0xFF, 0x00, 0xF8, 0x0C, 0x7F, 0xF8, 0xBA, 0x3F, 0xE1, 0x55, 0xCB, 0xFF, 0x00, 0x43, 0x03, 0xFF, 0x00, 0xE0, 0x31, 0xFF, 0x00, 0xE2, 0xE8, 0xFF, 0x00, 0x88, 0x93, 0x95, 0xFF, 0x00, 0x2B, 0xFC, 0x7F, 0xC8,
  0x3F, 0xB5, 0xB0, 0x1F, 0xF3, 0xF7, 0xF0, 0x97, 0xF9, 0x1C, 0x6D, 0x7A, 0x0F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAA, 0x1F, 0xF0, 0xAA, 0xE5, 0xFF, 0x00, 0xA1, 0x81, 0xFF, 0x00, 0xF0, 0x18, 0xFF, 0x00, 0xF1,
  0x75, 0xC9, 0xF8, 0x7E, 0x0D, 0x4A, 0x5B, 0x07, 0x6B, 0x3D, 0x62, 0xEA, 0xCA, 0x3F, 0x34, 0x83, 0x1C, 0x2E, 0xC0, 0x13, 0x81, 0xCF, 0x0C, 0x39, 0xE9, 0xF9, 0x57, 0xCC, 0x71, 0x3E, 0x7D, 0x84, 0xE2, 0x1C, 0x3C, 0x61, 0x87, 0x7C, 0xBC, 0x8F,
  0x5B, 0xDF, 0xAD, 0xAD, 0xD3, 0xC8, 0xE9, 0xA3, 0x82, 0xFF, 0x00, 0x58, 0x29, 0xCB, 0x09, 0x80, 0x97, 0x34, 0xB4, 0x7D, 0xBB, 0xF7, 0xB1, 0xEE, 0x74, 0x57, 0x91, 0x7D, 0x93, 0x5C, 0xFF, 0x00, 0xA1, 0x9F, 0x51, 0xFF, 0x00, 0xBF, 0x8F, 0xFF,
  0x00, 0xC5, 0xD1, 0xF6, 0x4D, 0x73, 0xFE, 0x86, 0x7D, 0x47, 0xFE, 0xFE, 0x3F, 0xFF, 0x00, 0x17, 0x5F, 0x0B, 0xFD, 0x97, 0x1F, 0xF9, 0xFA, 0xBE, 0xE6, 0x1F, 0xF1, 0x0C, 0x73, 0x9E, 0xCB, 0xEF, 0x5F, 0xE6, 0x7A, 0xED, 0x15, 0xE4, 0x5F, 0x64,
  0xD7, 0x3F, 0xE8, 0x67, 0xD4, 0x7F, 0xEF, 0xE3, 0xFF, 0x00, 0xF1, 0x74, 0x7D, 0x93, 0x5C, 0xFF, 0x00, 0xA1, 0x9F, 0x51, 0xFF, 0x00, 0xBF, 0x8F, 0xFF, 0x00, 0xC5, 0xD1, 0xFD, 0x97, 0x1F, 0xF9, 0xFA, 0xBE, 0xE6, 0x1F, 0xF1, 0x0C, 0x73, 0x9E,
  0xCB, 0xEF, 0x5F, 0xE6, 0x7A, 0xED, 0x73, 0x3F, 0x10, 0x3F, 0xE4, 0x48, 0xD4, 0x7F, 0xED, 0x97, 0xFE, 0x8C, 0x5A, 0xE2, 0x3E, 0xC9, 0xAE, 0x7F, 0xD0, 0xCF, 0xA8, 0xFF, 0x00, 0xDF, 0xC7, 0xFF, 0x00, 0xE2, 0xEA, 0x8E, 0xB1, 0x6F, 0xAA, 0xC7,
  0xA5, 0x4C, 0xD7, 0x3A, 0xED, 0xED, 0xD4, 0x23, 0x6E, 0xE8, 0x64, 0x76, 0x2A, 0xDF, 0x30, 0xC6, 0x72, 0xC7, 0xBF, 0x3F, 0x85, 0x6F, 0x86, 0xCB, 0x63, 0x0A,
  0xD0, 0x97, 0xB4, 0x4E, 0xCD, 0x74, 0x7D, 0xCB, 0xA7, 0xE1, 0xDE, 0x6D, 0x84, 0x9A, 0xC4, 0xD4, 0x4B, 0x96, 0x0F, 0x99, 0xEA, 0xB6, 0x5A, 0xBE, 0xA6, 0x6C, 0x1F, 0xF1, 0xEF, 0x1F, 0xFB, 0xA3, 0xF9, 0x54, 0x95, 0xD4, 0x69, 0xBF, 0x0D, 0xA5,
  0xBF, 0xD2, 0xAC, 0xEF, 0x06, 0xB8, 0xF1, 0x89, 0xE0, 0x49, 0x76, 0x7D, 0x9C, 0x9D, 0xBB, 0x94, 0x1C, 0x67, 0x7F, 0x6C, 0xD5, 0xAF, 0xF8, 0x55, 0x72, 0xFF, 0x00, 0xD0, 0xC0, 0xFF, 0x00, 0xF8, 0x0C, 0x7F, 0xF8, 0xBA, 0xFD, 0x5E, 0x9F, 0x88,
  0xB9, 0x65, 0x28, 0x2A, 0x72, 0x4E, 0xE9, 0x5B, 0xAF, 0x4F, 0x91, 0xCB, 0x3C, 0xD7, 0x03, 0x19, 0x34, 0xEA, 0x6B, 0xE9, 0x2F, 0xF2, 0x38, 0xDA, 0x2B, 0xB2, 0xFF, 0x00, 0x85, 0x57, 0x2F, 0xFD, 0x0C, 0x0F, 0xFF, 0x00, 0x80, 0xC7, 0xFF, 0x00,
  0x8B, 0xA3, 0xFE, 0x15, 0x5C, 0xBF, 0xF4, 0x30, 0x3F, 0xFE, 0x03, 0x1F, 0xFE, 0x2E, 0xAF, 0xFE, 0x22, 0x4E, 0x57, 0xFC, 0xAF, 0xF1, 0xFF, 0x00, 0x22, 0x7F, 0xB5, 0xB0, 0x1F, 0xF3, 0xF7, 0xF0, 0x97, 0xF9, 0x1C, 0x6D, 0x15, 0xD9, 0x7F, 0xC2,
  0xAB, 0x97, 0xFE, 0x86, 0x07, 0xFF, 0x00, 0xC0, 0x63, 0xFF, 0x00, 0xC5, 0xD1, 0xFF, 0x00, 0x0A,
  0xAE, 0x5F, 0xFA, 0x18, 0x1F, 0xFF, 0x00, 0x01, 0x8F, 0xFF, 0x00, 0x17, 0x47, 0xFC, 0x44, 0x9C, 0xAF, 0xF9, 0x5F, 0xE3, 0xFE, 0x41, 0xFD, 0xAD, 0x80, 0xFF, 0x00, 0x9F, 0xBF, 0x84, 0xBF, 0xC8, 0xE4, 0x74, 0xEF, 0xF9, 0x19, 0xF4, 0x4F, 0xFA,
  0xFD, 0x8B, 0xFF, 0x00, 0x43, 0x5A, 0xF7, 0x5A, 0xF1, 0x7F, 0x11, 0x78, 0x52, 0x6F, 0x0D, 0xDF, 0xE9, 0x4A, 0xBA, 0xAC, 0x93, 0x49, 0x73, 0x29, 0x09, 0x20, 0x8C, 0xA1, 0x88, 0xA9, 0x5C, 0x11, 0xF3, 0x1E, 0x7E, 0x6F, 0x6E, 0x95, 0x6F, 0xEC,
  0x9A, 0xE7, 0xFD, 0x0C, 0xFA, 0x8F, 0xFD, 0xFC, 0x7F, 0xFE, 0x2E, 0xBE, 0x03, 0x89, 0x6B, 0xD1, 0xCE, 0xB1, 0x7F, 0x5D, 0xA5, 0x2E, 0x58, 0xC9, 0x69, 0x74, 0xFA, 0x59, 0x7E, 0x87, 0x5F, 0xFA, 0xB3, 0x8A, 0xE2, 0x2A, 0x70, 0xC4, 0x60, 0x1A,
  0x71, 0x8D, 0xD5, 0xF6, 0xEB, 0xE7, 0x66, 0x7A, 0xED, 0x15, 0xE4, 0x5F, 0x64, 0xD7, 0x3F, 0xE8, 0x67, 0xD4, 0x7F, 0xEF, 0xE3, 0xFF, 0x00, 0xF1, 0x74, 0x7D, 0x93, 0x5C, 0xFF, 0x00, 0xA1, 0x9F, 0x51, 0xFF, 0x00, 0xBF, 0x8F, 0xFF, 0x00, 0xC5,
  0xD7, 0xCE, 0xFF, 0x00, 0x65, 0xC7, 0xFE, 0x7E, 0xAF, 0xB9, 0x93, 0xFF, 0x00, 0x10, 0xC7, 0x39, 0xEC, 0xBE, 0xF5, 0xFE, 0x67, 0xAE, 0xD1, 0x5E, 0x45, 0xF6, 0x4D, 0x73, 0xFE, 0x86, 0x7D, 0x47, 0xFE, 0xFE, 0x3F, 0xFF, 0x00, 0x17, 0x47, 0xD9,
  0x35, 0xCF, 0xFA, 0x19, 0xF5, 0x1F, 0xFB, 0xF8, 0xFF, 0x00, 0xFC, 0x5D, 0x1F, 0xD9, 0x71, 0xFF, 0x00, 0x9F, 0xAB, 0xEE, 0x61, 0xFF, 0x00, 0x10, 0xC7, 0x39, 0xEC, 0xBE, 0xF5, 0xFE, 0x67, 0xAE, 0xD7, 0x8C, 0xF8, 0xC3, 0xFE, 0x47, 0xFD, 0x4F,
  0xFD, 0xD8, 0xFF, 0x00, 0xF4, 0x5A, 0x55, 0x9F, 0xB2, 0x6B, 0x9F, 0xF4, 0x33, 0xEA, 0x3F, 0xF7, 0xF1, 0xFF, 0x00, 0xF8, 0xBA, 0xA5, 0xA5, 0xF8, 0x76, 0xE7, 0xC4, 0x1E, 0x2A, 0xBB, 0xB1, 0x9F, 0x56, 0x94, 0x4D, 0x1C, 0x1E, 0x6B, 0x5C, 0xBA,
  0x97, 0x67, 0xC6, 0xC1, 0x83, 0x96, 0xCF, 0xF1, 0x0E, 0xFD, 0xAB, 0xDC, 0xE1, 0xE7, 0x4B, 0x29, 0xC6, 0xAC, 0x65, 0x49, 0xF3, 0x46, 0x2B, 0x54, 0x93, 0xEE, 0x8B, 0x8F, 0x09, 0xE3, 0x72, 0x08, 0xCB, 0x19, 0x8D, 0xB2, 0x83, 0x56, 0xBE, 0x8F,
  0x57, 0xAF, 0x46, 0xDF, 0x42, 0x85, 0x15, 0xD9, 0x7F, 0xC2, 0xAB, 0x97, 0xFE, 0x86, 0x07, 0xFF, 0x00, 0xC0, 0x63, 0xFF, 0x00, 0xC5, 0xD1, 0xFF, 0x00, 0x0A,
  0xAE, 0x5F, 0xFA, 0x18, 0x1F, 0xFF, 0x00, 0x01, 0x8F, 0xFF, 0x00, 0x17, 0x5F, 0xA2, 0xFF, 0x00, 0xC4, 0x49, 0xCA, 0xFF, 0x00, 0x95, 0xFE, 0x3F, 0xE4, 0x71, 0xFF, 0x00, 0x6B, 0x60, 0x3F, 0xE7, 0xEF, 0xE1, 0x2F, 0xF2, 0x38, 0xDA, 0x2B, 0xB2,
  0xFF, 0x00, 0x85, 0x57, 0x2F, 0xFD, 0x0C, 0x0F, 0xFF, 0x00, 0x80, 0xC7, 0xFF, 0x00, 0x8B, 0xA3, 0xFE, 0x15, 0x5C, 0xBF, 0xF4, 0x30, 0x3F, 0xFE, 0x03, 0x1F, 0xFE, 0x2E, 0x8F, 0xF8, 0x89, 0x39, 0x5F, 0xF2, 0xBF, 0xC7, 0xFC, 0x83, 0xFB, 0x5B,
  0x01, 0xFF, 0x00, 0x3F, 0x7F, 0x09, 0x7F, 0x91, 0xC6, 0xD1, 0x5D, 0x97, 0xFC, 0x2A, 0xB9, 0x7F, 0xE8, 0x60, 0x7F, 0xFC, 0x06, 0x3F, 0xFC, 0x5D, 0x1F, 0xF0, 0xAA, 0xE5, 0xFF, 0x00, 0xA1, 0x81, 0xFF, 0x00, 0xF0, 0x18, 0xFF, 0x00, 0xF1, 0x74,
  0x7F, 0xC4, 0x49, 0xCA, 0xFF, 0x00, 0x95, 0xFE, 0x3F, 0xE4, 0x1F, 0xDA, 0xD8, 0x0F, 0xF9, 0xFB, 0xF8, 0x4B, 0xFC, 0x8B, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xE4, 0x58, 0xB9, 0xFF, 0x00, 0xAF, 0xD6, 0xFF, 0x00, 0xD0, 0x12, 0xBB, 0x8A, 0xF0, 0xCF, 0x0F, 0xC1, 0xA9, 0x4B, 0x60, 0xED, 0x67, 0xAC, 0x5D, 0x59, 0x47, 0xE6, 0x90, 0x63, 0x85, 0xD8, 0x02, 0x70, 0x39, 0xE1, 0x87, 0x3D, 0x3F,
  0x2A, 0xD6, 0xFB, 0x26, 0xB9, 0xFF, 0x00, 0x43, 0x3E, 0xA3, 0xFF, 0x00, 0x7F, 0x1F, 0xFF, 0x00, 0x8B, 0xAF, 0xCA, 0x31, 0xB9, 0x74, 0x6A, 0x62, 0x27, 0x3F, 0x68, 0x95, 0xDF, 0x66, 0x76, 0xD6, 0xE0, 0x0C, 0xD7, 0x30, 0xA8, 0xF1, 0x74, 0x52,
  0xE5, 0x9E, 0xAB, 0x55, 0xFE, 0x67, 0xAE, 0xD1, 0x5E, 0x45, 0xF6, 0x4D, 0x73, 0xFE, 0x86, 0x7D, 0x47, 0xFE, 0xFE, 0x3F, 0xFF, 0x00, 0x17, 0x47, 0xD9, 0x35, 0xCF, 0xFA, 0x19, 0xF5, 0x1F, 0xFB, 0xF8, 0xFF, 0x00, 0xFC, 0x5D, 0x72, 0xFF, 0x00,
  0x65, 0xC7, 0xFE, 0x7E, 0xAF, 0xB9, 0x99, 0xFF, 0x00, 0xC4, 0x31, 0xCE, 0x7B, 0x2F, 0xBD, 0x7F, 0x99, 0xEB, 0xB4, 0x57, 0x91, 0x7D, 0x93, 0x5C, 0xFF, 0x00, 0xA1, 0x9F, 0x51, 0xFF, 0x00, 0xBF, 0x8F, 0xFF, 0x00, 0xC5, 0xD1, 0xF6, 0x4D, 0x73,
  0xFE, 0x86, 0x7D, 0x47, 0xFE, 0xFE, 0x3F, 0xFF, 0x00, 0x17, 0x47, 0xF6, 0x5C, 0x7F, 0xE7, 0xEA, 0xFB, 0x98, 0x7F, 0xC4, 0x31, 0xCE, 0x7B, 0x2F, 0xBD, 0x7F, 0x99, 0xDB, 0xFC, 0x40, 0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6, 0x5F, 0xFA,
  0x31, 0x6B, 0xDB, 0xFC, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5F, 0x25, 0xEB, 0x16, 0xFA, 0xAC, 0x7A, 0x54, 0xCD, 0x73, 0xAE, 0xDE, 0xDD, 0x42, 0x36, 0xEE, 0x86, 0x47, 0x62, 0xAD, 0xF3, 0x0C, 0x67, 0x2C, 0x7B, 0xF3, 0xF8, 0x57, 0xD6, 0x9E, 0x04, 0xFF, 0x00, 0x92, 0x79,
  0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF, 0xA1, 0xCA, 0x70, 0xEA, 0x85, 0x17, 0x15, 0x2B, 0xEB, 0xFA, 0x23, 0xD0, 0xC2, 0x64, 0x58, 0xAC, 0x92, 0x0F, 0x0D, 0x8A, 0xF8, 0x9B, 0xE6, 0xE9, 0xB3, 0xD3, 0xA3, 0x7D, 0x99, 0xE3,
  0x1A, 0xCF, 0xFC, 0x9C, 0x2F, 0x89, 0xBF, 0xEB, 0xCA, 0x2F, 0xFD, 0x17, 0x05, 0x6F, 0x56, 0x0E, 0xB3, 0xFF, 0x00, 0x27, 0x0B, 0xE2, 0x6F, 0xFA, 0xF2, 0x8B, 0xFF, 0x00, 0x45, 0xC1, 0x5B, 0xD5, 0xF3, 0xF9, 0xE7, 0xFB, 0xDB, 0xF4, 0x47, 0xC3,
  0xF1, 0x1F, 0xFB, 0xF3, 0xF4, 0x41, 0x45, 0x14, 0x57, 0x8E, 0x78, 0x21, 0x45, 0x14, 0x50, 0x01, 0x5E, 0x31, 0xE1, 0x5F, 0xF9, 0x05, 0xCB, 0xFF, 0x00, 0x5D, 0x8F, 0xFE, 0x82, 0xB5, 0xEC, 0xF5, 0xE3, 0x1E, 0x15, 0xFF, 0x00, 0x90, 0x5C, 0xBF,
  0xF5, 0xD8, 0xFF, 0x00, 0xE8, 0x2B, 0x5E, 0xD6, 0x57, 0xFC, 0x1A, 0xBF, 0xF6, 0xEF, 0xEA, 0x7E, 0xA7, 0xE1, 0x57, 0xFC, 0x8C, 0x6A, 0xFA, 0x2F, 0xD4, 0xDD, 0xA2, 0x8A, 0x2B, 0xAC, 0xFD, 0xF4, 0x28, 0xA2, 0x8A, 0x00, 0x2B, 0x33, 0xC4, 0x1F,
  0xF2, 0x03, 0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xB4, 0xEB, 0x33, 0xC4, 0x1F, 0xF2, 0x03, 0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xB5, 0xA1, 0xFC, 0x58, 0xFA, 0xA3, 0x87, 0x34, 0xFF, 0x00, 0x71, 0xAD, 0xFE, 0x09, 0x7E,
  0x4C, 0xF4, 0xAF, 0x0E, 0x7F, 0xC8, 0xB1, 0xA4, 0xFF, 0x00, 0xD7, 0x94, 0x3F, 0xFA, 0x00, 0xAD, 0x3A, 0xCC, 0xF0, 0xE7, 0xFC, 0x8B, 0x1A, 0x4F, 0xFD, 0x79, 0x43, 0xFF, 0x00, 0xA0, 0x0A,
  0xD3, 0xAF, 0x9A, 0xAD, 0xFC, 0x59, 0x7A, 0xB3, 0xF9, 0x0F, 0x11, 0xFC, 0x69, 0xFA, 0xBF, 0xCC, 0x28, 0xA2, 0x8A, 0xC8, 0xC4, 0x28, 0xA2, 0x8A, 0x00, 0xF3, 0xDF, 0x89, 0x3F, 0xF2, 0x14, 0xF0, 0xE7, 0xFD, 0x76, 0x7F, 0xFD, 0x0A,
  0x3A, 0xAF, 0x56, 0x3E, 0x24, 0xFF, 0x00, 0xC8, 0x53, 0xC3, 0x9F, 0xF5, 0xD9, 0xFF, 0x00, 0xF4, 0x28, 0xEA, 0xBD, 0x7D, 0x1D, 0x0F, 0xF7, 0x4A, 0x5F, 0x3F, 0xFD, 0x29, 0x9F, 0xD0, 0xFE, 0x17, 0xFF, 0x00, 0xC8, 0xA1, 0xFA, 0xBF, 0xCD, 0x85,
  0x14, 0x51, 0x54, 0x7E, 0x92, 0x14, 0x51, 0x45, 0x00, 0x14, 0x9E, 0x0C, 0xFF, 0x00, 0x92, 0x87, 0xA9, 0x7F, 0xD7, 0x97, 0xF5, 0x8E, 0x96, 0x93, 0xC1, 0x9F, 0xF2, 0x50, 0xF5, 0x2F, 0xFA, 0xF2, 0xFE, 0xB1, 0xD1, 0x2F, 0xE0, 0xD5, 0xFF, 0x00,
  0x0F, 0xEA, 0x8F, 0x83, 0xF1, 0x1F, 0xFE, 0x44, 0x72, 0xF5, 0x5F, 0x93, 0x3D, 0x2E, 0x8A, 0x28, 0xAF, 0x9A, 0x3F, 0x9A, 0xC2, 0x8A, 0x28, 0xA0, 0x02, 0x8A, 0x28, 0xA0, 0x0F, 0x18, 0xF0, 0xAF, 0xFC, 0x82, 0xE5, 0xFF, 0x00, 0xAE, 0xC7, 0xFF,
  0x00, 0x41, 0x5A, 0xDD, 0xAC, 0x2F, 0x0A,
  0xFF, 0x00, 0xC8, 0x2E, 0x5F, 0xFA, 0xEC, 0x7F, 0xF4, 0x15, 0xAD, 0xDA, 0xFA, 0xCC, 0x57, 0xF1, 0xA4, 0x7F, 0x5D, 0xE4, 0x7F, 0xF2, 0x2E, 0xA3, 0xE8, 0x14, 0x51, 0x45, 0x60, 0x7A, 0xA1, 0x45, 0x14, 0x50, 0x06, 0x67, 0x88, 0x3F, 0xE4, 0x07,
  0x73, 0xFF, 0x00, 0x01, 0xFF, 0x00, 0xD0, 0x85, 0x7D, 0x4D, 0xE0, 0x4F, 0xF9, 0x27, 0x9E, 0x1A, 0xFF, 0x00, 0xB0, 0x55, 0xAF, 0xFE, 0x8A, 0x5A, 0xF9, 0x67, 0xC4, 0x1F, 0xF2, 0x03, 0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xBE, 0xA6,
  0xF0, 0x27, 0xFC, 0x93, 0xCF, 0x0D, 0x7F, 0xD8, 0x2A, 0xD7, 0xFF, 0x00, 0x45, 0x2D, 0x7B, 0x19, 0x7F, 0xF0, 0x9F, 0xAF, 0xF9, 0x1F, 0x9C, 0x71, 0x7F, 0xFB, 0xF4, 0x3F, 0xC0, 0xBF, 0x39, 0x1E, 0x31, 0xAC, 0xFF, 0x00, 0xC9, 0xC2, 0xF8, 0x9B,
  0xFE, 0xBC, 0xA2, 0xFF, 0x00, 0xD1, 0x70, 0x56, 0xF5, 0x60, 0xEB, 0x3F, 0xF2, 0x70, 0xBE, 0x26, 0xFF, 0x00, 0xAF, 0x28, 0xBF, 0xF4, 0x5C, 0x15, 0xBD, 0x5F, 0x35, 0x9E, 0x7F, 0xBD, 0xBF, 0x44, 0x7E, 0x29, 0xC4, 0x7F, 0xEF, 0xCF, 0xD1, 0x05,
  0x14, 0x51, 0x5E, 0x39, 0xE0, 0x85, 0x14, 0x51, 0x40, 0x05, 0x78, 0xC7, 0x85, 0x7F, 0xE4, 0x17, 0x2F, 0xFD, 0x76, 0x3F, 0xFA, 0x0A,
  0xD7, 0xB3, 0xD7, 0x8C, 0x78, 0x57, 0xFE, 0x41, 0x72, 0xFF, 0x00, 0xD7, 0x63, 0xFF, 0x00, 0xA0, 0xAD, 0x7B, 0x59, 0x5F, 0xF0, 0x6A, 0xFF, 0x00, 0xDB, 0xBF, 0xA9, 0xFA, 0x9F, 0x85, 0x5F, 0xF2, 0x31, 0xAB, 0xE8, 0xBF, 0x53, 0x76, 0x8A, 0x28,
  0xAE, 0xB3, 0xF7, 0xD0, 0xA2, 0x8A, 0x28, 0x00, 0xAC, 0xCF, 0x10, 0x7F, 0xC8, 0x0E, 0xE7, 0xFE, 0x03, 0xFF, 0x00, 0xA1, 0x0A,
  0xD3, 0xAC, 0xCF, 0x10, 0x7F, 0xC8, 0x0E, 0xE7, 0xFE, 0x03, 0xFF, 0x00, 0xA1, 0x0A,
  0xD6, 0x87, 0xF1, 0x63, 0xEA, 0x8E, 0x1C, 0xD3, 0xFD, 0xC6, 0xB7, 0xF8, 0x25, 0xF9, 0x33, 0xD2, 0xBC, 0x39, 0xFF, 0x00, 0x22, 0xC6, 0x93, 0xFF, 0x00, 0x5E, 0x50, 0xFF, 0x00, 0xE8, 0x02, 0xB4, 0xEB, 0x33, 0xC3, 0x9F, 0xF2, 0x2C, 0x69, 0x3F,
  0xF5, 0xE5, 0x0F, 0xFE, 0x80, 0x2B, 0x4E, 0xBE, 0x6A, 0xB7, 0xF1, 0x65, 0xEA, 0xCF, 0xE4, 0x3C, 0x47, 0xF1, 0xA7, 0xEA, 0xFF, 0x00, 0x30, 0xA2, 0x8A, 0x2B, 0x23, 0x10, 0xA2, 0x8A, 0x28, 0x03, 0xCF, 0x7E, 0x24, 0xFF, 0x00, 0xC8, 0x53, 0xC3,
  0x9F, 0xF5, 0xD9, 0xFF, 0x00, 0xF4, 0x28, 0xEA, 0xBD, 0x58, 0xF8, 0x93, 0xFF, 0x00, 0x21, 0x4F, 0x0E, 0x7F, 0xD7, 0x67, 0xFF, 0x00, 0xD0, 0xA3, 0xAA, 0xF5, 0xF4, 0x74, 0x3F, 0xDD, 0x29, 0x7C, 0xFF, 0x00, 0xF4, 0xA6, 0x7F, 0x43, 0xF8, 0x5F,
  0xFF, 0x00, 0x22, 0x87, 0xEA, 0xFF, 0x00, 0x36, 0x14, 0x51, 0x45, 0x51, 0xFA, 0x48, 0x51, 0x45, 0x14, 0x00, 0x52, 0x78, 0x33, 0xFE, 0x4A, 0x1E, 0xA5, 0xFF, 0x00, 0x5E, 0x5F, 0xD6, 0x3A, 0x5A, 0x4F, 0x06, 0x7F, 0xC9, 0x43, 0xD4, 0xBF, 0xEB,
  0xCB, 0xFA, 0xC7, 0x44, 0xBF, 0x83, 0x57, 0xFC, 0x3F, 0xAA, 0x3E, 0x0F, 0xC4, 0x7F, 0xF9, 0x11, 0xCB, 0xD5, 0x7E, 0x4C, 0xF4, 0xBA, 0x28, 0xA2, 0xBE, 0x68, 0xFE, 0x6B, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0x28, 0xA2, 0x80, 0x3C, 0x63, 0xC2, 0xBF, 0xF2, 0x0B, 0x97, 0xFE, 0xBB, 0x1F, 0xFD, 0x05, 0x6B, 0x76, 0xB0, 0xBC, 0x2B, 0xFF, 0x00, 0x20, 0xB9, 0x7F, 0xEB, 0xB1, 0xFF, 0x00, 0xD0, 0x56, 0xB7, 0x6B, 0xEB, 0x31, 0x5F, 0xC6, 0x91, 0xFD, 0x77,
  0x91, 0xFF, 0x00, 0xC8, 0xBA, 0x8F, 0xA0, 0x51, 0x45, 0x15, 0x81, 0xEA, 0x85, 0x14, 0x51, 0x40, 0x19, 0x9E, 0x20, 0xFF, 0x00, 0x90, 0x1D, 0xCF, 0xFC, 0x07, 0xFF, 0x00, 0x42, 0x15, 0xF5, 0x37, 0x81, 0x3F, 0xE4, 0x9E, 0x78, 0x6B, 0xFE, 0xC1,
  0x56, 0xBF, 0xFA, 0x29, 0x6B, 0xE5, 0x9F, 0x10, 0x7F, 0xC8, 0x0E, 0xE7, 0xFE, 0x03, 0xFF, 0x00, 0xA1, 0x0A,
  0xFA, 0x9B, 0xC0, 0x9F, 0xF2, 0x4F, 0x3C, 0x35, 0xFF, 0x00, 0x60, 0xAB, 0x5F, 0xFD, 0x14, 0xB5, 0xEC, 0x65, 0xFF, 0x00, 0xC2, 0x7E, 0xBF, 0xE4, 0x7E, 0x71, 0xC5, 0xFF, 0x00, 0xEF, 0xD0, 0xFF, 0x00, 0x02, 0xFC, 0xE4, 0x78, 0xC6, 0xB3, 0xFF,
  0x00, 0x27, 0x0B, 0xE2, 0x6F, 0xFA, 0xF2, 0x8B, 0xFF, 0x00, 0x45, 0xC1, 0x5B, 0xD5, 0x83, 0xAC, 0xFF, 0x00, 0xC9, 0xC2, 0xF8, 0x9B, 0xFE, 0xBC, 0xA2, 0xFF, 0x00, 0xD1, 0x70, 0x56, 0xF5, 0x7C, 0xD6, 0x79, 0xFE, 0xF6, 0xFD, 0x11, 0xF8, 0xA7,
  0x11, 0xFF, 0x00, 0xBF, 0x3F, 0x44, 0x14, 0x51, 0x45, 0x78, 0xE7, 0x82, 0x14, 0x51, 0x45, 0x00, 0x15, 0xE3, 0x1E, 0x15, 0xFF, 0x00, 0x90, 0x5C, 0xBF, 0xF5, 0xD8, 0xFF, 0x00, 0xE8, 0x2B, 0x5E, 0xCF, 0x5E, 0x31, 0xE1, 0x5F, 0xF9, 0x05, 0xCB,
  0xFF, 0x00, 0x5D, 0x8F, 0xFE, 0x82, 0xB5, 0xED, 0x65, 0x7F, 0xC1, 0xAB, 0xFF, 0x00, 0x6E, 0xFE, 0xA7, 0xEA, 0x7E, 0x15, 0x7F, 0xC8, 0xC6, 0xAF, 0xA2, 0xFD, 0x4D, 0xDA, 0x28, 0xA2, 0xBA, 0xCF, 0xDF, 0x42, 0x8A, 0x28, 0xA0, 0x02, 0xB3, 0x3C,
  0x41, 0xFF, 0x00, 0x20, 0x3B, 0x9F, 0xF8, 0x0F, 0xFE, 0x84, 0x2B, 0x4E, 0xB3, 0x3C, 0x41, 0xFF, 0x00, 0x20, 0x3B, 0x9F, 0xF8, 0x0F, 0xFE, 0x84, 0x2B, 0x5A, 0x1F, 0xC5, 0x8F, 0xAA, 0x38, 0x73, 0x4F, 0xF7, 0x1A, 0xDF, 0xE0, 0x97, 0xE4, 0xCF,
  0x4A, 0xF0, 0xE7, 0xFC, 0x8B, 0x1A, 0x4F, 0xFD, 0x79, 0x43, 0xFF, 0x00, 0xA0, 0x0A,
  0xD3, 0xAC, 0xCF, 0x0E, 0x7F, 0xC8, 0xB1, 0xA4, 0xFF, 0x00, 0xD7, 0x94, 0x3F, 0xFA, 0x00, 0xAD, 0x3A, 0xF9, 0xAA, 0xDF, 0xC5, 0x97, 0xAB, 0x3F, 0x90, 0xF1, 0x1F, 0xC6, 0x9F, 0xAB, 0xFC, 0xC2, 0x8A, 0x28, 0xAC, 0x8C, 0x42, 0x8A, 0x28, 0xA0,
  0x0F, 0x3D, 0xF8, 0x93, 0xFF, 0x00, 0x21, 0x4F, 0x0E, 0x7F, 0xD7, 0x67, 0xFF, 0x00, 0xD0, 0xA3, 0xAA, 0xF5, 0x63, 0xE2, 0x4F, 0xFC, 0x85, 0x3C, 0x39, 0xFF, 0x00, 0x5D, 0x9F, 0xFF, 0x00, 0x42, 0x8E, 0xAB, 0xD7, 0xD1, 0xD0, 0xFF, 0x00, 0x74,
  0xA5, 0xF3, 0xFF, 0x00, 0xD2, 0x99, 0xFD, 0x0F, 0xE1, 0x7F, 0xFC, 0x8A, 0x1F, 0xAB, 0xFC, 0xD8, 0x51, 0x45, 0x15, 0x47, 0xE9, 0x21, 0x45, 0x14, 0x50, 0x01, 0x49, 0xE0, 0xCF, 0xF9, 0x28, 0x7A, 0x97, 0xFD, 0x79, 0x7F, 0x58, 0xE9, 0x69, 0x3C,
  0x19, 0xFF, 0x00, 0x25, 0x0F, 0x52, 0xFF, 0x00, 0xAF, 0x2F, 0xEB, 0x1D, 0x12, 0xFE, 0x0D, 0x5F, 0xF0, 0xFE, 0xA8, 0xF8, 0x3F, 0x11, 0xFF, 0x00, 0xE4, 0x47, 0x2F, 0x55, 0xF9, 0x33, 0xD2, 0xE8, 0xA2, 0x8A, 0xF9, 0xA3, 0xF9, 0xAC, 0x28, 0xA2,
  0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0xF1, 0x8F, 0x0A,
  0xFF, 0x00, 0xC8, 0x2E, 0x5F, 0xFA, 0xEC, 0x7F, 0xF4, 0x15, 0xAD, 0xDA, 0xC2, 0xF0, 0xAF, 0xFC, 0x82, 0xE5, 0xFF, 0x00, 0xAE, 0xC7, 0xFF, 0x00, 0x41, 0x5A, 0xDD, 0xAF, 0xAC, 0xC5, 0x7F, 0x1A, 0x47, 0xF5, 0xDE, 0x47, 0xFF, 0x00, 0x22, 0xEA,
  0x3E, 0x81, 0x45, 0x14, 0x56, 0x07, 0xAA, 0x14, 0x51, 0x45, 0x00, 0x66, 0x78, 0x83, 0xFE, 0x40, 0x77, 0x3F, 0xF0, 0x1F, 0xFD, 0x08, 0x57, 0xD4, 0xDE, 0x04, 0xFF, 0x00, 0x92, 0x79, 0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF,
  0x96, 0x7C, 0x41, 0xFF, 0x00, 0x20, 0x3B, 0x9F, 0xF8, 0x0F, 0xFE, 0x84, 0x2B, 0xEA, 0x6F, 0x02, 0x7F, 0xC9, 0x3C, 0xF0, 0xD7, 0xFD, 0x82, 0xAD, 0x7F, 0xF4, 0x52, 0xD7, 0xB1, 0x97, 0xFF, 0x00, 0x09, 0xFA, 0xFF, 0x00, 0x91, 0xF9, 0xC7, 0x17,
  0xFF, 0x00, 0xBF, 0x43, 0xFC, 0x0B, 0xF3, 0x91, 0xF3, 0x3F, 0xC6, 0x38, 0x56, 0x7F, 0x8C, 0x7A, 0xF2, 0xB1, 0x20, 0x05, 0x80, 0xF1, 0xFF, 0x00, 0x5C, 0x22, 0xAE, 0x2B, 0xFB, 0x3E, 0x2F, 0xEF, 0x3F, 0xE6, 0x3F, 0xC2, 0xBB, 0x9F, 0x8B, 0xBF,
  0xF2, 0x59, 0xB5, 0xEF, 0xF7, 0x60, 0xFF, 0x00, 0xD1, 0x11, 0x57, 0x23, 0x5F, 0xA6, 0xF0, 0xEE, 0x59, 0x84, 0xC4, 0x60, 0x55, 0x4A, 0xD4, 0xD3, 0x77, 0x7A, 0x9F, 0x17, 0x5A, 0x72, 0x52, 0xB2, 0x65, 0x4F, 0xEC, 0xF8, 0xBF, 0xBC, 0xFF, 0x00,
  0x98, 0xFF, 0x00, 0x0A,
  0x3F, 0xB3, 0xE2, 0xFE, 0xF3, 0xFE, 0x63, 0xFC, 0x2A, 0xDD, 0x15, 0xEE, 0xFF, 0x00, 0x61, 0xE5, 0xDF, 0xF3, 0xE9, 0x19, 0x7B, 0x59, 0xF7, 0x2A, 0x7F, 0x67, 0xC5, 0xFD, 0xE7, 0xFC, 0xC7, 0xF8, 0x51, 0xFD, 0x9F, 0x17, 0xF7, 0x9F, 0xF3, 0x1F,
  0xE1, 0x56, 0xE8, 0xA3, 0xFB, 0x0F, 0x2E, 0xFF, 0x00, 0x9F, 0x48, 0x3D, 0xAC, 0xFB, 0x95, 0x3F, 0xB3, 0xE2, 0xFE, 0xF3, 0xFE, 0x63, 0xFC, 0x2B, 0xA9, 0xF0, 0x5F, 0x82, 0xF4, 0xDF, 0x11, 0xE8, 0xD3, 0x5E, 0x5E, 0x4F, 0x74, 0x92, 0x25, 0xC3,
  0x44, 0x04, 0x2E, 0xA0, 0x60, 0x2A, 0x9E, 0xEA, 0x79, 0xE4, 0xD6, 0x0D, 0x7A, 0x0F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAF, 0xCF, 0xBC, 0x40, 0xC3, 0xD2, 0xCB, 0xF0, 0xD4, 0xA7, 0x84, 0x8F, 0x23, 0x6D, 0xDE,
  0xDF, 0x23, 0xCE, 0xCD, 0xB1, 0x55, 0xA9, 0x61, 0x25, 0x3A, 0x72, 0xB3, 0xBA, 0x0F, 0xF8, 0x55, 0x7A, 0x1F, 0xFC, 0xFD, 0x6A, 0x3F, 0xF7, 0xF1, 0x3F, 0xF8, 0x8A, 0x3F, 0xE1, 0x55, 0xE8, 0x7F, 0xF3, 0xF5, 0xA8, 0xFF, 0x00, 0xDF, 0xC4, 0xFF,
  0x00, 0xE2, 0x2B, 0xB8, 0xA2, 0xBF, 0x27, 0xFE, 0xD2, 0xC5, 0xFF, 0x00, 0xCF, 0xC6, 0x7C, 0x97, 0xF6, 0xBE, 0x3B, 0xFE, 0x7E, 0xB3, 0x87, 0xFF, 0x00, 0x85, 0x57, 0xA1, 0xFF, 0x00, 0xCF, 0xD6, 0xA3, 0xFF, 0x00, 0x7F, 0x13, 0xFF, 0x00, 0x88,
  0xA3, 0xFE, 0x15, 0x5E, 0x87, 0xFF, 0x00, 0x3F, 0x5A, 0x8F, 0xFD, 0xFC, 0x4F, 0xFE, 0x22, 0xBB, 0x8A, 0x28, 0xFE, 0xD2, 0xC5, 0xFF, 0x00, 0xCF, 0xC6, 0x1F, 0xDA, 0xF8, 0xEF, 0xF9, 0xFA, 0xCE, 0x1F, 0xFE, 0x15, 0x5E, 0x87, 0xFF, 0x00, 0x3F,
  0x5A, 0x8F, 0xFD, 0xFC, 0x4F, 0xFE, 0x22, 0xB1, 0xFC, 0x51, 0xE0, 0x0D, 0x2B, 0x44, 0xF0, 0xE5, 0xDE, 0xA3, 0x6D, 0x71, 0x7A, 0xF3, 0x43, 0xB3, 0x6A, 0xC8, 0xEA, 0x54, 0xE5, 0xD5, 0x4E, 0x70, 0xA3, 0xB1, 0xAF, 0x50, 0xAE, 0x67, 0xE2, 0x07,
  0xFC, 0x89, 0x1A, 0x8F, 0xFD, 0xB2, 0xFF, 0x00, 0xD1, 0x8B, 0x5D, 0x18, 0x4C, 0xC3, 0x15, 0x3A, 0xF0, 0x8C, 0xA6, 0xEC, 0xDA, 0xFC, 0xCE, 0x9C, 0x16, 0x6B, 0x8C, 0x9E, 0x26, 0x9C, 0x25, 0x51, 0xB4, 0xE4, 0x97, 0xE2, 0x78, 0xFC, 0x76, 0x31,
  0x3C, 0x48, 0xC5, 0x9F, 0x25, 0x41, 0xEA, 0x29, 0xDF, 0xD9, 0xF1, 0x7F, 0x79, 0xFF, 0x00, 0x31, 0xFE, 0x15, 0x3C, 0x1F, 0xF1, 0xEF, 0x1F, 0xFB, 0xA3, 0xF9, 0x54, 0x95, 0xFD, 0x17, 0x87, 0xC9, 0x72, 0xF9, 0x51, 0x84, 0x9D, 0x25, 0x76, 0x97,
  0xE4, 0x7D, 0xB3, 0xA9, 0x3B, 0xEE, 0x54, 0xFE, 0xCF, 0x8B, 0xFB, 0xCF, 0xF9, 0x8F, 0xF0, 0xA3, 0xFB, 0x3E, 0x2F, 0xEF, 0x3F, 0xE6, 0x3F, 0xC2, 0xAD, 0xD1, 0x5B, 0x7F, 0x61, 0xE5, 0xDF, 0xF3, 0xE9, 0x0B, 0xDA, 0xCF, 0xB9, 0x53, 0xFB, 0x3E,
  0x2F, 0xEF, 0x3F, 0xE6, 0x3F, 0xC2, 0x8F, 0xEC, 0xF8, 0xBF, 0xBC, 0xFF, 0x00, 0x98, 0xFF, 0x00, 0x0A,
  0xB7, 0x45, 0x1F, 0xD8, 0x79, 0x77, 0xFC, 0xFA, 0x41, 0xED, 0x67, 0xDC, 0xAF, 0x69, 0xA6, 0x43, 0x3E, 0xB3, 0xA7, 0x59, 0xB3, 0x48, 0x23, 0xB9, 0xB8, 0x48, 0x9C, 0x82, 0x32, 0x01, 0x60, 0x0E, 0x38, 0xEB, 0xCD, 0x7A, 0x4F, 0xFC, 0x2A, 0xBD,
  0x0F, 0xFE, 0x7E, 0xB5, 0x1F, 0xFB, 0xF8, 0x9F, 0xFC, 0x45, 0x70, 0x5A, 0x77, 0xFC, 0x8C, 0xFA, 0x27, 0xFD, 0x7E, 0xC5, 0xFF, 0x00, 0xA1, 0xAD, 0x7B, 0xAD, 0x7E, 0x31, 0xC7, 0x13, 0x96, 0x07, 0x34, 0x74, 0x70, 0xCF, 0x96, 0x36, 0x5A, 0x2F,
  0x44, 0x7C, 0xFE, 0x7B, 0x8E, 0xC4, 0xD0, 0x95, 0x35, 0x4A, 0x6D, 0x5D, 0x3F, 0xCC, 0xE1, 0xFF, 0x00, 0xE1, 0x55, 0xE8, 0x7F, 0xF3, 0xF5, 0xA8, 0xFF, 0x00, 0xDF, 0xC4, 0xFF, 0x00, 0xE2, 0x28, 0xFF, 0x00, 0x85, 0x57, 0xA1, 0xFF, 0x00, 0xCF,
  0xD6, 0xA3, 0xFF, 0x00, 0x7F, 0x13, 0xFF, 0x00, 0x88, 0xAE, 0xE2, 0x8A, 0xF8, 0xDF, 0xED, 0x2C, 0x5F, 0xFC, 0xFC, 0x67, 0x83, 0xFD, 0xAF, 0x8E, 0xFF, 0x00, 0x9F, 0xAC, 0xE1, 0xFF, 0x00, 0xE1, 0x55, 0xE8, 0x7F, 0xF3, 0xF5, 0xA8, 0xFF, 0x00,
  0xDF, 0xC4, 0xFF, 0x00, 0xE2, 0x28, 0xFF, 0x00, 0x85, 0x57, 0xA1, 0xFF, 0x00, 0xCF, 0xD6, 0xA3, 0xFF, 0x00, 0x7F, 0x13, 0xFF, 0x00, 0x88, 0xAE, 0xE2, 0x8A, 0x3F, 0xB4, 0xB1, 0x7F, 0xF3, 0xF1, 0x87, 0xF6, 0xBE, 0x3B, 0xFE, 0x7E, 0xB3, 0x87,
  0xFF, 0x00, 0x85, 0x57, 0xA1, 0xFF, 0x00, 0xCF, 0xD6, 0xA3, 0xFF, 0x00, 0x7F, 0x13, 0xFF, 0x00, 0x88, 0xAF, 0x3F, 0xD7, 0xB4, 0x4B, 0x6D, 0x2F, 0xC4, 0xF7, 0x9A, 0x64, 0x0F, 0x2B, 0x43, 0x0A,
  0xA1, 0x56, 0x72, 0x0B, 0x1C, 0xAA, 0x9E, 0x70, 0x00, 0xEE, 0x7B, 0x57, 0xBC, 0x57, 0x8C, 0xF8, 0xC3, 0xFE, 0x47, 0xFD, 0x4F, 0xFD, 0xD8, 0xFF, 0x00, 0xF4, 0x5A, 0x57, 0xD4, 0x70, 0x7D, 0x6A, 0x98, 0xCC, 0xD6, 0x14, 0x71, 0x0F, 0x9A, 0x2F,
  0xA3, 0xF5, 0x47, 0xB5, 0x91, 0x66, 0x18, 0x9A, 0xF5, 0xE5, 0x1A, 0xB3, 0x6D, 0x28, 0xB7, 0xF8, 0xA3, 0x07, 0xFB, 0x3E, 0x2F, 0xEF, 0x3F, 0xE6, 0x3F, 0xC2, 0x8F, 0xEC, 0xF8, 0xBF, 0xBC, 0xFF, 0x00, 0x98, 0xFF, 0x00, 0x0A,
  0xB7, 0x45, 0x7E, 0xE3, 0xFD, 0x87, 0x97, 0x7F, 0xCF, 0xA4, 0x7D, 0x27, 0xB5, 0x9F, 0x72, 0xA7, 0xF6, 0x7C, 0x5F, 0xDE, 0x7F, 0xCC, 0x7F, 0x85, 0x1F, 0xD9, 0xF1, 0x7F, 0x79, 0xFF, 0x00, 0x31, 0xFE, 0x15, 0x6E, 0x8A, 0x3F, 0xB0, 0xF2, 0xEF,
  0xF9, 0xF4, 0x83, 0xDA, 0xCF, 0xB9, 0x53, 0xFB, 0x3E, 0x2F, 0xEF, 0x3F, 0xE6, 0x3F, 0xC2, 0x8F, 0xEC, 0xF8, 0xBF, 0xBC, 0xFF, 0x00, 0x98, 0xFF, 0x00, 0x0A,
  0xB7, 0x45, 0x1F, 0xD8, 0x79, 0x77, 0xFC, 0xFA, 0x41, 0xED, 0x67, 0xDC, 0xDE, 0xF0, 0x5F, 0x82, 0xF4, 0xDF, 0x11, 0xE8, 0xD3, 0x5E, 0x5E, 0x4F, 0x74, 0x92, 0x25, 0xC3, 0x44, 0x04, 0x2E, 0xA0, 0x60, 0x2A, 0x9E, 0xEA, 0x79, 0xE4, 0xD7, 0x47,
  0xFF, 0x00, 0x0A,
  0xAF, 0x43, 0xFF, 0x00, 0x9F, 0xAD, 0x47, 0xFE, 0xFE, 0x27, 0xFF, 0x00, 0x11, 0x47, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAE, 0xE2, 0xBF, 0x9C, 0xB1, 0xF8, 0xFC, 0x4D, 0x3C, 0x4C, 0xE1, 0x09, 0xB4, 0x93, 0x3E,
  0x3F, 0x33, 0xCC, 0xF1, 0x74, 0xB1, 0x75, 0x21, 0x0A,
  0x8D, 0x24, 0xCE, 0x1F, 0xFE, 0x15, 0x5E, 0x87, 0xFF, 0x00, 0x3F, 0x5A, 0x8F, 0xFD, 0xFC, 0x4F, 0xFE, 0x22, 0x8F, 0xF8, 0x55, 0x7A, 0x1F, 0xFC, 0xFD, 0x6A, 0x3F, 0xF7, 0xF1, 0x3F, 0xF8, 0x8A, 0xEE, 0x28, 0xAE, 0x3F, 0xED, 0x2C, 0x5F, 0xFC,
  0xFC, 0x67, 0x0F, 0xF6, 0xBE, 0x3B, 0xFE, 0x7E, 0xB3, 0x87, 0xFF, 0x00, 0x85, 0x57, 0xA1, 0xFF, 0x00, 0xCF, 0xD6, 0xA3, 0xFF, 0x00, 0x7F, 0x13, 0xFF, 0x00, 0x88, 0xA3, 0xFE, 0x15, 0x5E, 0x87, 0xFF, 0x00, 0x3F, 0x5A, 0x8F, 0xFD, 0xFC, 0x4F,
  0xFE, 0x22, 0xBB, 0x8A, 0x28, 0xFE, 0xD2, 0xC5, 0xFF, 0x00, 0xCF, 0xC6, 0x1F, 0xDA, 0xF8, 0xEF, 0xF9, 0xFA, 0xCF, 0x2F, 0xF1, 0x47, 0x80, 0x34, 0xAD, 0x13, 0xC3, 0x97, 0x7A, 0x8D, 0xB5, 0xC5, 0xEB, 0xCD, 0x0E, 0xCD, 0xAB, 0x23, 0xA9, 0x53,
  0x97, 0x55, 0x39, 0xC2, 0x8E, 0xC6, 0xBE, 0x99, 0xF0, 0x27, 0xFC, 0x93, 0xCF, 0x0D, 0x7F, 0xD8, 0x2A, 0xD7, 0xFF, 0x00, 0x45, 0x2D, 0x78, 0x87, 0xC4, 0x0F, 0xF9, 0x12, 0x35, 0x1F, 0xFB, 0x65, 0xFF, 0x00, 0xA3, 0x16, 0xBD, 0xBF, 0xC0, 0x9F,
  0xF2, 0x4F, 0x3C, 0x35, 0xFF, 0x00, 0x60, 0xAB, 0x5F, 0xFD, 0x14, 0xB5, 0xF4, 0xD9, 0x35, 0x7A, 0x95, 0xA8, 0x39, 0x54, 0x77, 0x77, 0xFD, 0x11, 0xF6, 0x1C, 0x3F, 0x89, 0xAB, 0x88, 0xC3, 0x4A, 0x75, 0x65, 0x77, 0xCC, 0xD7, 0xE0, 0x8F, 0x9A,
  0xFE, 0x2E, 0xFF, 0x00, 0xC9, 0x66, 0xD7, 0xBF, 0xDD, 0x83, 0xFF, 0x00, 0x44, 0x45, 0x5C, 0x8D, 0x75, 0xDF, 0x17, 0x7F, 0xE4, 0xB3, 0x6B, 0xDF, 0xEE, 0xC1, 0xFF, 0x00, 0xA2, 0x22, 0xAE, 0x46, 0xBF, 0x65, 0xE1, 0x5F, 0xF9, 0x17, 0x2F, 0x56,
  0x7A, 0x15, 0xFE, 0x30, 0xA2, 0x8A, 0x2B, 0xE8, 0xCC, 0x42, 0x8A, 0x28, 0xA0, 0x02, 0xBD, 0x07, 0xE1, 0x5F, 0xFC, 0x8B, 0x17, 0x3F, 0xF5, 0xFA, 0xDF, 0xFA, 0x02, 0x57, 0x9F, 0x57, 0xA0, 0xFC, 0x2B, 0xFF, 0x00, 0x91, 0x62, 0xE7, 0xFE, 0xBF,
  0x5B, 0xFF, 0x00, 0x40, 0x4A, 0xFC, 0xBF, 0xC4, 0xFF, 0x00, 0xF7, 0x4A, 0x3E, 0xAF, 0xFF, 0x00, 0x6D, 0x3C, 0xBC, 0xEF, 0xFD, 0xC6, 0x5E, 0xA8, 0xEE, 0x28, 0xA2, 0x8A, 0xFC, 0x4C, 0xF8, 0x70, 0xA2, 0x8A, 0x28, 0x00, 0xAE, 0x67, 0xE2, 0x07,
  0xFC, 0x89, 0x1A, 0x8F, 0xFD, 0xB2, 0xFF, 0x00, 0xD1, 0x8B, 0x5D, 0x35, 0x73, 0x3F, 0x10, 0x3F, 0xE4, 0x48, 0xD4, 0x7F, 0xED, 0x97, 0xFE, 0x8C, 0x5A, 0xEA, 0xC1, 0x7F, 0xBC, 0xD3, 0xFF, 0x00, 0x12, 0xFC, 0xCE, 0xCC, 0xBB, 0xFD, 0xF2, 0x97,
  0xF8, 0xA3, 0xF9, 0xA3, 0xCA, 0x20, 0xFF, 0x00, 0x8F, 0x78, 0xFF, 0x00, 0xDD, 0x1F, 0xCA, 0xA4, 0xA8, 0xE0, 0xFF, 0x00, 0x8F, 0x78, 0xFF, 0x00, 0xDD, 0x1F, 0xCA, 0xA4, 0xAF, 0xEA, 0xBC, 0x2F, 0xF0, 0x21, 0xE8, 0xBF, 0x23, 0xF4, 0x19, 0x6E,
  0x14, 0x51, 0x45, 0x6E, 0x20, 0xA2, 0x8A, 0x28, 0x02, 0x4D, 0x3B, 0xFE, 0x46, 0x7D, 0x13, 0xFE, 0xBF, 0x62, 0xFF, 0x00, 0xD0, 0xD6, 0xBD, 0xD6, 0xBC, 0x2B, 0x4E, 0xFF, 0x00, 0x91, 0x9F, 0x44, 0xFF, 0x00, 0xAF, 0xD8, 0xBF, 0xF4, 0x35, 0xAF,
  0x75, 0xAF, 0xC0, 0x3C, 0x45, 0xFF, 0x00, 0x91, 0xC4, 0xBD, 0x17, 0xE4, 0x8F, 0x98, 0xE2, 0x4F, 0x8E, 0x97, 0xA3, 0xFC, 0xC2, 0x8A, 0x28, 0xAF, 0x82, 0x3E, 0x68, 0x28, 0xA2, 0x8A, 0x00, 0x2B, 0xC6, 0x7C, 0x61, 0xFF, 0x00, 0x23, 0xFE, 0xA7,
  0xFE, 0xEC, 0x7F, 0xFA, 0x2D, 0x2B, 0xD9, 0xAB, 0xC6, 0x7C, 0x61, 0xFF, 0x00, 0x23, 0xFE, 0xA7, 0xFE, 0xEC, 0x7F, 0xFA, 0x2D, 0x2B, 0xEC, 0x78, 0x13, 0xFE, 0x47, 0x54, 0xFF, 0x00, 0xAE, 0xA8, 0xFA, 0x0E, 0x1C, 0xFF, 0x00, 0x79, 0x9F, 0xF8,
  0x5F, 0xE6, 0x8C, 0xCA, 0x28, 0xA2, 0xBF, 0xA2, 0xCF, 0xAC, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0x28, 0xA2, 0x80, 0x3D, 0x07, 0xE1, 0x5F, 0xFC, 0x8B, 0x17, 0x3F, 0xF5, 0xFA, 0xDF, 0xFA, 0x02, 0x57, 0x71, 0x5C, 0x3F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAE, 0xE2, 0xBF, 0x94, 0x73, 0x2F, 0xF7, 0xBA, 0x9E,
  0xA7, 0xC2, 0xE7, 0x1F, 0xEF, 0xD5, 0x7D, 0x42, 0x8A, 0x28, 0xAE, 0x13, 0xCD, 0x0A,
  0x28, 0xA2, 0x80, 0x39, 0x9F, 0x88, 0x1F, 0xF2, 0x24, 0x6A, 0x3F, 0xF6, 0xCB, 0xFF, 0x00, 0x46, 0x2D, 0x7B, 0x7F, 0x81, 0x3F, 0xE4, 0x9E, 0x78, 0x6B, 0xFE, 0xC1, 0x56, 0xBF, 0xFA, 0x29, 0x6B, 0xC4, 0x3E, 0x20, 0x7F, 0xC8, 0x91, 0xA8, 0xFF,
  0x00, 0xDB, 0x2F, 0xFD, 0x18, 0xB5, 0xED, 0xFE, 0x04, 0xFF, 0x00, 0x92, 0x79, 0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF, 0xAF, 0xC8, 0x3F, 0xDD, 0xA5, 0xFE, 0x27, 0xF9, 0x23, 0xEE, 0xF8, 0x5F, 0xFD, 0xCE, 0x5F, 0xE2, 0x7F,
  0x92, 0x3E, 0x6B, 0xF8, 0xBB, 0xFF, 0x00, 0x25, 0x9B, 0x5E, 0xFF, 0x00, 0x76, 0x0F, 0xFD, 0x11, 0x15, 0x72, 0x35, 0xD7, 0x7C, 0x5D, 0xFF, 0x00, 0x92, 0xCD, 0xAF, 0x7F, 0xBB, 0x07, 0xFE, 0x88, 0x8A, 0xB9, 0x1A, 0xFD, 0xAB, 0x85, 0x7F, 0xE4,
  0x5C, 0xBD, 0x59, 0xEB, 0xD7, 0xF8, 0xC2, 0x8A, 0x28, 0xAF, 0xA3, 0x31, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0xF4, 0x1F, 0x85, 0x7F, 0xF2, 0x2C, 0x5C, 0xFF, 0x00, 0xD7, 0xEB, 0x7F, 0xE8, 0x09, 0x5E, 0x7D, 0x5E, 0x83, 0xF0, 0xAF, 0xFE, 0x45, 0x8B, 0x9F, 0xFA, 0xFD, 0x6F, 0xFD, 0x01, 0x2B, 0xF2, 0xFF, 0x00, 0x13, 0xFF, 0x00, 0xDD, 0x28, 0xFA, 0xBF,
  0xFD, 0xB4, 0xF2, 0xF3, 0xBF, 0xF7, 0x19, 0x7A, 0xA3, 0xB8, 0xA2, 0x8A, 0x2B, 0xF1, 0x33, 0xE1, 0xC2, 0x8A, 0x28, 0xA0, 0x02, 0xB9, 0x9F, 0x88, 0x1F, 0xF2, 0x24, 0x6A, 0x3F, 0xF6, 0xCB, 0xFF, 0x00, 0x46, 0x2D, 0x74, 0xD5, 0xCC, 0xFC, 0x40,
  0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6, 0x5F, 0xFA, 0x31, 0x6B, 0xAB, 0x05, 0xFE, 0xF3, 0x4F, 0xFC, 0x4B, 0xF3, 0x3B, 0x32, 0xEF, 0xF7, 0xCA, 0x5F, 0xE2, 0x8F, 0xE6, 0x8F, 0x28, 0x83, 0xFE, 0x3D, 0xE3, 0xFF, 0x00, 0x74, 0x7F, 0x2A,
  0x92, 0xA3, 0x83, 0xFE, 0x3D, 0xE3, 0xFF, 0x00, 0x74, 0x7F, 0x2A, 0x92, 0xBF, 0xAA, 0xF0, 0xBF, 0xC0, 0x87, 0xA2, 0xFC, 0x8F, 0xD0, 0x65, 0xB8, 0x51, 0x45, 0x15, 0xB8, 0x82, 0x8A, 0x28, 0xA0, 0x09, 0x34, 0xEF, 0xF9, 0x19, 0xF4, 0x4F, 0xFA,
  0xFD, 0x8B, 0xFF, 0x00, 0x43, 0x5A, 0xF7, 0x5A, 0xF0, 0xAD, 0x3B, 0xFE, 0x46, 0x7D, 0x13, 0xFE, 0xBF, 0x62, 0xFF, 0x00, 0xD0, 0xD6, 0xBD, 0xD6, 0xBF, 0x00, 0xF1, 0x17, 0xFE, 0x47, 0x12, 0xF4, 0x5F, 0x92, 0x3E, 0x63, 0x89, 0x3E, 0x3A, 0x5E,
  0x8F, 0xF3, 0x0A,
  0x28, 0xA2, 0xBE, 0x08, 0xF9, 0xA0, 0xA2, 0x8A, 0x28, 0x00, 0xAF, 0x19, 0xF1, 0x87, 0xFC, 0x8F, 0xFA, 0x9F, 0xFB, 0xB1, 0xFF, 0x00, 0xE8, 0xB4, 0xAF, 0x66, 0xAF, 0x19, 0xF1, 0x87, 0xFC, 0x8F, 0xFA, 0x9F, 0xFB, 0xB1, 0xFF, 0x00, 0xE8, 0xB4,
  0xAF, 0xB1, 0xE0, 0x4F, 0xF9, 0x1D, 0x53, 0xFE, 0xBA, 0xA3, 0xE8, 0x38, 0x73, 0xFD, 0xE6, 0x7F, 0xE1, 0x7F, 0x9A, 0x33, 0x28, 0xA2, 0x8A, 0xFE, 0x8B, 0x3E, 0xB0, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0xF4, 0x1F, 0x85, 0x7F, 0xF2,
  0x2C, 0x5C, 0xFF, 0x00, 0xD7, 0xEB, 0x7F, 0xE8, 0x09, 0x5D, 0xC5, 0x70, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xE4, 0x58, 0xB9, 0xFF, 0x00, 0xAF, 0xD6, 0xFF, 0x00, 0xD0, 0x12, 0xBB, 0x8A, 0xFE, 0x51, 0xCC, 0xBF, 0xDE, 0xEA, 0x7A, 0x9F, 0x0B, 0x9C, 0x7F, 0xBF, 0x55, 0xF5, 0x0A,
  0x28, 0xA2, 0xB8, 0x4F, 0x34, 0x28, 0xA2, 0x8A, 0x00, 0xE6, 0x7E, 0x20, 0x7F, 0xC8, 0x91, 0xA8, 0xFF, 0x00, 0xDB, 0x2F, 0xFD, 0x18, 0xB5, 0xED, 0xFE, 0x04, 0xFF, 0x00, 0x92, 0x79, 0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF,
  0x10, 0xF8, 0x81, 0xFF, 0x00, 0x22, 0x46, 0xA3, 0xFF, 0x00, 0x6C, 0xBF, 0xF4, 0x62, 0xD7, 0xB7, 0xF8, 0x13, 0xFE, 0x49, 0xE7, 0x86, 0xBF, 0xEC, 0x15, 0x6B, 0xFF, 0x00, 0xA2, 0x96, 0xBE, 0xBF, 0x20, 0xFF, 0x00, 0x76, 0x97, 0xF8, 0x9F, 0xE4,
  0x8F, 0xBB, 0xE1, 0x7F, 0xF7, 0x39, 0x7F, 0x89, 0xFE, 0x48, 0xF9, 0xA7, 0xE2, 0xFB, 0xAA, 0x7C, 0x65, 0xD7, 0x8B, 0x30, 0x51, 0xB6, 0x0E, 0x49, 0xC7, 0xFC, 0xB0, 0x8A, 0xB8, 0xFF, 0x00, 0x3E, 0x2F, 0xF9, 0xEA, 0x9F, 0xF7, 0xD0, 0xAF, 0x51,
  0xF1, 0x76, 0x8F, 0x61, 0xAD, 0xFC, 0x7C, 0xF1, 0x25, 0xB6, 0xA3, 0x07, 0x9D, 0x0A,
  0xDB, 0x43, 0x20, 0x5D, 0xEC, 0xB8, 0x61, 0x14, 0x03, 0x39, 0x52, 0x3B, 0x13, 0x53, 0x7F, 0xC2, 0xBF, 0xF0, 0xBF, 0xFD, 0x03, 0x3F, 0xF2, 0x62, 0x5F, 0xFE, 0x2A, 0xBE, 0xAF, 0x0F, 0xC6, 0xF1, 0xC9, 0xE1, 0xF5, 0x47, 0x4F, 0x9A, 0xDA, 0xDF,
  0xD7, 0xE6, 0x6D, 0x98, 0x66, 0xD8, 0x6C, 0x2D, 0x7F, 0x67, 0x51, 0x4A, 0xFE, 0x49, 0x7F, 0x9A, 0x3C, 0xA3, 0xCF, 0x8B, 0xFE, 0x7A, 0xA7, 0xFD, 0xF4, 0x28, 0xF3, 0xE2, 0xFF, 0x00, 0x9E, 0xA9, 0xFF, 0x00, 0x7D, 0x0A,
  0xF5, 0x7F, 0xF8, 0x57, 0xFE, 0x17, 0xFF, 0x00, 0xA0, 0x67, 0xFE, 0x4C, 0x4B, 0xFF, 0x00, 0xC5, 0x51, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xC2, 0xFF, 0x00, 0xF4, 0x0C, 0xFF, 0x00, 0xC9, 0x89, 0x7F, 0xF8, 0xAA, 0xDB, 0xFE, 0x22, 0x84, 0x7F, 0xE7, 0xCF, 0xF5, 0xF7, 0x9C, 0x3F, 0xEB, 0x06, 0x0B, 0xB4, 0xBE, 0xE5, 0xFE, 0x67, 0x94, 0x79, 0xF1, 0x7F, 0xCF, 0x54, 0xFF,
  0x00, 0xBE, 0x85, 0x1E, 0x7C, 0x5F, 0xF3, 0xD5, 0x3F, 0xEF, 0xA1, 0x5E, 0xAF, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xC2, 0xFF, 0x00, 0xF4, 0x0C, 0xFF, 0x00, 0xC9, 0x89, 0x7F, 0xF8, 0xAA, 0x3F, 0xE1, 0x5F, 0xF8, 0x5F, 0xFE, 0x81, 0x9F, 0xF9, 0x31, 0x2F, 0xFF, 0x00, 0x15, 0x47, 0xFC, 0x45, 0x08, 0xFF, 0x00, 0xCF, 0x9F, 0xEB, 0xEF, 0x0F, 0xF5,
  0x83, 0x05, 0xDA, 0x5F, 0x72, 0xFF, 0x00, 0x33, 0xCA, 0x3C, 0xF8, 0xBF, 0xE7, 0xAA, 0x7F, 0xDF, 0x42, 0xBB, 0x9F, 0x86, 0xDA, 0xB6, 0x9B, 0x61, 0xE1, 0xDB, 0x88, 0xAF, 0x35, 0x0B, 0x5B, 0x79, 0x0D, 0xDB, 0x30, 0x49, 0xA6, 0x54, 0x24, 0x6C,
  0x4E, 0x70, 0x4F, 0x4E, 0x0D, 0x6F, 0x7F, 0xC2, 0xBF, 0xF0, 0xBF, 0xFD, 0x03, 0x3F, 0xF2, 0x62, 0x5F, 0xFE, 0x2A, 0xBC, 0xCF, 0xC3, 0xFA, 0x5D, 0x95, 0xF5, 0x83, 0xCB, 0x71, 0x0E, 0xF7, 0x12, 0x95, 0x07, 0x71, 0x1C, 0x60, 0x7A, 0x1F, 0x7A,
  0xF1, 0xB3, 0xBE, 0x23, 0xA7, 0xC4, 0x74, 0x14, 0x65, 0x17, 0x05, 0x07, 0xF9, 0xFC, 0xFC, 0x8F, 0x5B, 0x2B, 0xC1, 0xD3, 0xE2, 0x7E, 0x7C, 0x1E, 0x1D, 0xB8, 0xB5, 0x67, 0x79, 0x7C, 0xFB, 0x5C, 0xF5, 0xFF, 0x00, 0xF8, 0x48, 0xF4, 0x3F, 0xFA,
  0x0C, 0xE9, 0xDF, 0xF8, 0x14, 0x9F, 0xE3, 0x47, 0xFC, 0x24, 0x7A, 0x1F, 0xFD, 0x06, 0x74, 0xEF, 0xFC, 0x0A,
  0x4F, 0xF1, 0xAF, 0x35, 0xFF, 0x00, 0x84, 0x7F, 0x4B, 0xFF, 0x00, 0x9F, 0x5F, 0xFC, 0x88, 0xDF, 0xE3, 0x47, 0xFC, 0x23, 0xFA, 0x5F, 0xFC, 0xFA, 0xFF, 0x00, 0xE4, 0x46, 0xFF, 0x00, 0x1A, 0xF9, 0x4F, 0xEC, 0xEC, 0x37, 0xF3, 0x4B, 0xEE, 0x5F,
  0xE6, 0x7A, 0xFF, 0x00, 0xF1, 0x09, 0xB1, 0x1F, 0xF3, 0xFD, 0x7E, 0x3F, 0xFC, 0x89, 0xE9, 0x5F, 0xF0, 0x91, 0xE8, 0x7F, 0xF4, 0x19, 0xD3, 0xBF, 0xF0, 0x29, 0x3F, 0xC6, 0x8F, 0xF8, 0x48, 0xF4, 0x3F, 0xFA, 0x0C, 0xE9, 0xDF, 0xF8, 0x14, 0x9F,
  0xE3, 0x5E, 0x6B, 0xFF, 0x00, 0x08, 0xFE, 0x97, 0xFF, 0x00, 0x3E, 0xBF, 0xF9, 0x11, 0xBF, 0xC6, 0x8F, 0xF8, 0x47, 0xF4, 0xBF, 0xF9, 0xF5, 0xFF, 0x00, 0xC8, 0x8D, 0xFE, 0x34, 0x7F, 0x67, 0x61, 0xBF, 0x9A, 0x5F, 0x72, 0xFF, 0x00, 0x30, 0xFF,
  0x00, 0x88, 0x4D, 0x88, 0xFF, 0x00, 0x9F, 0xEB, 0xF1, 0xFF, 0x00, 0xE4, 0x4F, 0x4A, 0xFF, 0x00, 0x84, 0x8F, 0x43, 0xFF, 0x00, 0xA0, 0xCE, 0x9D, 0xFF, 0x00, 0x81, 0x49, 0xFE, 0x35, 0xCF, 0x78, 0xE3, 0x5A, 0xD2, 0xAE, 0xFC, 0x1D, 0x7F, 0x05,
  0xB6, 0xA7, 0x65, 0x34, 0xCD, 0xE5, 0xED, 0x8E, 0x39, 0xD5, 0x98, 0xE2, 0x45, 0x27, 0x00, 0x1F, 0x4A, 0xE5, 0xBF, 0xE1, 0x1F, 0xD2, 0xFF, 0x00, 0xE7, 0xD7, 0xFF, 0x00, 0x22, 0x37, 0xF8, 0xD5, 0x1D, 0x63, 0x47, 0xB0, 0xB5, 0xD2, 0xA6, 0x9A,
  0x18, 0x36, 0xC8, 0xBB, 0x70, 0x77, 0xB1, 0xC6, 0x58, 0x0E, 0xE6, 0xB6, 0xC3, 0xE0, 0x70, 0xF1, 0xAD, 0x09, 0x29, 0x3B, 0xA6, 0xBA, 0x2E, 0xFE, 0xA1, 0xFF, 0x00, 0x10, 0xC6, 0xBE, 0x0B, 0xFD, 0xA9, 0xD6, 0x4D, 0x53, 0xF7, 0xAD, 0xAF, 0xD9,
  0xD7, 0xB7, 0x91, 0x95, 0x0C, 0xD1, 0x08, 0x23, 0x06, 0x44, 0x04, 0x28, 0xE3, 0x70, 0xF4, 0xA7, 0xF9, 0xF1, 0x7F, 0xCF, 0x54, 0xFF, 0x00, 0xBE, 0x85, 0x7A, 0x4E, 0x8B, 0xE0, 0x7F, 0x0E, 0x5D, 0xE8, 0x5A, 0x75, 0xCC, 0xFA, 0x76, 0xF9, 0xA6,
  0xB6, 0x8E, 0x47, 0x6F, 0x3E, 0x41, 0x96, 0x2A, 0x09, 0x38, 0x0D, 0xEB, 0x57, 0xBF, 0xE1, 0x5F, 0xF8, 0x5F, 0xFE, 0x81, 0x9F, 0xF9, 0x31, 0x2F, 0xFF, 0x00, 0x15, 0x5F, 0x7B, 0x1F, 0x12, 0xE3, 0x45, 0x2A, 0x5E, 0xC7, 0xE1, 0xD3, 0xEE, 0xF9,
  0x9F, 0x2B, 0x53, 0x3E, 0xC1, 0xC6, 0x6E, 0x2D, 0x4B, 0x4F, 0x25, 0xFE, 0x67, 0x94, 0x79, 0xF1, 0x7F, 0xCF, 0x54, 0xFF, 0x00, 0xBE, 0x85, 0x1E, 0x7C, 0x5F, 0xF3, 0xD5, 0x3F, 0xEF, 0xA1, 0x5E, 0xAF, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xC2, 0xFF, 0x00, 0xF4, 0x0C, 0xFF, 0x00, 0xC9, 0x89, 0x7F, 0xF8, 0xAA, 0x3F, 0xE1, 0x5F, 0xF8, 0x5F, 0xFE, 0x81, 0x9F, 0xF9, 0x31, 0x2F, 0xFF, 0x00, 0x15, 0x4F, 0xFE, 0x22, 0x84, 0x7F, 0xE7, 0xCF, 0xF5, 0xF7, 0x91, 0xFE, 0xB0,
  0x60, 0xBB, 0x4B, 0xEE, 0x5F, 0xE6, 0x79, 0x47, 0x9F, 0x17, 0xFC, 0xF5, 0x4F, 0xFB, 0xE8, 0x51, 0xE7, 0xC5, 0xFF, 0x00, 0x3D, 0x53, 0xFE, 0xFA, 0x15, 0xEA, 0xFF, 0x00, 0xF0, 0xAF, 0xFC, 0x2F, 0xFF, 0x00, 0x40, 0xCF, 0xFC, 0x98, 0x97, 0xFF,
  0x00, 0x8A, 0xA3, 0xFE, 0x15, 0xFF, 0x00, 0x85, 0xFF, 0x00, 0xE8, 0x19, 0xFF, 0x00, 0x93, 0x12, 0xFF, 0x00, 0xF1, 0x54, 0x7F, 0xC4, 0x50, 0x8F, 0xFC, 0xF9, 0xFE, 0xBE, 0xF0, 0xFF, 0x00, 0x58, 0x30, 0x5D, 0xA5, 0xF7, 0x2F, 0xF3, 0x3C, 0xB2,
  0xC2, 0xE2, 0x14, 0xF1, 0x16, 0x91, 0x2B, 0x4D, 0x1A, 0xC7, 0x1D, 0xDC, 0x6C, 0xEE, 0x58, 0x00, 0xA0, 0x3A, 0xE4, 0x93, 0xD8, 0x57, 0xB3, 0x7F, 0xC2, 0x47, 0xA1, 0xFF, 0x00, 0xD0, 0x67, 0x4E, 0xFF, 0x00, 0xC0, 0xA4, 0xFF, 0x00, 0x1A, 0xF3,
  0xBF, 0x1B, 0xF8, 0x6F, 0x49, 0xD2, 0x2F, 0xF4, 0x58, 0xAC, 0x6D, 0x3C, 0xA4, 0xB9, 0x95, 0xD6, 0x51, 0xE6, 0x3B, 0x6E, 0x00, 0xA6, 0x3A, 0x93, 0x8E, 0xA7, 0xA5, 0x43, 0xFF, 0x00, 0x08, 0xFE, 0x97, 0xFF, 0x00, 0x3E, 0xBF, 0xF9, 0x11, 0xBF,
  0xC6, 0xBE, 0x57, 0x3B, 0xC5, 0xD1, 0xCE, 0xEB, 0xAC, 0x74, 0xEF, 0x1E, 0x65, 0xB2, 0xB7, 0x4D, 0x3B, 0xF9, 0x1F, 0x43, 0x81, 0xE1, 0x57, 0xC5, 0x18, 0x78, 0xE2, 0xA8, 0x4F, 0x96, 0x31, 0xBA, 0xD7, 0x7D, 0xFC, 0x93, 0x3D, 0x2B, 0xFE, 0x12,
  0x3D, 0x0F, 0xFE, 0x83, 0x3A, 0x77, 0xFE, 0x05, 0x27, 0xF8, 0xD1, 0xFF, 0x00, 0x09, 0x1E, 0x87, 0xFF, 0x00, 0x41, 0x9D, 0x3B, 0xFF, 0x00, 0x02, 0x93, 0xFC, 0x6B, 0xCD, 0x7F, 0xE1, 0x1F, 0xD2, 0xFF, 0x00, 0xE7, 0xD7, 0xFF, 0x00, 0x22, 0x37,
  0xF8, 0xD1, 0xFF, 0x00, 0x08, 0xFE, 0x97, 0xFF, 0x00, 0x3E, 0xBF, 0xF9, 0x11, 0xBF, 0xC6, 0xBC, 0x5F, 0xEC, 0xEC, 0x37, 0xF3, 0x4B, 0xEE, 0x5F, 0xE6, 0x76, 0x7F, 0xC4, 0x26, 0xC4, 0x7F, 0xCF, 0xF5, 0xF8, 0xFF, 0x00, 0xF2, 0x27, 0xA5, 0x7F,
  0xC2, 0x47, 0xA1, 0xFF, 0x00, 0xD0, 0x67, 0x4E, 0xFF, 0x00, 0xC0, 0xA4, 0xFF, 0x00, 0x1A, 0x3F, 0xE1, 0x23, 0xD0, 0xFF, 0x00, 0xE8, 0x33, 0xA7, 0x7F, 0xE0, 0x52, 0x7F, 0x8D, 0x79, 0xAF, 0xFC, 0x23, 0xFA, 0x5F, 0xFC, 0xFA, 0xFF, 0x00, 0xE4,
  0x46, 0xFF, 0x00, 0x1A, 0x3F, 0xE1, 0x1F, 0xD2, 0xFF, 0x00, 0xE7, 0xD7, 0xFF, 0x00, 0x22, 0x37, 0xF8, 0xD1, 0xFD, 0x9D, 0x86, 0xFE, 0x69, 0x7D, 0xCB, 0xFC, 0xC3, 0xFE, 0x21, 0x36, 0x23, 0xFE, 0x7F, 0xAF, 0xC7, 0xFF, 0x00, 0x91, 0x3D, 0x2B,
  0xFE, 0x12, 0x3D, 0x0F, 0xFE, 0x83, 0x3A, 0x77, 0xFE, 0x05, 0x27, 0xF8, 0xD7, 0x93, 0x78, 0xAA, 0xEE, 0xDA, 0xE3, 0xC6, 0xFA, 0x85, 0xC4, 0x17, 0x11, 0x4B, 0x0B, 0xAC, 0x7B, 0x64, 0x47, 0x0C, 0xA7, 0xE4, 0x41, 0xC1, 0x1C, 0x76, 0x35, 0x7F,
  0xFE, 0x11, 0xFD, 0x2F, 0xFE, 0x7D, 0x7F, 0xF2, 0x23, 0x7F, 0x8D, 0x27, 0x86, 0x7C, 0x3F, 0xA5, 0xEA, 0x1E, 0x32, 0xBD, 0xB0, 0xBA, 0xB5, 0xF3, 0x2D, 0x62, 0xB6, 0xF3, 0x11, 0x3C, 0xC6, 0x18, 0x6C, 0xA7, 0x39, 0x07, 0x3F, 0xC4, 0x7F, 0x3A,
  0xF5, 0xB2, 0x6A, 0xB4, 0x72, 0x9C, 0x4F, 0xD7, 0x61, 0x79, 0x72, 0x2B, 0xD9, 0xDB, 0xBA, 0xF3, 0x39, 0xB1, 0x7C, 0x1B, 0x3E, 0x1A, 0xA1, 0x2C, 0x75, 0x6A, 0x9C, 0xD1, 0xF8, 0x6C, 0xB7, 0xD7, 0x5E, 0xA9, 0x76, 0xEE, 0x60, 0x79, 0xF1, 0x7F,
  0xCF, 0x54, 0xFF, 0x00, 0xBE, 0x85, 0x1E, 0x7C, 0x5F, 0xF3, 0xD5, 0x3F, 0xEF, 0xA1, 0x5E, 0xAF, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xC2, 0xFF, 0x00, 0xF4, 0x0C, 0xFF, 0x00, 0xC9, 0x89, 0x7F, 0xF8, 0xAA, 0x3F, 0xE1, 0x5F, 0xF8, 0x5F, 0xFE, 0x81, 0x9F, 0xF9, 0x31, 0x2F, 0xFF, 0x00, 0x15, 0x5F, 0x5D, 0xFF, 0x00, 0x11, 0x42, 0x3F, 0xF3, 0xE7, 0xFA, 0xFB, 0xCF,
  0x9B, 0xFF, 0x00, 0x58, 0x30, 0x5D, 0xA5, 0xF7, 0x2F, 0xF3, 0x3C, 0xA3, 0xCF, 0x8B, 0xFE, 0x7A, 0xA7, 0xFD, 0xF4, 0x28, 0xF3, 0xE2, 0xFF, 0x00, 0x9E, 0xA9, 0xFF, 0x00, 0x7D, 0x0A,
  0xF5, 0x7F, 0xF8, 0x57, 0xFE, 0x17, 0xFF, 0x00, 0xA0, 0x67, 0xFE, 0x4C, 0x4B, 0xFF, 0x00, 0xC5, 0x51, 0xFF, 0x00, 0x0A,
  0xFF, 0x00, 0xC2, 0xFF, 0x00, 0xF4, 0x0C, 0xFF, 0x00, 0xC9, 0x89, 0x7F, 0xF8, 0xAA, 0x3F, 0xE2, 0x28, 0x47, 0xFE, 0x7C, 0xFF, 0x00, 0x5F, 0x78, 0x7F, 0xAC, 0x18, 0x2E, 0xD2, 0xFB, 0x97, 0xF9, 0x9E, 0x51, 0xE7, 0xC5, 0xFF, 0x00, 0x3D, 0x53,
  0xFE, 0xFA, 0x14, 0x79, 0xF1, 0x7F, 0xCF, 0x54, 0xFF, 0x00, 0xBE, 0x85, 0x7A, 0xBF, 0xFC, 0x2B, 0xFF, 0x00, 0x0B, 0xFF, 0x00, 0xD0, 0x33, 0xFF, 0x00, 0x26, 0x25, 0xFF, 0x00, 0xE2, 0xA8, 0xFF, 0x00, 0x85, 0x7F, 0xE1, 0x7F, 0xFA, 0x06, 0x7F,
  0xE4, 0xC4, 0xBF, 0xFC, 0x55, 0x1F, 0xF1, 0x14, 0x23, 0xFF, 0x00, 0x3E, 0x7F, 0xAF, 0xBC, 0x3F, 0xD6, 0x0C, 0x17, 0x69, 0x7D, 0xCB, 0xFC, 0xCC, 0x1F, 0x86, 0xDA, 0xB6, 0x9B, 0x61, 0xE1, 0xDB, 0x88, 0xAF, 0x35, 0x0B, 0x5B, 0x79, 0x0D, 0xDB,
  0x30, 0x49, 0xA6, 0x54, 0x24, 0x6C, 0x4E, 0x70, 0x4F, 0x4E, 0x0D, 0x76, 0x3F, 0xF0, 0x91, 0xE8, 0x7F, 0xF4, 0x19, 0xD3, 0xBF, 0xF0, 0x29, 0x3F, 0xC6, 0xBC, 0x83, 0xC3, 0xFA, 0x5D, 0x95, 0xF5, 0x83, 0xCB, 0x71, 0x0E, 0xF7, 0x12, 0x95, 0x07,
  0x71, 0x1C, 0x60, 0x7A, 0x1F, 0x7A, 0xD5, 0xFF, 0x00, 0x84, 0x7F, 0x4B, 0xFF, 0x00, 0x9F, 0x5F, 0xFC, 0x88, 0xDF, 0xE3, 0x5F, 0x09, 0x8C, 0xC1, 0x61, 0xE7, 0x5E, 0x52, 0x94, 0x9D, 0xDB, 0xEC, 0xBF, 0xCC, 0xFA, 0xDF, 0xF8, 0x86, 0xF5, 0xF3,
  0x2F, 0xF6, 0xC8, 0xD5, 0x49, 0x4F, 0x5B, 0x6B, 0xFE, 0x47, 0xA5, 0x7F, 0xC2, 0x47, 0xA1, 0xFF, 0x00, 0xD0, 0x67, 0x4E, 0xFF, 0x00, 0xC0, 0xA4, 0xFF, 0x00, 0x1A, 0x3F, 0xE1, 0x23, 0xD0, 0xFF, 0x00, 0xE8, 0x33, 0xA7, 0x7F, 0xE0, 0x52, 0x7F,
  0x8D, 0x79, 0xAF, 0xFC, 0x23, 0xFA, 0x5F, 0xFC, 0xFA, 0xFF, 0x00, 0xE4, 0x46, 0xFF, 0x00, 0x1A, 0x3F, 0xE1, 0x1F, 0xD2, 0xFF, 0x00, 0xE7, 0xD7, 0xFF, 0x00, 0x22, 0x37, 0xF8, 0xD7, 0x37, 0xF6, 0x76, 0x1B, 0xF9, 0xA5, 0xF7, 0x2F, 0xF3, 0x0F,
  0xF8, 0x84, 0xD8, 0x8F, 0xF9, 0xFE, 0xBF, 0x1F, 0xFE, 0x44, 0xF4, 0xAF, 0xF8, 0x48, 0xF4, 0x3F, 0xFA, 0x0C, 0xE9, 0xDF, 0xF8, 0x14, 0x9F, 0xE3, 0x47, 0xFC, 0x24, 0x7A, 0x1F, 0xFD, 0x06, 0x74, 0xEF, 0xFC, 0x0A,
  0x4F, 0xF1, 0xAF, 0x35, 0xFF, 0x00, 0x84, 0x7F, 0x4B, 0xFF, 0x00, 0x9F, 0x5F, 0xFC, 0x88, 0xDF, 0xE3, 0x47, 0xFC, 0x23, 0xFA, 0x5F, 0xFC, 0xFA, 0xFF, 0x00, 0xE4, 0x46, 0xFF, 0x00, 0x1A, 0x3F, 0xB3, 0xB0, 0xDF, 0xCD, 0x2F, 0xB9, 0x7F, 0x98,
  0x7F, 0xC4, 0x26, 0xC4, 0x7F, 0xCF, 0xF5, 0xF8, 0xFF, 0x00, 0xF2, 0x27, 0x53, 0xE3, 0x8D, 0x6B, 0x4A, 0xBB, 0xF0, 0x75, 0xFC, 0x16, 0xDA, 0x9D, 0x94, 0xD3, 0x37, 0x97, 0xB6, 0x38, 0xE7, 0x56, 0x63, 0x89, 0x14, 0x9C, 0x00, 0x7D, 0x2B, 0xDF,
  0x7C, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5F, 0x25, 0xEB, 0x1A, 0x3D, 0x85, 0xAE, 0x95, 0x34, 0xD0, 0xC1, 0xB6, 0x45, 0xDB, 0x83, 0xBD, 0x8E, 0x32, 0xC0, 0x77, 0x35, 0xF5, 0xA7, 0x81, 0x3F, 0xE4, 0x9E, 0x78, 0x6B, 0xFE, 0xC1, 0x56, 0xBF, 0xFA, 0x29,
  0x6B, 0xDD, 0xCA, 0xE8, 0xC2, 0x8D, 0x17, 0x1A, 0x6D, 0xB5, 0x7E, 0xBE, 0x88, 0x5F, 0xEA, 0xF4, 0xF2, 0x1F, 0xF6, 0x59, 0xC9, 0x49, 0xBF, 0x7A, 0xEB, 0xCF, 0x4E, 0xCB, 0xB1, 0xE3, 0x1A, 0xCF, 0xFC, 0x9C, 0x2F, 0x89, 0xBF, 0xEB, 0xCA, 0x2F,
  0xFD, 0x17, 0x05, 0x6F, 0x56, 0x0E, 0xB3, 0xFF, 0x00, 0x27, 0x0B, 0xE2, 0x6F, 0xFA, 0xF2, 0x8B, 0xFF, 0x00, 0x45, 0xC1, 0x5B, 0xD5, 0xF3, 0xD9, 0xE7, 0xFB, 0xDB, 0xF4, 0x47, 0xE7, 0xDC, 0x47, 0xFE, 0xFC, 0xFD, 0x10, 0x51, 0x45, 0x15, 0xE3,
  0x9E, 0x08, 0x51, 0x45, 0x14, 0x00, 0x57, 0x8C, 0x78, 0x57, 0xFE, 0x41, 0x72, 0xFF, 0x00, 0xD7, 0x63, 0xFF, 0x00, 0xA0, 0xAD, 0x7B, 0x3D, 0x78, 0xC7, 0x85, 0x7F, 0xE4, 0x17, 0x2F, 0xFD, 0x76, 0x3F, 0xFA, 0x0A,
  0xD7, 0xB5, 0x95, 0xFF, 0x00, 0x06, 0xAF, 0xFD, 0xBB, 0xFA, 0x9F, 0xA9, 0xF8, 0x55, 0xFF, 0x00, 0x23, 0x1A, 0xBE, 0x8B, 0xF5, 0x37, 0x68, 0xA2, 0x8A, 0xEB, 0x3F, 0x7D, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0xCC, 0xF1, 0x07, 0xFC, 0x80, 0xEE, 0x7F, 0xE0, 0x3F, 0xFA, 0x10, 0xAD, 0x3A, 0xCC, 0xF1, 0x07, 0xFC, 0x80, 0xEE, 0x7F, 0xE0, 0x3F, 0xFA, 0x10, 0xAD, 0x68, 0x7F, 0x16, 0x3E, 0xA8, 0xE1, 0xCD, 0x3F, 0xDC, 0x6B, 0x7F, 0x82, 0x5F, 0x93, 0x3D,
  0x2B, 0xC3, 0x9F, 0xF2, 0x2C, 0x69, 0x3F, 0xF5, 0xE5, 0x0F, 0xFE, 0x80, 0x2B, 0x4E, 0xB3, 0x3C, 0x39, 0xFF, 0x00, 0x22, 0xC6, 0x93, 0xFF, 0x00, 0x5E, 0x50, 0xFF, 0x00, 0xE8, 0x02, 0xB4, 0xEB, 0xE6, 0xAB, 0x7F, 0x16, 0x5E, 0xAC, 0xFE, 0x43,
  0xC4, 0x7F, 0x1A, 0x7E, 0xAF, 0xF3, 0x0A,
  0x28, 0xA2, 0xB2, 0x31, 0x0A,
  0x28, 0xA2, 0x80, 0x3C, 0xF7, 0xE2, 0x4F, 0xFC, 0x85, 0x3C, 0x39, 0xFF, 0x00, 0x5D, 0x9F, 0xFF, 0x00, 0x42, 0x8E, 0xAB, 0xD5, 0x8F, 0x89, 0x3F, 0xF2, 0x14, 0xF0, 0xE7, 0xFD, 0x76, 0x7F, 0xFD, 0x0A,
  0x3A, 0xAF, 0x5F, 0x47, 0x43, 0xFD, 0xD2, 0x97, 0xCF, 0xFF, 0x00, 0x4A, 0x67, 0xF4, 0x3F, 0x85, 0xFF, 0x00, 0xF2, 0x28, 0x7E, 0xAF, 0xF3, 0x61, 0x45, 0x14, 0x55, 0x1F, 0xA4, 0x85, 0x14, 0x51, 0x40, 0x05, 0x27, 0x83, 0x3F, 0xE4, 0xA1, 0xEA,
  0x5F, 0xF5, 0xE5, 0xFD, 0x63, 0xA5, 0xA4, 0xF0, 0x67, 0xFC, 0x94, 0x3D, 0x4B, 0xFE, 0xBC, 0xBF, 0xAC, 0x74, 0x4B, 0xF8, 0x35, 0x7F, 0xC3, 0xFA, 0xA3, 0xE0, 0xFC, 0x47, 0xFF, 0x00, 0x91, 0x1C, 0xBD, 0x57, 0xE4, 0xCF, 0x4B, 0xA2, 0x8A, 0x2B,
  0xE6, 0x8F, 0xE6, 0xB0, 0xA2, 0x8A, 0x28, 0x00, 0xA2, 0x8A, 0x28, 0x03, 0xC6, 0x3C, 0x2B, 0xFF, 0x00, 0x20, 0xB9, 0x7F, 0xEB, 0xB1, 0xFF, 0x00, 0xD0, 0x56, 0xB7, 0x6B, 0x0B, 0xC2, 0xBF, 0xF2, 0x0B, 0x97, 0xFE, 0xBB, 0x1F, 0xFD, 0x05, 0x6B,
  0x76, 0xBE, 0xB3, 0x15, 0xFC, 0x69, 0x1F, 0xD7, 0x79, 0x1F, 0xFC, 0x8B, 0xA8, 0xFA, 0x05, 0x14, 0x51, 0x58, 0x1E, 0xA8, 0x51, 0x45, 0x14, 0x01, 0x99, 0xE2, 0x0F, 0xF9, 0x01, 0xDC, 0xFF, 0x00, 0xC0, 0x7F, 0xF4, 0x21, 0x5F, 0x53, 0x78, 0x13,
  0xFE, 0x49, 0xE7, 0x86, 0xBF, 0xEC, 0x15, 0x6B, 0xFF, 0x00, 0xA2, 0x96, 0xBE, 0x59, 0xF1, 0x07, 0xFC, 0x80, 0xEE, 0x7F, 0xE0, 0x3F, 0xFA, 0x10, 0xAF, 0xA9, 0xBC, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5E, 0xC6, 0x5F, 0xFC, 0x27, 0xEB, 0xFE, 0x47, 0xE7, 0x1C, 0x5F, 0xFE, 0xFD, 0x0F, 0xF0, 0x2F, 0xCE, 0x47, 0x8C, 0x6B, 0x3F, 0xF2, 0x70, 0xBE, 0x26, 0xFF, 0x00, 0xAF, 0x28, 0xBF, 0xF4, 0x5C, 0x15, 0xBD, 0x58,
  0x3A, 0xCF, 0xFC, 0x9C, 0x2F, 0x89, 0xBF, 0xEB, 0xCA, 0x2F, 0xFD, 0x17, 0x05, 0x6F, 0x57, 0xCD, 0x67, 0x9F, 0xEF, 0x6F, 0xD1, 0x1F, 0x8A, 0x71, 0x1F, 0xFB, 0xF3, 0xF4, 0x41, 0x45, 0x14, 0x57, 0x8E, 0x78, 0x21, 0x45, 0x14, 0x50, 0x01, 0x5E,
  0x31, 0xE1, 0x5F, 0xF9, 0x05, 0xCB, 0xFF, 0x00, 0x5D, 0x8F, 0xFE, 0x82, 0xB5, 0xEC, 0xF5, 0xE3, 0x1E, 0x15, 0xFF, 0x00, 0x90, 0x5C, 0xBF, 0xF5, 0xD8, 0xFF, 0x00, 0xE8, 0x2B, 0x5E, 0xD6, 0x57, 0xFC, 0x1A, 0xBF, 0xF6, 0xEF, 0xEA, 0x7E, 0xA7,
  0xE1, 0x57, 0xFC, 0x8C, 0x6A, 0xFA, 0x2F, 0xD4, 0xDD, 0xA2, 0x8A, 0x2B, 0xAC, 0xFD, 0xF4, 0x28, 0xA2, 0x8A, 0x00, 0x2B, 0x33, 0xC4, 0x1F, 0xF2, 0x03, 0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xB4, 0xEB, 0x33, 0xC4, 0x1F, 0xF2, 0x03,
  0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xB5, 0xA1, 0xFC, 0x58, 0xFA, 0xA3, 0x87, 0x34, 0xFF, 0x00, 0x71, 0xAD, 0xFE, 0x09, 0x7E, 0x4C, 0xF4, 0xAF, 0x0E, 0x7F, 0xC8, 0xB1, 0xA4, 0xFF, 0x00, 0xD7, 0x94, 0x3F, 0xFA, 0x00, 0xAD, 0x3A,
  0xCC, 0xF0, 0xE7, 0xFC, 0x8B, 0x1A, 0x4F, 0xFD, 0x79, 0x43, 0xFF, 0x00, 0xA0, 0x0A,
  0xD3, 0xAF, 0x9A, 0xAD, 0xFC, 0x59, 0x7A, 0xB3, 0xF9, 0x0F, 0x11, 0xFC, 0x69, 0xFA, 0xBF, 0xCC, 0x28, 0xA2, 0x8A, 0xC8, 0xC4, 0x28, 0xA2, 0x8A, 0x00, 0xF3, 0xDF, 0x89, 0x3F, 0xF2, 0x14, 0xF0, 0xE7, 0xFD, 0x76, 0x7F, 0xFD, 0x0A,
  0x3A, 0xAF, 0x56, 0x3E, 0x24, 0xFF, 0x00, 0xC8, 0x53, 0xC3, 0x9F, 0xF5, 0xD9, 0xFF, 0x00, 0xF4, 0x28, 0xEA, 0xBD, 0x7D, 0x1D, 0x0F, 0xF7, 0x4A, 0x5F, 0x3F, 0xFD, 0x29, 0x9F, 0xD0, 0xFE, 0x17, 0xFF, 0x00, 0xC8, 0xA1, 0xFA, 0xBF, 0xCD, 0x85,
  0x14, 0x51, 0x54, 0x7E, 0x92, 0x14, 0x51, 0x45, 0x00, 0x14, 0x9E, 0x0C, 0xFF, 0x00, 0x92, 0x87, 0xA9, 0x7F, 0xD7, 0x97, 0xF5, 0x8E, 0x96, 0x93, 0xC1, 0x9F, 0xF2, 0x50, 0xF5, 0x2F, 0xFA, 0xF2, 0xFE, 0xB1, 0xD1, 0x2F, 0xE0, 0xD5, 0xFF, 0x00,
  0x0F, 0xEA, 0x8F, 0x83, 0xF1, 0x1F, 0xFE, 0x44, 0x72, 0xF5, 0x5F, 0x93, 0x3D, 0x2E, 0x8A, 0x28, 0xAF, 0x9A, 0x3F, 0x9A, 0xC2, 0x8A, 0x28, 0xA0, 0x02, 0x8A, 0x28, 0xA0, 0x0F, 0x18, 0xF0, 0xAF, 0xFC, 0x82, 0xE5, 0xFF, 0x00, 0xAE, 0xC7, 0xFF,
  0x00, 0x41, 0x5A, 0xDD, 0xAC, 0x2F, 0x0A,
  0xFF, 0x00, 0xC8, 0x2E, 0x5F, 0xFA, 0xEC, 0x7F, 0xF4, 0x15, 0xAD, 0xDA, 0xFA, 0xCC, 0x57, 0xF1, 0xA4, 0x7F, 0x5D, 0xE4, 0x7F, 0xF2, 0x2E, 0xA3, 0xE8, 0x14, 0x51, 0x45, 0x60, 0x7A, 0xA1, 0x45, 0x14, 0x50, 0x06, 0x67, 0x88, 0x3F, 0xE4, 0x07,
  0x73, 0xFF, 0x00, 0x01, 0xFF, 0x00, 0xD0, 0x85, 0x7D, 0x4D, 0xE0, 0x4F, 0xF9, 0x27, 0x9E, 0x1A, 0xFF, 0x00, 0xB0, 0x55, 0xAF, 0xFE, 0x8A, 0x5A, 0xF9, 0x67, 0xC4, 0x1F, 0xF2, 0x03, 0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xBE, 0xA6,
  0xF0, 0x27, 0xFC, 0x93, 0xCF, 0x0D, 0x7F, 0xD8, 0x2A, 0xD7, 0xFF, 0x00, 0x45, 0x2D, 0x7B, 0x19, 0x7F, 0xF0, 0x9F, 0xAF, 0xF9, 0x1F, 0x9C, 0x71, 0x7F, 0xFB, 0xF4, 0x3F, 0xC0, 0xBF, 0x39, 0x1E, 0x31, 0xAC, 0xFF, 0x00, 0xC9, 0xC2, 0xF8, 0x9B,
  0xFE, 0xBC, 0xA2, 0xFF, 0x00, 0xD1, 0x70, 0x56, 0xF5, 0x72, 0x7E, 0x2E, 0xD6, 0x2C, 0x34, 0x4F, 0x8F, 0x9E, 0x24, 0xB9, 0xD4, 0x67, 0xF2, 0x61, 0x6B, 0x68, 0x63, 0x0D, 0xB1, 0x9B, 0x2C, 0x62, 0x80, 0xE3, 0x0A,
  0x0F, 0x60, 0x6A, 0x6F, 0xF8, 0x58, 0x1E, 0x17, 0xFF, 0x00, 0xA0, 0x9F, 0xFE, 0x4B, 0xCB, 0xFF, 0x00, 0xC4, 0xD7, 0x81, 0x9C, 0x61, 0xAB, 0x54, 0xC5, 0x39, 0x42, 0x0D, 0xAB, 0x2D, 0x93, 0x3F, 0x1C, 0xCF, 0xF0, 0x98, 0x8A, 0xB8, 0xC7, 0x2A,
  0x74, 0xDB, 0x56, 0x5B, 0x26, 0xCE, 0x9A, 0x8A, 0xE6, 0x7F, 0xE1, 0x60, 0x78, 0x5F, 0xFE, 0x82, 0x7F, 0xF9, 0x2F, 0x2F, 0xFF, 0x00, 0x13, 0x47, 0xFC, 0x2C, 0x0F, 0x0B, 0xFF, 0x00, 0xD0, 0x4F, 0xFF, 0x00, 0x25, 0xE5, 0xFF, 0x00, 0xE2, 0x6B,
  0xCB, 0xFA, 0x96, 0x27, 0xFE, 0x7D, 0xCB, 0xEE, 0x67, 0x8B, 0xFD, 0x9F, 0x8C, 0xFF, 0x00, 0x9F, 0x52, 0xFF, 0x00, 0xC0, 0x5F, 0xF9, 0x1D, 0x35, 0x15, 0xCC, 0xFF, 0x00, 0xC2, 0xC0, 0xF0, 0xBF, 0xFD, 0x04, 0xFF, 0x00, 0xF2, 0x5E, 0x5F, 0xFE,
  0x26, 0x8F, 0xF8, 0x58, 0x1E, 0x17, 0xFF, 0x00, 0xA0, 0x9F, 0xFE, 0x4B, 0xCB, 0xFF, 0x00, 0xC4, 0xD1, 0xF5, 0x2C, 0x4F, 0xFC, 0xFB, 0x97, 0xDC, 0xC3, 0xFB, 0x3F, 0x19, 0xFF, 0x00, 0x3E, 0xA5, 0xFF, 0x00, 0x80, 0xBF, 0xF2, 0x3A, 0x6A, 0xF1,
  0x8F, 0x0A,
  0xFF, 0x00, 0xC8, 0x2E, 0x5F, 0xFA, 0xEC, 0x7F, 0xF4, 0x15, 0xAF, 0x41, 0xFF, 0x00, 0x85, 0x81, 0xE1, 0x7F, 0xFA, 0x09, 0xFF, 0x00, 0xE4, 0xBC, 0xBF, 0xFC, 0x4D, 0x79, 0x9F, 0x87, 0xF5, 0x4B, 0x2B, 0x1B, 0x07, 0x8A, 0xE2, 0x6D, 0x8E, 0x65,
  0x2C, 0x06, 0xD2, 0x78, 0xC0, 0xF4, 0x1E, 0xD5, 0xEB, 0x65, 0xD8, 0x6A, 0xD0, 0xA5, 0x51, 0x4A, 0x0D, 0x5F, 0x97, 0xA3, 0xF3, 0x3F, 0x48, 0xF0, 0xD6, 0x32, 0xC1, 0xE3, 0xEA, 0x4F, 0x14, 0xB9, 0x13, 0x4B, 0x59, 0x7B, 0xAB, 0xAF, 0x7B, 0x1D,
  0x45, 0x15, 0x99, 0xFF, 0x00, 0x09, 0x06, 0x97, 0xFF, 0x00, 0x3F, 0x5F, 0xF9, 0x0D, 0xBF, 0xC2, 0x8F, 0xF8, 0x48, 0x34, 0xBF, 0xF9, 0xFA, 0xFF, 0x00, 0xC8, 0x6D, 0xFE, 0x15, 0xD5, 0xEC, 0x2A, 0xFF, 0x00, 0x2B, 0xFB, 0x8F, 0xDB, 0xBF, 0xB5,
  0x30, 0x3F, 0xF3, 0xFA, 0x1F, 0xF8, 0x12, 0xFF, 0x00, 0x33, 0x4E, 0x8A, 0xCC, 0xFF, 0x00, 0x84, 0x83, 0x4B, 0xFF, 0x00, 0x9F, 0xAF, 0xFC, 0x86, 0xDF, 0xE1, 0x47, 0xFC, 0x24, 0x1A, 0x5F, 0xFC, 0xFD, 0x7F, 0xE4, 0x36, 0xFF, 0x00, 0x0A,
  0x3D, 0x85, 0x5F, 0xE5, 0x7F, 0x70, 0x7F, 0x6A, 0x60, 0x7F, 0xE7, 0xF4, 0x3F, 0xF0, 0x25, 0xFE, 0x66, 0x9D, 0x66, 0x78, 0x83, 0xFE, 0x40, 0x77, 0x3F, 0xF0, 0x1F, 0xFD, 0x08, 0x51, 0xFF, 0x00, 0x09, 0x06, 0x97, 0xFF, 0x00, 0x3F, 0x5F, 0xF9,
  0x0D, 0xBF, 0xC2, 0xA8, 0xEB, 0x1A, 0xC5, 0x85, 0xD6, 0x95, 0x34, 0x30, 0xCF, 0xBA, 0x46, 0xDB, 0x81, 0xB1, 0x86, 0x70, 0xC0, 0xF7, 0x15, 0xA5, 0x1A, 0x35, 0x15, 0x48, 0xB7, 0x17, 0xBA, 0xE8, 0x71, 0x66, 0x39, 0x8E, 0x0E, 0x78, 0x3A, 0xB1,
  0x8D, 0x58, 0xB6, 0xE3, 0x2F, 0xB4, 0xBB, 0x3F, 0x33, 0xD6, 0x3C, 0x39, 0xFF, 0x00, 0x22, 0xC6, 0x93, 0xFF, 0x00, 0x5E, 0x50, 0xFF, 0x00, 0xE8, 0x02, 0xB4, 0xEB, 0x8B, 0xD1, 0x7C, 0x71, 0xE1, 0xCB, 0x4D, 0x0B, 0x4E, 0xB6, 0x9F, 0x51, 0xD9,
  0x34, 0x36, 0xD1, 0xC6, 0xEB, 0xE4, 0x48, 0x70, 0xC1, 0x40, 0x23, 0x21, 0x7D, 0x6A, 0xF7, 0xFC, 0x2C, 0x0F, 0x0B, 0xFF, 0x00, 0xD0, 0x4F, 0xFF, 0x00, 0x25, 0xE5, 0xFF, 0x00, 0xE2, 0x6B, 0xE7, 0xEB, 0x60, 0xF1, 0x2E, 0xA4, 0x9A, 0xA7, 0x2D,
  0xDF, 0x46, 0x7F, 0x2D, 0xD7, 0xC0, 0x62, 0xDD, 0x59, 0x35, 0x4A, 0x5B, 0xBF, 0xB2, 0xFB, 0xFA, 0x1D, 0x35, 0x15, 0xCC, 0xFF, 0x00, 0xC2, 0xC0, 0xF0, 0xBF, 0xFD, 0x04, 0xFF, 0x00, 0xF2, 0x5E, 0x5F, 0xFE, 0x26, 0x8F, 0xF8, 0x58, 0x1E, 0x17,
  0xFF, 0x00, 0xA0, 0x9F, 0xFE, 0x4B, 0xCB, 0xFF, 0x00, 0xC4, 0xD6, 0x7F, 0x52, 0xC4, 0xFF, 0x00, 0xCF, 0xB9, 0x7D, 0xCC, 0xCB, 0xFB, 0x3F, 0x19, 0xFF, 0x00, 0x3E, 0xA5, 0xFF, 0x00, 0x80, 0xBF, 0xF2, 0x3A, 0x6A, 0x2B, 0x99, 0xFF, 0x00, 0x85,
  0x81, 0xE1, 0x7F, 0xFA, 0x09, 0xFF, 0x00, 0xE4, 0xBC, 0xBF, 0xFC, 0x4D, 0x1F, 0xF0, 0xB0, 0x3C, 0x2F, 0xFF, 0x00, 0x41, 0x3F, 0xFC, 0x97, 0x97, 0xFF, 0x00, 0x89, 0xA3, 0xEA, 0x58, 0x9F, 0xF9, 0xF7, 0x2F, 0xB9, 0x87, 0xF6, 0x7E, 0x33, 0xFE,
  0x7D, 0x4B, 0xFF, 0x00, 0x01, 0x7F, 0xE4, 0x61, 0xFC, 0x49, 0xFF, 0x00, 0x90, 0xA7, 0x87, 0x3F, 0xEB, 0xB3, 0xFF, 0x00, 0xE8, 0x51, 0xD5, 0x7A, 0xA5, 0xE3, 0x7F, 0x12, 0x69, 0x3A, 0xBD, 0xFE, 0x8B, 0x2D, 0x8D, 0xDF, 0x9A, 0x96, 0xD2, 0xBB,
  0x4A, 0x7C, 0xB7, 0x5D, 0xA0, 0x94, 0xC7, 0x50, 0x33, 0xD0, 0xF4, 0xA8, 0x7F, 0xE1, 0x20, 0xD2, 0xFF, 0x00, 0xE7, 0xEB, 0xFF, 0x00, 0x21, 0xB7, 0xF8, 0x57, 0xBD, 0x46, 0x85, 0x55, 0x86, 0xA7, 0x17, 0x17, 0x75, 0x7E, 0x9E, 0x6C, 0xFD, 0xDB,
  0xC3, 0x9A, 0xF4, 0xB0, 0x99, 0x53, 0xA7, 0x89, 0x92, 0x84, 0xAE, 0xF4, 0x93, 0xB3, 0xDD, 0xF4, 0x66, 0x9D, 0x15, 0x99, 0xFF, 0x00, 0x09, 0x06, 0x97, 0xFF, 0x00, 0x3F, 0x5F, 0xF9, 0x0D, 0xBF, 0xC2, 0x8F, 0xF8, 0x48, 0x34, 0xBF, 0xF9, 0xFA,
  0xFF, 0x00, 0xC8, 0x6D, 0xFE, 0x15, 0x5E, 0xC2, 0xAF, 0xF2, 0xBF, 0xB8, 0xFD, 0x03, 0xFB, 0x53, 0x03, 0xFF, 0x00, 0x3F, 0xA1, 0xFF, 0x00, 0x81, 0x2F, 0xF3, 0x34, 0xE8, 0xAC, 0xCF, 0xF8, 0x48, 0x34, 0xBF, 0xF9, 0xFA, 0xFF, 0x00, 0xC8, 0x6D,
  0xFE, 0x14, 0x7F, 0xC2, 0x41, 0xA5, 0xFF, 0x00, 0xCF, 0xD7, 0xFE, 0x43, 0x6F, 0xF0, 0xA3, 0xD8, 0x55, 0xFE, 0x57, 0xF7, 0x07, 0xF6, 0xA6, 0x07, 0xFE, 0x7F, 0x43, 0xFF, 0x00, 0x02, 0x5F, 0xE6, 0x69, 0xD2, 0x78, 0x33, 0xFE, 0x4A, 0x1E, 0xA5,
  0xFF, 0x00, 0x5E, 0x5F, 0xD6, 0x3A, 0xCD, 0xFF, 0x00, 0x84, 0x83, 0x4B, 0xFF, 0x00, 0x9F, 0xAF, 0xFC, 0x86, 0xDF, 0xE1, 0x49, 0xE1, 0x9F, 0x10, 0x69, 0x7A, 0x7F, 0x8C, 0xAF, 0x6F, 0xEE, 0xAE, 0xBC, 0xBB, 0x59, 0x6D, 0xBC, 0xB4, 0x7F, 0x2D,
  0x8E, 0x5B, 0x29, 0xC6, 0x00, 0xCF, 0xF0, 0x9F, 0xCA, 0x89, 0x50, 0xAB, 0xEC, 0x6A, 0x2E, 0x57, 0xAA, 0xED, 0xE6, 0x8F, 0x8A, 0xE3, 0xEC, 0x4D, 0x1C, 0x56, 0x4F, 0x2A, 0x78, 0x79, 0xA9, 0xCA, 0xEB, 0x48, 0xB4, 0xDE, 0xCF, 0xA2, 0x3D, 0x7A,
  0x8A, 0xE6, 0x7F, 0xE1, 0x60, 0x78, 0x5F, 0xFE, 0x82, 0x7F, 0xF9, 0x2F, 0x2F, 0xFF, 0x00, 0x13, 0x47, 0xFC, 0x2C, 0x0F, 0x0B, 0xFF, 0x00, 0xD0, 0x4F, 0xFF, 0x00, 0x25, 0xE5, 0xFF, 0x00, 0xE2, 0x6B, 0xE7, 0xFE, 0xA5, 0x89, 0xFF, 0x00, 0x9F,
  0x72, 0xFB, 0x99, 0xFC, 0xFD, 0xFD, 0x9F, 0x8C, 0xFF, 0x00, 0x9F, 0x52, 0xFF, 0x00, 0xC0, 0x5F, 0xF9, 0x1D, 0x35, 0x15, 0xCC, 0xFF, 0x00, 0xC2, 0xC0, 0xF0, 0xBF, 0xFD, 0x04, 0xFF, 0x00, 0xF2, 0x5E, 0x5F, 0xFE, 0x26, 0x8F, 0xF8, 0x58, 0x1E,
  0x17, 0xFF, 0x00, 0xA0, 0x9F, 0xFE, 0x4B, 0xCB, 0xFF, 0x00, 0xC4, 0xD1, 0xF5, 0x2C, 0x4F, 0xFC, 0xFB, 0x97, 0xDC, 0xC3, 0xFB, 0x3F, 0x19, 0xFF, 0x00, 0x3E, 0xA5, 0xFF, 0x00, 0x80, 0xBF, 0xF2, 0x3A, 0x6A, 0x2B, 0x99, 0xFF, 0x00, 0x85, 0x81,
  0xE1, 0x7F, 0xFA, 0x09, 0xFF, 0x00, 0xE4, 0xBC, 0xBF, 0xFC, 0x4D, 0x1F, 0xF0, 0xB0, 0x3C, 0x2F, 0xFF, 0x00, 0x41, 0x3F, 0xFC, 0x97, 0x97, 0xFF, 0x00, 0x89, 0xA3, 0xEA, 0x58, 0x9F, 0xF9, 0xF7, 0x2F, 0xB9, 0x87, 0xF6, 0x7E, 0x33, 0xFE, 0x7D,
  0x4B, 0xFF, 0x00, 0x01, 0x7F, 0xE4, 0x79, 0xF7, 0x85, 0x7F, 0xE4, 0x17, 0x2F, 0xFD, 0x76, 0x3F, 0xFA, 0x0A,
  0xD6, 0xED, 0x72, 0xFE, 0x1F, 0xD5, 0x2C, 0xAC, 0x6C, 0x1E, 0x2B, 0x89, 0xB6, 0x39, 0x94, 0xB0, 0x1B, 0x49, 0xE3, 0x03, 0xD0, 0x7B, 0x56, 0xAF, 0xFC, 0x24, 0x1A, 0x5F, 0xFC, 0xFD, 0x7F, 0xE4, 0x36, 0xFF, 0x00, 0x0A,
  0xFA, 0x6C, 0x45, 0x2A, 0x8E, 0xAC, 0x9A, 0x8B, 0xFB, 0x8F, 0xEA, 0x3C, 0x9F, 0x30, 0xC2, 0x53, 0xC0, 0x52, 0x84, 0xEA, 0xC5, 0x34, 0xB6, 0x72, 0x57, 0xFC, 0xCD, 0x3A, 0x2B, 0x33, 0xFE, 0x12, 0x0D, 0x2F, 0xFE, 0x7E, 0xBF, 0xF2, 0x1B, 0x7F,
  0x85, 0x1F, 0xF0, 0x90, 0x69, 0x7F, 0xF3, 0xF5, 0xFF, 0x00, 0x90, 0xDB, 0xFC, 0x2B, 0x1F, 0x61, 0x57, 0xF9, 0x5F, 0xDC, 0x7A, 0x7F, 0xDA, 0x98, 0x1F, 0xF9, 0xFD, 0x0F, 0xFC, 0x09, 0x7F, 0x99, 0xA7, 0x45, 0x66, 0x7F, 0xC2, 0x41, 0xA5, 0xFF,
  0x00, 0xCF, 0xD7, 0xFE, 0x43, 0x6F, 0xF0, 0xA3, 0xFE, 0x12, 0x0D, 0x2F, 0xFE, 0x7E, 0xBF, 0xF2, 0x1B, 0x7F, 0x85, 0x1E, 0xC2, 0xAF, 0xF2, 0xBF, 0xB8, 0x3F, 0xB5, 0x30, 0x3F, 0xF3, 0xFA, 0x1F, 0xF8, 0x12, 0xFF, 0x00, 0x30, 0xF1, 0x07, 0xFC,
  0x80, 0xEE, 0x7F, 0xE0, 0x3F, 0xFA, 0x10, 0xAF, 0xA9, 0xBC, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5F, 0x25, 0xEB, 0x1A, 0xC5, 0x85, 0xD6, 0x95, 0x34, 0x30, 0xCF, 0xBA, 0x46, 0xDB, 0x81, 0xB1, 0x86, 0x70, 0xC0, 0xF7, 0x15, 0xF5, 0xA7, 0x81, 0x3F, 0xE4, 0x9E, 0x78, 0x6B, 0xFE, 0xC1, 0x56, 0xBF, 0xFA, 0x29,
  0x6B, 0xD4, 0xC0, 0xC6, 0x51, 0xA6, 0xD4, 0x95, 0xB5, 0xFF, 0x00, 0x23, 0xE0, 0x78, 0xA6, 0xBD, 0x2A, 0xF8, 0xC8, 0xCA, 0x94, 0x94, 0x97, 0x2A, 0xD9, 0xA7, 0xD5, 0xF6, 0x3E, 0x69, 0xF8, 0xBE, 0x8A, 0xFF, 0x00, 0x19, 0x75, 0xE0, 0xCA, 0x18,
  0x6D, 0x83, 0x82, 0x33, 0xFF, 0x00, 0x2C, 0x22, 0xAE, 0x3F, 0xC8, 0x8B, 0xFE, 0x79, 0x27, 0xFD, 0xF2, 0x2B, 0xB2, 0xF8, 0xBB, 0xFF, 0x00, 0x25, 0x9B, 0x5E, 0xFF, 0x00, 0x76, 0x0F, 0xFD, 0x11, 0x15, 0x72, 0x35, 0xFA, 0xB7, 0x0C, 0x50, 0xA5,
  0x3C, 0xBD, 0x39, 0x45, 0x37, 0x77, 0xD0, 0xF8, 0xEA, 0xCD, 0xF3, 0x91, 0xF9, 0x11, 0x7F, 0xCF, 0x24, 0xFF, 0x00, 0xBE, 0x45, 0x1E, 0x44, 0x5F, 0xF3, 0xC9, 0x3F, 0xEF, 0x91, 0x52, 0x51, 0x5F, 0x43, 0xF5, 0x5A, 0x1F, 0xC8, 0xBE, 0xE4, 0x63,
  0xCC, 0xFB, 0x91, 0xF9, 0x11, 0x7F, 0xCF, 0x24, 0xFF, 0x00, 0xBE, 0x45, 0x1E, 0x44, 0x5F, 0xF3, 0xC9, 0x3F, 0xEF, 0x91, 0x52, 0x51, 0x47, 0xD5, 0x68, 0x7F, 0x22, 0xFB, 0x90, 0x73, 0x3E, 0xE4, 0x7E, 0x44, 0x5F, 0xF3, 0xC9, 0x3F, 0xEF, 0x91,
  0x5D, 0xCF, 0xC3, 0x6D, 0x27, 0x4D, 0xBF, 0xF0, 0xED, 0xC4, 0xB7, 0x9A, 0x7D, 0xAD, 0xC4, 0x82, 0xED, 0x94, 0x3C, 0xD0, 0xAB, 0x90, 0x36, 0x27, 0x19, 0x23, 0xA7, 0x26, 0xB8, 0xAA, 0xF4, 0x1F, 0x85, 0x7F, 0xF2, 0x2C, 0x5C, 0xFF, 0x00, 0xD7,
  0xEB, 0x7F, 0xE8, 0x09, 0x5F, 0x9A, 0x78, 0x95, 0x08, 0xD1, 0xC2, 0xD1, 0x74, 0xD7, 0x2E, 0xAF, 0x6D, 0x3F, 0x94, 0xF3, 0x33, 0x99, 0xCA, 0x38, 0x29, 0x38, 0xBB, 0x6A, 0x8E, 0x97, 0xFE, 0x11, 0xCD, 0x0F, 0xFE, 0x80, 0xDA, 0x77, 0xFE, 0x02,
  0xA7, 0xF8, 0x51, 0xFF, 0x00, 0x08, 0xE6, 0x87, 0xFF, 0x00, 0x40, 0x6D, 0x3B, 0xFF, 0x00, 0x01, 0x53, 0xFC, 0x2B, 0x4E, 0x8A, 0xFC, 0x6B, 0xDB, 0x55, 0xFE, 0x67, 0xF7, 0x9F, 0x17, 0xF5, 0x8A, 0xDF, 0xCE, 0xFE, 0xF6, 0x66, 0x7F, 0xC2, 0x39,
  0xA1, 0xFF, 0x00, 0xD0, 0x1B, 0x4E, 0xFF, 0x00, 0xC0, 0x54, 0xFF, 0x00, 0x0A,
  0x3F, 0xE1, 0x1C, 0xD0, 0xFF, 0x00, 0xE8, 0x0D, 0xA7, 0x7F, 0xE0, 0x2A, 0x7F, 0x85, 0x69, 0xD1, 0x47, 0xB6, 0xAB, 0xFC, 0xCF, 0xEF, 0x0F, 0xAC, 0x56, 0xFE, 0x77, 0xF7, 0xB3, 0x33, 0xFE, 0x11, 0xCD, 0x0F, 0xFE, 0x80, 0xDA, 0x77, 0xFE, 0x02,
  0xA7, 0xF8, 0x57, 0x3D, 0xE3, 0x8D, 0x17, 0x4A, 0xB4, 0xF0, 0x75, 0xFC, 0xF6, 0xDA, 0x65, 0x94, 0x33, 0x2F, 0x97, 0xB6, 0x48, 0xE0, 0x55, 0x61, 0x99, 0x14, 0x1C, 0x10, 0x3D, 0x2B, 0xB4, 0xAE, 0x67, 0xE2, 0x07, 0xFC, 0x89, 0x1A, 0x8F, 0xFD,
  0xB2, 0xFF, 0x00, 0xD1, 0x8B, 0x5D, 0x38, 0x3A, 0xD5, 0x1E, 0x26, 0x9A, 0x72, 0x7F, 0x12, 0xEB, 0xE6, 0x75, 0xE0, 0x2B, 0xD5, 0x78, 0xBA, 0x49, 0xC9, 0xFC, 0x51, 0xEA, 0xFB, 0xA3, 0xC9, 0x61, 0x86, 0x23, 0x04, 0x64, 0xC6, 0x84, 0x95, 0x1C,
  0xED, 0x1E, 0x94, 0xFF, 0x00, 0x22, 0x2F, 0xF9, 0xE4, 0x9F, 0xF7, 0xC8, 0xA2, 0x0F, 0xF8, 0xF7, 0x8F, 0xFD, 0xD1, 0xFC, 0xAA, 0x4A, 0xFE, 0xA0, 0xC3, 0x61, 0xA8, 0xBA, 0x10, 0x6E, 0x0B, 0x65, 0xD1, 0x76, 0x3E, 0xF9, 0xC9, 0xDC, 0x8F, 0xC8,
  0x8B, 0xFE, 0x79, 0x27, 0xFD, 0xF2, 0x28, 0xF2, 0x22, 0xFF, 0x00, 0x9E, 0x49, 0xFF, 0x00, 0x7C, 0x8A, 0x92, 0x8A, 0xDF, 0xEA, 0xB4, 0x3F, 0x91, 0x7D, 0xC8, 0x9E, 0x67, 0xDC, 0x8F, 0xC8, 0x8B, 0xFE, 0x79, 0x27, 0xFD, 0xF2, 0x28, 0xF2, 0x22,
  0xFF, 0x00, 0x9E, 0x49, 0xFF, 0x00, 0x7C, 0x8A, 0x92, 0x8A, 0x3E, 0xAB, 0x43, 0xF9, 0x17, 0xDC, 0x83, 0x99, 0xF7, 0x0B, 0x0B, 0x78, 0x5F, 0xC4, 0x5A, 0x44, 0x4D, 0x0C, 0x6D, 0x1C, 0x97, 0x71, 0xAB, 0xA1, 0x50, 0x43, 0x02, 0xEB, 0x90, 0x47,
  0x71, 0x5E, 0xCD, 0xFF, 0x00, 0x08, 0xE6, 0x87, 0xFF, 0x00, 0x40, 0x6D, 0x3B, 0xFF, 0x00, 0x01, 0x53, 0xFC, 0x2B, 0xC7, 0x74, 0xEF, 0xF9, 0x19, 0xF4, 0x4F, 0xFA, 0xFD, 0x8B, 0xFF, 0x00, 0x43, 0x5A, 0xF7, 0x5A, 0xFC, 0x23, 0xC4, 0x06, 0xE9,
  0x66, 0xF2, 0x8D, 0x3D, 0x15, 0x96, 0xDA, 0x74, 0x47, 0xCD, 0xF1, 0x0D, 0x5A, 0x90, 0x95, 0x3E, 0x59, 0x35, 0xA3, 0xEB, 0xE6, 0x66, 0x7F, 0xC2, 0x39, 0xA1, 0xFF, 0x00, 0xD0, 0x1B, 0x4E, 0xFF, 0x00, 0xC0, 0x54, 0xFF, 0x00, 0x0A,
  0x3F, 0xE1, 0x1C, 0xD0, 0xFF, 0x00, 0xE8, 0x0D, 0xA7, 0x7F, 0xE0, 0x2A, 0x7F, 0x85, 0x69, 0xD1, 0x5F, 0x0D, 0xED, 0xAA, 0xFF, 0x00, 0x33, 0xFB, 0xCF, 0x9C, 0xFA, 0xC5, 0x6F, 0xE7, 0x7F, 0x7B, 0x33, 0x3F, 0xE1, 0x1C, 0xD0, 0xFF, 0x00, 0xE8,
  0x0D, 0xA7, 0x7F, 0xE0, 0x2A, 0x7F, 0x85, 0x1F, 0xF0, 0x8E, 0x68, 0x7F, 0xF4, 0x06, 0xD3, 0xBF, 0xF0, 0x15, 0x3F, 0xC2, 0xB4, 0xE8, 0xA3, 0xDB, 0x55, 0xFE, 0x67, 0xF7, 0x87, 0xD6, 0x2B, 0x7F, 0x3B, 0xFB, 0xD9, 0x99, 0xFF, 0x00, 0x08, 0xE6,
  0x87, 0xFF, 0x00, 0x40, 0x6D, 0x3B, 0xFF, 0x00, 0x01, 0x53, 0xFC, 0x2B, 0xC9, 0xBC, 0x55, 0x69, 0x6D, 0x6F, 0xE3, 0x7D, 0x42, 0xDE, 0x0B, 0x78, 0xA2, 0x85, 0x16, 0x3D, 0xB1, 0xA2, 0x05, 0x51, 0xF2, 0x21, 0xE0, 0x0E, 0x3B, 0x9A, 0xF6, 0xCA,
  0xF1, 0x9F, 0x18, 0x7F, 0xC8, 0xFF, 0x00, 0xA9, 0xFF, 0x00, 0xBB, 0x1F, 0xFE, 0x8B, 0x4A, 0xFA, 0xEE, 0x08, 0x94, 0xAA, 0x67, 0x14, 0xE3, 0x37, 0x75, 0xE7, 0xAF, 0x54, 0x7B, 0xDC, 0x3D, 0x56, 0xA4, 0xB1, 0x13, 0x52, 0x93, 0x7E, 0xEB, 0xEB,
  0xE6, 0x8C, 0x8F, 0x22, 0x2F, 0xF9, 0xE4, 0x9F, 0xF7, 0xC8, 0xA3, 0xC8, 0x8B, 0xFE, 0x79, 0x27, 0xFD, 0xF2, 0x2A, 0x4A, 0x2B, 0xFA, 0x0B, 0xEA, 0xB4, 0x3F, 0x91, 0x7D, 0xC8, 0xFA, 0x9E, 0x67, 0xDC, 0x8F, 0xC8, 0x8B, 0xFE, 0x79, 0x27, 0xFD,
  0xF2, 0x28, 0xF2, 0x22, 0xFF, 0x00, 0x9E, 0x49, 0xFF, 0x00, 0x7C, 0x8A, 0x92, 0x8A, 0x3E, 0xAB, 0x43, 0xF9, 0x17, 0xDC, 0x83, 0x99, 0xF7, 0x23, 0xF2, 0x22, 0xFF, 0x00, 0x9E, 0x49, 0xFF, 0x00, 0x7C, 0x8A, 0x3C, 0x88, 0xBF, 0xE7, 0x92, 0x7F,
  0xDF, 0x22, 0xA4, 0xA2, 0x8F, 0xAA, 0xD0, 0xFE, 0x45, 0xF7, 0x20, 0xE6, 0x7D, 0xCE, 0xD7, 0xE1, 0xB6, 0x93, 0xA6, 0xDF, 0xF8, 0x76, 0xE2, 0x5B, 0xCD, 0x3E, 0xD6, 0xE2, 0x41, 0x76, 0xCA, 0x1E, 0x68, 0x55, 0xC8, 0x1B, 0x13, 0x8C, 0x91, 0xD3,
  0x93, 0x5D, 0x8F, 0xFC, 0x23, 0x9A, 0x1F, 0xFD, 0x01, 0xB4, 0xEF, 0xFC, 0x05, 0x4F, 0xF0, 0xAE, 0x6B, 0xE1, 0x5F, 0xFC, 0x8B, 0x17, 0x3F, 0xF5, 0xFA, 0xDF, 0xFA, 0x02, 0x57, 0x71, 0x5F, 0xCB, 0x99, 0x8D, 0x5A, 0x8B, 0x15, 0x34, 0xA4, 0xF7,
  0xEE, 0x7C, 0x4E, 0x6D, 0x5E, 0xAC, 0x71, 0xB5, 0x12, 0x93, 0xDF, 0xB9, 0x99, 0xFF, 0x00, 0x08, 0xE6, 0x87, 0xFF, 0x00, 0x40, 0x6D, 0x3B, 0xFF, 0x00, 0x01, 0x53, 0xFC, 0x28, 0xFF, 0x00, 0x84, 0x73, 0x43, 0xFF, 0x00, 0xA0, 0x36, 0x9D, 0xFF,
  0x00, 0x80, 0xA9, 0xFE, 0x15, 0xA7, 0x45, 0x71, 0x7B, 0x6A, 0xBF, 0xCC, 0xFE, 0xF3, 0xCE, 0xFA, 0xC5, 0x6F, 0xE7, 0x7F, 0x7B, 0x33, 0x3F, 0xE1, 0x1C, 0xD0, 0xFF, 0x00, 0xE8, 0x0D, 0xA7, 0x7F, 0xE0, 0x2A, 0x7F, 0x85, 0x1F, 0xF0, 0x8E, 0x68,
  0x7F, 0xF4, 0x06, 0xD3, 0xBF, 0xF0, 0x15, 0x3F, 0xC2, 0xB4, 0xE8, 0xA3, 0xDB, 0x55, 0xFE, 0x67, 0xF7, 0x87, 0xD6, 0x2B, 0x7F, 0x3B, 0xFB, 0xD9, 0xC5, 0xF8, 0xE3, 0x45, 0xD2, 0xAD, 0x3C, 0x1D, 0x7F, 0x3D, 0xB6, 0x99, 0x65, 0x0C, 0xCB, 0xE5,
  0xED, 0x92, 0x38, 0x15, 0x58, 0x66, 0x45, 0x07, 0x04, 0x0F, 0x4A, 0xF7, 0xDF, 0x02, 0x7F, 0xC9, 0x3C, 0xF0, 0xD7, 0xFD, 0x82, 0xAD, 0x7F, 0xF4, 0x52, 0xD7, 0x88, 0x7C, 0x40, 0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6, 0x5F, 0xFA, 0x31,
  0x6B, 0xDB, 0xFC, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5F, 0x59, 0x91, 0x4A, 0x52, 0xC3, 0x49, 0xC9, 0xDF, 0xDE, 0x7F, 0x92, 0x3E, 0xE3, 0x86, 0xA7, 0x29, 0xE1, 0x24, 0xE4, 0xEF, 0xEF, 0x3F, 0xC9, 0x1F, 0x35, 0xFC, 0x5D, 0xFF, 0x00, 0x92, 0xCD, 0xAF, 0x7F, 0xBB,
  0x07, 0xFE, 0x88, 0x8A, 0xB9, 0x1A, 0xEB, 0xBE, 0x2E, 0xFF, 0x00, 0xC9, 0x66, 0xD7, 0xBF, 0xDD, 0x83, 0xFF, 0x00, 0x44, 0x45, 0x5C, 0x8D, 0x7E, 0xD1, 0xC2, 0xBF, 0xF2, 0x2E, 0x5E, 0xAC, 0xF5, 0x2B, 0xFC, 0x61, 0x45, 0x14, 0x57, 0xD1, 0x98,
  0x85, 0x14, 0x51, 0x40, 0x05, 0x7A, 0x0F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAF, 0x3E, 0xAF, 0x41, 0xF8, 0x57, 0xFF, 0x00, 0x22, 0xC5, 0xCF, 0xFD, 0x7E, 0xB7, 0xFE, 0x80, 0x95, 0xF9, 0x7F, 0x89, 0xFF, 0x00,
  0xEE, 0x94, 0x7D, 0x5F, 0xFE, 0xDA, 0x79, 0x79, 0xDF, 0xFB, 0x8C, 0xBD, 0x51, 0xDC, 0x51, 0x45, 0x15, 0xF8, 0x99, 0xF0, 0xE1, 0x45, 0x14, 0x50, 0x01, 0x5C, 0xCF, 0xC4, 0x0F, 0xF9, 0x12, 0x35, 0x1F, 0xFB, 0x65, 0xFF, 0x00, 0xA3, 0x16, 0xBA,
  0x6A, 0xE6, 0x7E, 0x20, 0x7F, 0xC8, 0x91, 0xA8, 0xFF, 0x00, 0xDB, 0x2F, 0xFD, 0x18, 0xB5, 0xD5, 0x82, 0xFF, 0x00, 0x79, 0xA7, 0xFE, 0x25, 0xF9, 0x9D, 0x99, 0x77, 0xFB, 0xE5, 0x2F, 0xF1, 0x47, 0xF3, 0x47, 0x94, 0x41, 0xFF, 0x00, 0x1E, 0xF1,
  0xFF, 0x00, 0xBA, 0x3F, 0x95, 0x49, 0x51, 0xC1, 0xFF, 0x00, 0x1E, 0xF1, 0xFF, 0x00, 0xBA, 0x3F, 0x95, 0x49, 0x5F, 0xD5, 0x78, 0x5F, 0xE0, 0x43, 0xD1, 0x7E, 0x47, 0xE8, 0x32, 0xDC, 0x28, 0xA2, 0x8A, 0xDC, 0x41, 0x45, 0x14, 0x50, 0x04, 0x9A,
  0x77, 0xFC, 0x8C, 0xFA, 0x27, 0xFD, 0x7E, 0xC5, 0xFF, 0x00, 0xA1, 0xAD, 0x7B, 0xAD, 0x78, 0x56, 0x9D, 0xFF, 0x00, 0x23, 0x3E, 0x89, 0xFF, 0x00, 0x5F, 0xB1, 0x7F, 0xE8, 0x6B, 0x5E, 0xEB, 0x5F, 0x80, 0x78, 0x8B, 0xFF, 0x00, 0x23, 0x89, 0x7A,
  0x2F, 0xC9, 0x1F, 0x31, 0xC4, 0x9F, 0x1D, 0x2F, 0x47, 0xF9, 0x85, 0x14, 0x51, 0x5F, 0x04, 0x7C, 0xD0, 0x51, 0x45, 0x14, 0x00, 0x57, 0x8C, 0xF8, 0xC3, 0xFE, 0x47, 0xFD, 0x4F, 0xFD, 0xD8, 0xFF, 0x00, 0xF4, 0x5A, 0x57, 0xB3, 0x57, 0x8C, 0xF8,
  0xC3, 0xFE, 0x47, 0xFD, 0x4F, 0xFD, 0xD8, 0xFF, 0x00, 0xF4, 0x5A, 0x57, 0xD8, 0xF0, 0x27, 0xFC, 0x8E, 0xA9, 0xFF, 0x00, 0x5D, 0x51, 0xF4, 0x1C, 0x39, 0xFE, 0xF3, 0x3F, 0xF0, 0xBF, 0xCD, 0x19, 0x94, 0x51, 0x45, 0x7F, 0x45, 0x9F, 0x58, 0x14,
  0x51, 0x45, 0x00, 0x14, 0x51, 0x45, 0x00, 0x7A, 0x0F, 0xC2, 0xBF, 0xF9, 0x16, 0x2E, 0x7F, 0xEB, 0xF5, 0xBF, 0xF4, 0x04, 0xAE, 0xE2, 0xB8, 0x7F, 0x85, 0x7F, 0xF2, 0x2C, 0x5C, 0xFF, 0x00, 0xD7, 0xEB, 0x7F, 0xE8, 0x09, 0x5D, 0xC5, 0x7F, 0x28,
  0xE6, 0x5F, 0xEF, 0x75, 0x3D, 0x4F, 0x85, 0xCE, 0x3F, 0xDF, 0xAA, 0xFA, 0x85, 0x14, 0x51, 0x5C, 0x27, 0x9A, 0x14, 0x51, 0x45, 0x00, 0x73, 0x3F, 0x10, 0x3F, 0xE4, 0x48, 0xD4, 0x7F, 0xED, 0x97, 0xFE, 0x8C, 0x5A, 0xF6, 0xFF, 0x00, 0x02, 0x7F,
  0xC9, 0x3C, 0xF0, 0xD7, 0xFD, 0x82, 0xAD, 0x7F, 0xF4, 0x52, 0xD7, 0x88, 0x7C, 0x40, 0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6, 0x5F, 0xFA, 0x31, 0x6B, 0xDB, 0xFC, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5F, 0x5F, 0x90, 0x7F, 0xBB, 0x4B, 0xFC, 0x4F, 0xF2, 0x47, 0xDD, 0xF0, 0xBF, 0xFB, 0x9C, 0xBF, 0xC4, 0xFF, 0x00, 0x24, 0x7C, 0xD7, 0xF1, 0x77, 0xFE, 0x4B, 0x36, 0xBD, 0xFE, 0xEC, 0x1F, 0xFA, 0x22, 0x2A, 0xE4,
  0x6B, 0xAE, 0xF8, 0xBB, 0xFF, 0x00, 0x25, 0x9B, 0x5E, 0xFF, 0x00, 0x76, 0x0F, 0xFD, 0x11, 0x15, 0x72, 0x35, 0xFB, 0x57, 0x0A,
  0xFF, 0x00, 0xC8, 0xB9, 0x7A, 0xB3, 0xD7, 0xAF, 0xF1, 0x85, 0x14, 0x51, 0x5F, 0x46, 0x62, 0x14, 0x51, 0x45, 0x00, 0x15, 0xE8, 0x3F, 0x0A,
  0xFF, 0x00, 0xE4, 0x58, 0xB9, 0xFF, 0x00, 0xAF, 0xD6, 0xFF, 0x00, 0xD0, 0x12, 0xBC, 0xFA, 0xBD, 0x07, 0xE1, 0x5F, 0xFC, 0x8B, 0x17, 0x3F, 0xF5, 0xFA, 0xDF, 0xFA, 0x02, 0x57, 0xE5, 0xFE, 0x27, 0xFF, 0x00, 0xBA, 0x51, 0xF5, 0x7F, 0xFB, 0x69,
  0xE5, 0xE7, 0x7F, 0xEE, 0x32, 0xF5, 0x47, 0x71, 0x45, 0x14, 0x57, 0xE2, 0x67, 0xC3, 0x85, 0x14, 0x51, 0x40, 0x05, 0x73, 0x3F, 0x10, 0x3F, 0xE4, 0x48, 0xD4, 0x7F, 0xED, 0x97, 0xFE, 0x8C, 0x5A, 0xE9, 0xAB, 0x99, 0xF8, 0x81, 0xFF, 0x00, 0x22,
  0x46, 0xA3, 0xFF, 0x00, 0x6C, 0xBF, 0xF4, 0x62, 0xD7, 0x56, 0x0B, 0xFD, 0xE6, 0x9F, 0xF8, 0x97, 0xE6, 0x76, 0x65, 0xDF, 0xEF, 0x94, 0xBF, 0xC5, 0x1F, 0xCD, 0x1E, 0x51, 0x07, 0xFC, 0x7B, 0xC7, 0xFE, 0xE8, 0xFE, 0x55, 0x25, 0x47, 0x07, 0xFC,
  0x7B, 0xC7, 0xFE, 0xE8, 0xFE, 0x55, 0x25, 0x7F, 0x55, 0xE1, 0x7F, 0x81, 0x0F, 0x45, 0xF9, 0x1F, 0xA0, 0xCB, 0x70, 0xA2, 0x8A, 0x2B, 0x71, 0x05, 0x14, 0x51, 0x40, 0x12, 0x69, 0xDF, 0xF2, 0x33, 0xE8, 0x9F, 0xF5, 0xFB, 0x17, 0xFE, 0x86, 0xB5,
  0xEE, 0xB5, 0xE1, 0x5A, 0x77, 0xFC, 0x8C, 0xFA, 0x27, 0xFD, 0x7E, 0xC5, 0xFF, 0x00, 0xA1, 0xAD, 0x7B, 0xAD, 0x7E, 0x01, 0xE2, 0x2F, 0xFC, 0x8E, 0x25, 0xE8, 0xBF, 0x24, 0x7C, 0xC7, 0x12, 0x7C, 0x74, 0xBD, 0x1F, 0xE6, 0x14, 0x51, 0x45, 0x7C,
  0x11, 0xF3, 0x41, 0x45, 0x14, 0x50, 0x01, 0x5E, 0x33, 0xE3, 0x0F, 0xF9, 0x1F, 0xF5, 0x3F, 0xF7, 0x63, 0xFF, 0x00, 0xD1, 0x69, 0x5E, 0xCD, 0x5E, 0x33, 0xE3, 0x0F, 0xF9, 0x1F, 0xF5, 0x3F, 0xF7, 0x63, 0xFF, 0x00, 0xD1, 0x69, 0x5F, 0x63, 0xC0,
  0x9F, 0xF2, 0x3A, 0xA7, 0xFD, 0x75, 0x47, 0xD0, 0x70, 0xE7, 0xFB, 0xCC, 0xFF, 0x00, 0xC2, 0xFF, 0x00, 0x34, 0x66, 0x51, 0x45, 0x15, 0xFD, 0x16, 0x7D, 0x60, 0x51, 0x45, 0x14, 0x00, 0x51, 0x45, 0x14, 0x01, 0xE8, 0x3F, 0x0A,
  0xFF, 0x00, 0xE4, 0x58, 0xB9, 0xFF, 0x00, 0xAF, 0xD6, 0xFF, 0x00, 0xD0, 0x12, 0xBB, 0x8A, 0xE1, 0xFE, 0x15, 0xFF, 0x00, 0xC8, 0xB1, 0x73, 0xFF, 0x00, 0x5F, 0xAD, 0xFF, 0x00, 0xA0, 0x25, 0x77, 0x15, 0xFC, 0xA3, 0x99, 0x7F, 0xBD, 0xD4, 0xF5,
  0x3E, 0x17, 0x38, 0xFF, 0x00, 0x7E, 0xAB, 0xEA, 0x14, 0x51, 0x45, 0x70, 0x9E, 0x68, 0x51, 0x45, 0x14, 0x01, 0xCC, 0xFC, 0x40, 0xFF, 0x00, 0x91, 0x23, 0x51, 0xFF, 0x00, 0xB6, 0x5F, 0xFA, 0x31, 0x6B, 0xDB, 0xFC, 0x09, 0xFF, 0x00, 0x24, 0xF3,
  0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5E, 0x21, 0xF1, 0x03, 0xFE, 0x44, 0x8D, 0x47, 0xFE, 0xD9, 0x7F, 0xE8, 0xC5, 0xAF, 0x6F, 0xF0, 0x27, 0xFC, 0x93, 0xCF, 0x0D, 0x7F, 0xD8, 0x2A, 0xD7, 0xFF, 0x00, 0x45, 0x2D, 0x7D, 0x7E, 0x41, 0xFE, 0xED, 0x2F,
  0xF1, 0x3F, 0xC9, 0x1F, 0x77, 0xC2, 0xFF, 0x00, 0xEE, 0x72, 0xFF, 0x00, 0x13, 0xFC, 0x91, 0xF3, 0x3F, 0xC6, 0x39, 0x96, 0x0F, 0x8C, 0x7A, 0xF3, 0x30, 0x24, 0x15, 0x80, 0x71, 0xFF, 0x00, 0x5C, 0x22, 0xAE, 0x2B, 0xFB, 0x42, 0x2F, 0xEE, 0xBF,
  0xE4, 0x3F, 0xC6, 0xBD, 0x9B, 0x59, 0xFF, 0x00, 0x93, 0x85, 0xF1, 0x37, 0xFD, 0x79, 0x45, 0xFF, 0x00, 0xA2, 0xE0, 0xAD, 0xEA, 0xF6, 0xDF, 0x1A, 0x62, 0xF2, 0x8F, 0xF6, 0x5A, 0x31, 0x4D, 0x2D, 0x7E, 0xFF, 0x00, 0x90, 0xB3, 0x4C, 0xE6, 0x38,
  0x4C, 0x43, 0xA4, 0xE9, 0xF3, 0x68, 0xB5, 0xBD, 0xBF, 0x46, 0x7C, 0xF7, 0xFD, 0xA1, 0x17, 0xF7, 0x5F, 0xF2, 0x1F, 0xE3, 0x47, 0xF6, 0x84, 0x5F, 0xDD, 0x7F, 0xC8, 0x7F, 0x8D, 0x7D, 0x09, 0x45, 0x2F, 0xF8, 0x89, 0x99, 0x8F, 0xF2, 0x2F, 0xEB,
  0xE4, 0x79, 0xFF, 0x00, 0xEB, 0x24, 0x3F, 0xE7, 0xCF, 0xFE, 0x4D, 0xFF, 0x00, 0xDA, 0x9F, 0x3D, 0xFF, 0x00, 0x68, 0x45, 0xFD, 0xD7, 0xFC, 0x87, 0xF8, 0xD1, 0xFD, 0xA1, 0x17, 0xF7, 0x5F, 0xF2, 0x1F, 0xE3, 0x5F, 0x42, 0x51, 0x47, 0xFC, 0x44,
  0xCC, 0xC7, 0xF9, 0x17, 0xF5, 0xF2, 0x0F, 0xF5, 0x92, 0x1F, 0xF3, 0xE7, 0xFF, 0x00, 0x26, 0xFF, 0x00, 0xED, 0x4F, 0x9E, 0xFF, 0x00, 0xB4, 0x22, 0xFE, 0xEB, 0xFE, 0x43, 0xFC, 0x6B, 0xA9, 0xF0, 0x5F, 0x8D, 0x34, 0xDF, 0x0E, 0x68, 0xD3, 0x59,
  0xDE, 0x41, 0x74, 0xF2, 0x3D, 0xC3, 0x4A, 0x0C, 0x28, 0xA4, 0x60, 0xAA, 0x8E, 0xEC, 0x39, 0xE0, 0xD7, 0xAD, 0xD7, 0x8C, 0x78, 0x57, 0xFE, 0x41, 0x72, 0xFF, 0x00, 0xD7, 0x63, 0xFF, 0x00, 0xA0, 0xAD, 0x71, 0xE3, 0xF8, 0x8E, 0xAE, 0x7F, 0x45,
  0xAC, 0x5C, 0x34, 0x86, 0xD6, 0x7D, 0xFE, 0x5E, 0x47, 0xD1, 0xF0, 0xEE, 0x1A, 0x8F, 0x14, 0x54, 0x9E, 0x0E, 0xA2, 0xE4, 0x4A, 0xCE, 0xF7, 0xBF, 0x7F, 0x43, 0xAF, 0xFF, 0x00, 0x85, 0xA9, 0xA1, 0xFF, 0x00, 0xCF, 0xAE, 0xA3, 0xFF, 0x00, 0x7E,
  0xD3, 0xFF, 0x00, 0x8B, 0xA3, 0xFE, 0x16, 0xA6, 0x87, 0xFF, 0x00, 0x3E, 0xBA, 0x8F, 0xFD, 0xFB, 0x4F, 0xFE, 0x2E, 0xB3, 0x68, 0xAF, 0x0F, 0xEA, 0xB8, 0x4F, 0xE4, 0x7F, 0xF8, 0x17, 0xFC, 0x03, 0xEB, 0x7F, 0xE2, 0x14, 0xE0, 0x7F, 0xE7, 0xF3,
  0xFB, 0xBF, 0xFB, 0x63, 0x4B, 0xFE, 0x16, 0xA6, 0x87, 0xFF, 0x00, 0x3E, 0xBA, 0x8F, 0xFD, 0xFB, 0x4F, 0xFE, 0x2E, 0x8F, 0xF8, 0x5A, 0x9A, 0x1F, 0xFC, 0xFA, 0xEA, 0x3F, 0xF7, 0xED, 0x3F, 0xF8, 0xBA, 0xCD, 0xA2, 0x8F, 0xAA, 0xE1, 0x3F, 0x91,
  0xFF, 0x00, 0xE0, 0x5F, 0xF0, 0x03, 0xFE, 0x21, 0x4E, 0x07, 0xFE, 0x7F, 0x3F, 0xBB, 0xFF, 0x00, 0xB6, 0x34, 0xBF, 0xE1, 0x6A, 0x68, 0x7F, 0xF3, 0xEB, 0xA8, 0xFF, 0x00, 0xDF, 0xB4, 0xFF, 0x00, 0xE2, 0xEB, 0x1F, 0xC5, 0x1E, 0x3F, 0xD2, 0xB5,
  0xBF, 0x0E, 0x5D, 0xE9, 0xD6, 0xD6, 0xF7, 0xA9, 0x34, 0xDB, 0x36, 0xB4, 0x88, 0xA1, 0x46, 0x1D, 0x58, 0xE7, 0x0C, 0x7B, 0x0A,
  0x9A, 0xB3, 0x3C, 0x41, 0xFF, 0x00, 0x20, 0x3B, 0x9F, 0xF8, 0x0F, 0xFE, 0x84, 0x2B, 0x5A, 0x18, 0x6C, 0x2A, 0xAB, 0x17, 0x18, 0x3B, 0xDD, 0x75, 0xF3, 0xF4, 0x33, 0xAB, 0xE1, 0x9E, 0x0F, 0x07, 0x07, 0x8A, 0x8D, 0x56, 0xDC, 0x17, 0x36, 0xDF,
  0xCB, 0xAF, 0x7F, 0x23, 0x96, 0x8E, 0xFA, 0x24, 0x89, 0x14, 0xAB, 0xE4, 0x28, 0x1D, 0x05, 0x3B, 0xFB, 0x42, 0x2F, 0xEE, 0xBF, 0xE4, 0x3F, 0xC6, 0xBD, 0xC7, 0xC3, 0x9F, 0xF2, 0x2C, 0x69, 0x3F, 0xF5, 0xE5, 0x0F, 0xFE, 0x80, 0x2B, 0x4E, 0xBE,
  0x8F, 0xFE, 0x22, 0x3E, 0x61, 0x4B, 0xF7, 0x6A, 0x0A,
  0xD1, 0xD3, 0xEE, 0xF9, 0x1F, 0x9B, 0x55, 0xE2, 0x28, 0x42, 0x6E, 0x3E, 0xC7, 0x67, 0xFC, 0xDF, 0xF0, 0x0F, 0x9E, 0xFF, 0x00, 0xB4, 0x22, 0xFE, 0xEB, 0xFE, 0x43, 0xFC, 0x68, 0xFE, 0xD0, 0x8B, 0xFB, 0xAF, 0xF9, 0x0F, 0xF1, 0xAF, 0xA1, 0x28,
  0xA3, 0xFE, 0x22, 0x66, 0x63, 0xFC, 0x8B, 0xFA, 0xF9, 0x11, 0xFE, 0xB2, 0x43, 0xFE, 0x7C, 0xFF, 0x00, 0xE4, 0xDF, 0xFD, 0xA9, 0xF3, 0xDF, 0xF6, 0x84, 0x5F, 0xDD, 0x7F, 0xC8, 0x7F, 0x8D, 0x1F, 0xDA, 0x11, 0x7F, 0x75, 0xFF, 0x00, 0x21, 0xFE,
  0x35, 0xF4, 0x25, 0x14, 0x7F, 0xC4, 0x4C, 0xCC, 0x7F, 0x91, 0x7F, 0x5F, 0x20, 0xFF, 0x00, 0x59, 0x21, 0xFF, 0x00, 0x3E, 0x7F, 0xF2, 0x6F, 0xFE, 0xD4, 0xF9, 0xFA, 0xD3, 0x53, 0x86, 0x0D, 0x67, 0x4E, 0xBC, 0x65, 0x90, 0xC7, 0x6D, 0x70, 0x92,
  0xB8, 0x00, 0x64, 0x80, 0xC0, 0x9C, 0x73, 0xD7, 0x8A, 0xF4, 0x9F, 0xF8, 0x5A, 0x9A, 0x1F, 0xFC, 0xFA, 0xEA, 0x3F, 0xF7, 0xED, 0x3F, 0xF8, 0xBA, 0xAB, 0xF1, 0x27, 0xFE, 0x42, 0x9E, 0x1C, 0xFF, 0x00, 0xAE, 0xCF, 0xFF, 0x00, 0xA1, 0x47, 0x55,
  0xEB, 0xC9, 0xCC, 0xB1, 0xB1, 0xCD, 0xE5, 0x1C, 0x6E, 0x26, 0x1E, 0xF4, 0xBB, 0x3B, 0x6D, 0xA7, 0x6F, 0x23, 0xED, 0xF2, 0x2E, 0x17, 0xC3, 0x71, 0x46, 0x11, 0x62, 0xEA, 0xC9, 0xC2, 0xD7, 0x56, 0xDF, 0xAB, 0xEB, 0x74, 0x69, 0x7F, 0xC2, 0xD4,
  0xD0, 0xFF, 0x00, 0xE7, 0xD7, 0x51, 0xFF, 0x00, 0xBF, 0x69, 0xFF, 0x00, 0xC5, 0xD1, 0xFF, 0x00, 0x0B, 0x53, 0x43, 0xFF, 0x00, 0x9F, 0x5D, 0x47, 0xFE, 0xFD, 0xA7, 0xFF, 0x00, 0x17, 0x59, 0xB4, 0x57, 0x9B, 0xF5, 0x5C, 0x27, 0xF2, 0x3F, 0xFC,
  0x0B, 0xFE, 0x01, 0xEC, 0xFF, 0x00, 0xC4, 0x29, 0xC0, 0xFF, 0x00, 0xCF, 0xE7, 0xF7, 0x7F, 0xF6, 0xC6, 0x97, 0xFC, 0x2D, 0x4D, 0x0F, 0xFE, 0x7D, 0x75, 0x1F, 0xFB, 0xF6, 0x9F, 0xFC, 0x5D, 0x1F, 0xF0, 0xB5, 0x34, 0x3F, 0xF9, 0xF5, 0xD4, 0x7F,
  0xEF, 0xDA, 0x7F, 0xF1, 0x75, 0x9B, 0x45, 0x1F, 0x55, 0xC2, 0x7F, 0x23, 0xFF, 0x00, 0xC0, 0xBF, 0xE0, 0x07, 0xFC, 0x42, 0x9C, 0x0F, 0xFC, 0xFE, 0x7F, 0x77, 0xFF, 0x00, 0x6C, 0x69, 0x7F, 0xC2, 0xD4, 0xD0, 0xFF, 0x00, 0xE7, 0xD7, 0x51, 0xFF,
  0x00, 0xBF, 0x69, 0xFF, 0x00, 0xC5, 0xD7, 0x9F, 0xEB, 0xDA, 0xDD, 0xB6, 0xA9, 0xE2, 0x7B, 0xCD, 0x4E, 0x04, 0x95, 0x61, 0x99, 0x50, 0x2A, 0xB8, 0x01, 0x86, 0x15, 0x47, 0x38, 0x24, 0x76, 0x3D, 0xEB, 0xAE, 0xA4, 0xF0, 0x67, 0xFC, 0x94, 0x3D,
  0x4B, 0xFE, 0xBC, 0xBF, 0xAC, 0x75, 0xDF, 0x97, 0x62, 0x29, 0xE5, 0x95, 0x5E, 0x2F, 0x0F, 0x0F, 0x7A, 0x0A,
  0xFA, 0xBB, 0xF5, 0x5E, 0x47, 0x97, 0x9C, 0x70, 0x86, 0x1B, 0x86, 0xB0, 0x92, 0xC7, 0xD2, 0x9B, 0x9B, 0xF8, 0x6D, 0xB6, 0xFA, 0xEF, 0x77, 0xDB, 0xB1, 0xC3, 0x7F, 0x68, 0x45, 0xFD, 0xD7, 0xFC, 0x87, 0xF8, 0xD1, 0xFD, 0xA1, 0x17, 0xF7, 0x5F,
  0xF2, 0x1F, 0xE3, 0x5F, 0x42, 0x51, 0x5E, 0xCF, 0xFC, 0x44, 0xCC, 0xC7, 0xF9, 0x17, 0xF5, 0xF2, 0x3E, 0x0F, 0xFD, 0x64, 0x87, 0xFC, 0xF9, 0xFF, 0x00, 0xC9, 0xBF, 0xFB, 0x53, 0xE7, 0xBF, 0xED, 0x08, 0xBF, 0xBA, 0xFF, 0x00, 0x90, 0xFF, 0x00,
  0x1A, 0x3F, 0xB4, 0x22, 0xFE, 0xEB, 0xFE, 0x43, 0xFC, 0x6B, 0xE8, 0x4A, 0x28, 0xFF, 0x00, 0x88, 0x99, 0x98, 0xFF, 0x00, 0x22, 0xFE, 0xBE, 0x41, 0xFE, 0xB2, 0x43, 0xFE, 0x7C, 0xFF, 0x00, 0xE4, 0xDF, 0xFD, 0xA9, 0xF3, 0xDF, 0xF6, 0x84, 0x5F,
  0xDD, 0x7F, 0xC8, 0x7F, 0x8D, 0x1F, 0xDA, 0x11, 0x7F, 0x75, 0xFF, 0x00, 0x21, 0xFE, 0x35, 0xF4, 0x25, 0x14, 0x7F, 0xC4, 0x4C, 0xCC, 0x7F, 0x91, 0x7F, 0x5F, 0x20, 0xFF, 0x00, 0x59, 0x21, 0xFF, 0x00, 0x3E, 0x7F, 0xF2, 0x6F, 0xFE, 0xD4, 0xF2,
  0x4F, 0x05, 0xF8, 0xD3, 0x4D, 0xF0, 0xE6, 0x8D, 0x35, 0x9D, 0xE4, 0x17, 0x4F, 0x23, 0xDC, 0x34, 0xA0, 0xC2, 0x8A, 0x46, 0x0A,
  0xA8, 0xEE, 0xC3, 0x9E, 0x0D, 0x74, 0x7F, 0xF0, 0xB5, 0x34, 0x3F, 0xF9, 0xF5, 0xD4, 0x7F, 0xEF, 0xDA, 0x7F, 0xF1, 0x75, 0xC8, 0x78, 0x57, 0xFE, 0x41, 0x72, 0xFF, 0x00, 0xD7, 0x63, 0xFF, 0x00, 0xA0, 0xAD, 0x6E, 0xD7, 0xCF, 0xE2, 0xF0, 0xF8,
  0x69, 0x56, 0x93, 0x9C, 0x5B, 0x7E, 0xBF, 0xF0, 0x0F, 0xD2, 0xE8, 0x78, 0x73, 0x84, 0xCC, 0x69, 0xAC, 0x64, 0xEA, 0xB4, 0xE7, 0xAD, 0xAD, 0xFF, 0x00, 0x04, 0xD2, 0xFF, 0x00, 0x85, 0xA9, 0xA1, 0xFF, 0x00, 0xCF, 0xAE, 0xA3, 0xFF, 0x00, 0x7E,
  0xD3, 0xFF, 0x00, 0x8B, 0xA3, 0xFE, 0x16, 0xA6, 0x87, 0xFF, 0x00, 0x3E, 0xBA, 0x8F, 0xFD, 0xFB, 0x4F, 0xFE, 0x2E, 0xB3, 0x68, 0xAE, 0x7F, 0xAA, 0xE1, 0x3F, 0x91, 0xFF, 0x00, 0xE0, 0x5F, 0xF0, 0x0D, 0x7F, 0xE2, 0x14, 0xE0, 0x7F, 0xE7, 0xF3,
  0xFB, 0xBF, 0xFB, 0x63, 0x4B, 0xFE, 0x16, 0xA6, 0x87, 0xFF, 0x00, 0x3E, 0xBA, 0x8F, 0xFD, 0xFB, 0x4F, 0xFE, 0x2E, 0x8F, 0xF8, 0x5A, 0x9A, 0x1F, 0xFC, 0xFA, 0xEA, 0x3F, 0xF7, 0xED, 0x3F, 0xF8, 0xBA, 0xCD, 0xA2, 0x8F, 0xAA, 0xE1, 0x3F, 0x91,
  0xFF, 0x00, 0xE0, 0x5F, 0xF0, 0x03, 0xFE, 0x21, 0x4E, 0x07, 0xFE, 0x7F, 0x3F, 0xBB, 0xFF, 0x00, 0xB6, 0x21, 0xF1, 0x47, 0x8F, 0xF4, 0xAD, 0x6F, 0xC3, 0x97, 0x7A, 0x75, 0xB5, 0xBD, 0xEA, 0x4D, 0x36, 0xCD, 0xAD, 0x22, 0x28, 0x51, 0x87, 0x56,
  0x39, 0xC3, 0x1E, 0xC2, 0xBE, 0x99, 0xF0, 0x27, 0xFC, 0x93, 0xCF, 0x0D, 0x7F, 0xD8, 0x2A, 0xD7, 0xFF, 0x00, 0x45, 0x2D, 0x7C, 0xB3, 0xE2, 0x0F, 0xF9, 0x01, 0xDC, 0xFF, 0x00, 0xC0, 0x7F, 0xF4, 0x21, 0x5F, 0x53, 0x78, 0x13, 0xFE, 0x49, 0xE7,
  0x86, 0xBF, 0xEC, 0x15, 0x6B, 0xFF, 0x00, 0xA2, 0x96, 0xBD, 0xAC, 0xB6, 0x9D, 0x3A, 0x74, 0x9A, 0xA6, 0xAC, 0xAF, 0xDE, 0xFD, 0x11, 0xE7, 0x62, 0xF8, 0x7E, 0x96, 0x43, 0x35, 0x85, 0xA5, 0x2E, 0x64, 0xD7, 0x37, 0xDF, 0xA7, 0x77, 0xD8, 0xF1,
  0x8D, 0x67, 0xFE, 0x4E, 0x17, 0xC4, 0xDF, 0xF5, 0xE5, 0x17, 0xFE, 0x8B, 0x82, 0xB7, 0xAB, 0x07, 0x59, 0xFF, 0x00, 0x93, 0x85, 0xF1, 0x37, 0xFD, 0x79, 0x45, 0xFF, 0x00, 0xA2, 0xE0, 0xAD, 0xEA, 0xF9, 0xCC, 0xF3, 0xFD, 0xED, 0xFA, 0x23, 0xF3,
  0x4E, 0x23, 0xFF, 0x00, 0x7E, 0x7E, 0x88, 0x28, 0xA2, 0x8A, 0xF1, 0xCF, 0x04, 0x28, 0xA2, 0x8A, 0x00, 0x2B, 0xC6, 0x3C, 0x2B, 0xFF, 0x00, 0x20, 0xB9, 0x7F, 0xEB, 0xB1, 0xFF, 0x00, 0xD0, 0x56, 0xBD, 0x9E, 0xBC, 0x63, 0xC2, 0xBF, 0xF2, 0x0B,
  0x97, 0xFE, 0xBB, 0x1F, 0xFD, 0x05, 0x6B, 0xDA, 0xCA, 0xFF, 0x00, 0x83, 0x57, 0xFE, 0xDD, 0xFD, 0x4F, 0xD4, 0xFC, 0x2A, 0xFF, 0x00, 0x91, 0x8D, 0x5F, 0x45, 0xFA, 0x9B, 0xB4, 0x51, 0x45, 0x75, 0x9F, 0xBE, 0x85, 0x14, 0x51, 0x40, 0x05, 0x66,
  0x78, 0x83, 0xFE, 0x40, 0x77, 0x3F, 0xF0, 0x1F, 0xFD, 0x08, 0x56, 0x9D, 0x66, 0x78, 0x83, 0xFE, 0x40, 0x77, 0x3F, 0xF0, 0x1F, 0xFD, 0x08, 0x56, 0xB4, 0x3F, 0x8B, 0x1F, 0x54, 0x70, 0xE6, 0x9F, 0xEE, 0x35, 0xBF, 0xC1, 0x2F, 0xC9, 0x9E, 0x95,
  0xE1, 0xCF, 0xF9, 0x16, 0x34, 0x9F, 0xFA, 0xF2, 0x87, 0xFF, 0x00, 0x40, 0x15, 0xA7, 0x59, 0x9E, 0x1C, 0xFF, 0x00, 0x91, 0x63, 0x49, 0xFF, 0x00, 0xAF, 0x28, 0x7F, 0xF4, 0x01, 0x5A, 0x75, 0xF3, 0x55, 0xBF, 0x8B, 0x2F, 0x56, 0x7F, 0x21, 0xE2,
  0x3F, 0x8D, 0x3F, 0x57, 0xF9, 0x85, 0x14, 0x51, 0x59, 0x18, 0x85, 0x14, 0x51, 0x40, 0x1E, 0x7B, 0xF1, 0x27, 0xFE, 0x42, 0x9E, 0x1C, 0xFF, 0x00, 0xAE, 0xCF, 0xFF, 0x00, 0xA1, 0x47, 0x55, 0xEA, 0xC7, 0xC4, 0x9F, 0xF9, 0x0A,
  0x78, 0x73, 0xFE, 0xBB, 0x3F, 0xFE, 0x85, 0x1D, 0x57, 0xAF, 0xA3, 0xA1, 0xFE, 0xE9, 0x4B, 0xE7, 0xFF, 0x00, 0xA5, 0x33, 0xFA, 0x1F, 0xC2, 0xFF, 0x00, 0xF9, 0x14, 0x3F, 0x57, 0xF9, 0xB0, 0xA2, 0x8A, 0x2A, 0x8F, 0xD2, 0x42, 0x8A, 0x28, 0xA0,
  0x02, 0x93, 0xC1, 0x9F, 0xF2, 0x50, 0xF5, 0x2F, 0xFA, 0xF2, 0xFE, 0xB1, 0xD2, 0xD2, 0x78, 0x33, 0xFE, 0x4A, 0x1E, 0xA5, 0xFF, 0x00, 0x5E, 0x5F, 0xD6, 0x3A, 0x25, 0xFC, 0x1A, 0xBF, 0xE1, 0xFD, 0x51, 0xF0, 0x7E, 0x23, 0xFF, 0x00, 0xC8, 0x8E,
  0x5E, 0xAB, 0xF2, 0x67, 0xA5, 0xD1, 0x45, 0x15, 0xF3, 0x47, 0xF3, 0x58, 0x51, 0x45, 0x14, 0x00, 0x51, 0x45, 0x14, 0x01, 0xE3, 0x1E, 0x15, 0xFF, 0x00, 0x90, 0x5C, 0xBF, 0xF5, 0xD8, 0xFF, 0x00, 0xE8, 0x2B, 0x5B, 0xB5, 0x85, 0xE1, 0x5F, 0xF9,
  0x05, 0xCB, 0xFF, 0x00, 0x5D, 0x8F, 0xFE, 0x82, 0xB5, 0xBB, 0x5F, 0x59, 0x8A, 0xFE, 0x34, 0x8F, 0xEB, 0xBC, 0x8F, 0xFE, 0x45, 0xD4, 0x7D, 0x02, 0x8A, 0x28, 0xAC, 0x0F, 0x54, 0x28, 0xA2, 0x8A, 0x00, 0xCC, 0xF1, 0x07, 0xFC, 0x80, 0xEE, 0x7F,
  0xE0, 0x3F, 0xFA, 0x10, 0xAF, 0xA9, 0xBC, 0x09, 0xFF, 0x00, 0x24, 0xF3, 0xC3, 0x5F, 0xF6, 0x0A,
  0xB5, 0xFF, 0x00, 0xD1, 0x4B, 0x5F, 0x2C, 0xF8, 0x83, 0xFE, 0x40, 0x77, 0x3F, 0xF0, 0x1F, 0xFD, 0x08, 0x57, 0xD4, 0xDE, 0x04, 0xFF, 0x00, 0x92, 0x79, 0xE1, 0xAF, 0xFB, 0x05, 0x5A, 0xFF, 0x00, 0xE8, 0xA5, 0xAF, 0x63, 0x2F, 0xFE, 0x13, 0xF5,
  0xFF, 0x00, 0x23, 0xF3, 0x8E, 0x2F, 0xFF, 0x00, 0x7E, 0x87, 0xF8, 0x17, 0xE7, 0x23, 0xC6, 0x35, 0x9F, 0xF9, 0x38, 0x5F, 0x13, 0x7F, 0xD7, 0x94, 0x5F, 0xFA, 0x2E, 0x0A,
  0xDE, 0xAC, 0x1D, 0x67, 0xFE, 0x4E, 0x17, 0xC4, 0xDF, 0xF5, 0xE5, 0x17, 0xFE, 0x8B, 0x82, 0xB7, 0xAB, 0xE6, 0xB3, 0xCF, 0xF7, 0xB7, 0xE8, 0x8F, 0xC5, 0x38, 0x8F, 0xFD, 0xF9, 0xFA, 0x20, 0xA2, 0x8A, 0x2B, 0xC7, 0x3C, 0x10, 0xA2, 0x8A, 0x28,
  0x00, 0xAF, 0x18, 0xF0, 0xAF, 0xFC, 0x82, 0xE5, 0xFF, 0x00, 0xAE, 0xC7, 0xFF, 0x00, 0x41, 0x5A, 0xF6, 0x7A, 0xF1, 0x8F, 0x0A,
  0xFF, 0x00, 0xC8, 0x2E, 0x5F, 0xFA, 0xEC, 0x7F, 0xF4, 0x15, 0xAF, 0x6B, 0x2B, 0xFE, 0x0D, 0x5F, 0xFB, 0x77, 0xF5, 0x3F, 0x53, 0xF0, 0xAB, 0xFE, 0x46, 0x35, 0x7D, 0x17, 0xEA, 0x6E, 0xD1, 0x45, 0x15, 0xD6, 0x7E, 0xFA, 0x14, 0x51, 0x45, 0x00,
  0x15, 0x99, 0xE2, 0x0F, 0xF9, 0x01, 0xDC, 0xFF, 0x00, 0xC0, 0x7F, 0xF4, 0x21, 0x5A, 0x75, 0x99, 0xE2, 0x0F, 0xF9, 0x01, 0xDC, 0xFF, 0x00, 0xC0, 0x7F, 0xF4, 0x21, 0x5A, 0xD0, 0xFE, 0x2C, 0x7D, 0x51, 0xC3, 0x9A, 0x7F, 0xB8, 0xD6, 0xFF, 0x00,
  0x04, 0xBF, 0x26, 0x7A, 0x57, 0x87, 0x3F, 0xE4, 0x58, 0xD2, 0x7F, 0xEB, 0xCA, 0x1F, 0xFD, 0x00, 0x56, 0x9D, 0x66, 0x78, 0x73, 0xFE, 0x45, 0x8D, 0x27, 0xFE, 0xBC, 0xA1, 0xFF, 0x00, 0xD0, 0x05, 0x69, 0xD7, 0xCD, 0x56, 0xFE, 0x2C, 0xBD, 0x59,
  0xFC, 0x87, 0x88, 0xFE, 0x34, 0xFD, 0x5F, 0xE6, 0x14, 0x51, 0x45, 0x64, 0x62, 0x14, 0x51, 0x45, 0x00, 0x79, 0xEF, 0xC4, 0x9F, 0xF9, 0x0A,
  0x78, 0x73, 0xFE, 0xBB, 0x3F, 0xFE, 0x85, 0x1D, 0x57, 0xAB, 0x1F, 0x12, 0x7F, 0xE4, 0x29, 0xE1, 0xCF, 0xFA, 0xEC, 0xFF, 0x00, 0xFA, 0x14, 0x75, 0x5E, 0xBE, 0x8E, 0x87, 0xFB, 0xA5, 0x2F, 0x9F, 0xFE, 0x94, 0xCF, 0xE8, 0x7F, 0x0B, 0xFF, 0x00,
  0xE4, 0x50, 0xFD, 0x5F, 0xE6, 0xC2, 0x8A, 0x28, 0xAA, 0x3F, 0x49, 0x0A,
  0x28, 0xA2, 0x80, 0x0A,
  0x4F, 0x06, 0x7F, 0xC9, 0x43, 0xD4, 0xBF, 0xEB, 0xCB, 0xFA, 0xC7, 0x4B, 0x49, 0xE0, 0xCF, 0xF9, 0x28, 0x7A, 0x97, 0xFD, 0x79, 0x7F, 0x58, 0xE8, 0x97, 0xF0, 0x6A, 0xFF, 0x00, 0x87, 0xF5, 0x47, 0xC1, 0xF8, 0x8F, 0xFF, 0x00, 0x22, 0x39, 0x7A,
  0xAF, 0xC9, 0x9E, 0x97, 0x45, 0x14, 0x57, 0xCD, 0x1F, 0xCD, 0x61, 0x45, 0x14, 0x50, 0x01, 0x45, 0x14, 0x50, 0x07, 0x8C, 0x78, 0x57, 0xFE, 0x41, 0x72, 0xFF, 0x00, 0xD7, 0x63, 0xFF, 0x00, 0xA0, 0xAD, 0x6E, 0xD6, 0x17, 0x85, 0x7F, 0xE4, 0x17,
  0x2F, 0xFD, 0x76, 0x3F, 0xFA, 0x0A,
  0xD6, 0xED, 0x7D, 0x66, 0x2B, 0xF8, 0xD2, 0x3F, 0xAE, 0xF2, 0x3F, 0xF9, 0x17, 0x51, 0xF4, 0x0A,
  0x28, 0xA2, 0xB0, 0x3D, 0x50, 0xA2, 0x8A, 0x28, 0x03, 0x33, 0xC4, 0x1F, 0xF2, 0x03, 0xB9, 0xFF, 0x00, 0x80, 0xFF, 0x00, 0xE8, 0x42, 0xBE, 0xA6, 0xF0, 0x27, 0xFC, 0x93, 0xCF, 0x0D, 0x7F, 0xD8, 0x2A, 0xD7, 0xFF, 0x00, 0x45, 0x2D, 0x7C, 0xB3,
  0xE2, 0x0F, 0xF9, 0x01, 0xDC, 0xFF, 0x00, 0xC0, 0x7F, 0xF4, 0x21, 0x5F, 0x53, 0x78, 0x13, 0xFE, 0x49, 0xE7, 0x86, 0xBF, 0xEC, 0x15, 0x6B, 0xFF, 0x00, 0xA2, 0x96, 0xBD, 0x8C, 0xBF, 0xF8, 0x4F, 0xD7, 0xFC, 0x8F, 0xCE, 0x38, 0xBF, 0xFD, 0xFA,
  0x1F, 0xE0, 0x5F, 0x9C, 0x8F, 0x18, 0xD6, 0x7F, 0xE4, 0xE1, 0x7C, 0x4D, 0xFF, 0x00, 0x5E, 0x51, 0x7F, 0xE8, 0xB8, 0x2B, 0x7A, 0xB9, 0xDF, 0x1A, 0xDA, 0xF8, 0x93, 0x4C, 0xF8, 0xCD, 0xAF, 0x6B, 0x16, 0x1E, 0x15, 0xD5, 0x75, 0x4B, 0x59, 0xE1,
  0x8A, 0x24, 0x78, 0x2D, 0xA4, 0x28, 0x7F, 0x75, 0x16, 0x48, 0x60, 0x84, 0x1C, 0x15, 0x23, 0xFF, 0x00, 0xD5, 0x55, 0xBF, 0xE1, 0x20, 0xF1, 0x87, 0xFD, 0x13, 0x9D, 0x73, 0xFE, 0xFC, 0xCD, 0xFF, 0x00, 0xC6, 0xAB, 0xC6, 0xCD, 0x72, 0xFC, 0x4D,
  0x7C, 0x43, 0x9D, 0x38, 0xDD, 0x59, 0x75, 0x5F, 0xE6, 0x7E, 0x49, 0x9D, 0x65, 0x58, 0xBC, 0x4E, 0x2D, 0xD4, 0xA3, 0x0B, 0xAB, 0x2E, 0xAB, 0xF5, 0x67, 0x57, 0x45, 0x72, 0x9F, 0xF0, 0x90, 0x78, 0xC3, 0xFE, 0x89, 0xCE, 0xB9, 0xFF, 0x00, 0x7E,
  0x66, 0xFF, 0x00, 0xE3, 0x54, 0x7F, 0xC2, 0x41, 0xE3, 0x0F, 0xFA, 0x27, 0x3A, 0xE7, 0xFD, 0xF9, 0x9B, 0xFF, 0x00, 0x8D, 0x57, 0x9D, 0xFD, 0x8F, 0x8D, 0xFE, 0x4F, 0xC5, 0x7F, 0x99, 0xE4, 0xFF, 0x00, 0x60, 0xE6, 0x1F, 0xF3, 0xEF, 0xF1, 0x8F,
  0xF9, 0x9D, 0x5D, 0x15, 0xCA, 0x7F, 0xC2, 0x41, 0xE3, 0x0F, 0xFA, 0x27, 0x3A, 0xE7, 0xFD, 0xF9, 0x9B, 0xFF, 0x00, 0x8D, 0x51, 0xFF, 0x00, 0x09, 0x07, 0x8C, 0x3F, 0xE8, 0x9C, 0xEB, 0x9F, 0xF7, 0xE6, 0x6F, 0xFE, 0x35, 0x47, 0xF6, 0x3E, 0x37,
  0xF9, 0x3F, 0x15, 0xFE, 0x61, 0xFD, 0x83, 0x98, 0x7F, 0xCF, 0xBF, 0xC6, 0x3F, 0xE6, 0x75, 0x75, 0xE3, 0x1E, 0x15, 0xFF, 0x00, 0x90, 0x5C, 0xBF, 0xF5, 0xD8, 0xFF, 0x00, 0xE8, 0x2B, 0x5D, 0xE7, 0xFC, 0x24, 0x1E, 0x30, 0xFF, 0x00, 0xA2, 0x73,
  0xAE, 0x7F, 0xDF, 0x99, 0xBF, 0xF8, 0xD5, 0x71, 0x9A, 0x56, 0x83, 0xE3, 0x0D, 0x32, 0xD5, 0xA1, 0xFF, 0x00, 0x84, 0x33, 0x5C, 0x97, 0x73, 0x97, 0xCF, 0xD8, 0xA6, 0x5E, 0xC0, 0x7F, 0x73, 0xDA, 0xBD, 0x3C, 0x06, 0x5F, 0x89, 0xA5, 0x4E, 0xA4,
  0x67, 0x1B, 0x37, 0x6B, 0x6A, 0xBA, 0x5F, 0xCC, 0xFB, 0xEF, 0x0F, 0xE9, 0xCB, 0x29, 0xC6, 0xCE, 0xAE, 0x39, 0x72, 0x45, 0xAD, 0x3A, 0xF7, 0xED, 0x73, 0x52, 0x8A, 0x87, 0xEC, 0x5E, 0x30, 0xFF, 0x00, 0xA1, 0x1B, 0x5C, 0xFF, 0x00, 0xC0, 0x49,
  0xBF, 0xF8, 0x8A, 0x3E, 0xC5, 0xE3, 0x0F, 0xFA, 0x11, 0xB5, 0xCF, 0xFC, 0x04, 0x9B, 0xFF, 0x00, 0x88, 0xAE, 0x8F, 0xA9, 0xD7, 0xFE, 0x5F, 0xC5, 0x1F, 0xAF, 0x7F, 0xAC, 0x99, 0x5F, 0xFC, 0xFD, 0xFF, 0x00, 0xC9, 0x65, 0xFE, 0x44, 0xD4, 0x54,
  0x3F, 0x62, 0xF1, 0x87, 0xFD, 0x08, 0xDA, 0xE7, 0xFE, 0x02, 0x4D, 0xFF, 0x00, 0xC4, 0x51, 0xF6, 0x2F, 0x18, 0x7F, 0xD0, 0x8D, 0xAE, 0x7F, 0xE0, 0x24, 0xDF, 0xFC, 0x45, 0x1F, 0x53, 0xAF, 0xFC, 0xBF, 0x8A, 0x0F, 0xF5, 0x93, 0x2B, 0xFF, 0x00,
  0x9F, 0xBF, 0xF9, 0x2C, 0xBF, 0xC8, 0x9A, 0xB3, 0x3C, 0x41, 0xFF, 0x00, 0x20, 0x3B, 0x9F, 0xF8, 0x0F, 0xFE, 0x84, 0x2A, 0xEF, 0xD8, 0xBC, 0x61, 0xFF, 0x00, 0x42, 0x36, 0xB9, 0xFF, 0x00, 0x80, 0x93, 0x7F, 0xF1, 0x15, 0x57, 0x50, 0xD1, 0xBC,
  0x61, 0x7F, 0x63, 0x25, 0xB7, 0xFC, 0x21, 0x5A, 0xE2, 0x6F, 0xC7, 0xCD, 0xF6, 0x29, 0x8E, 0x30, 0x41, 0xE9, 0xB3, 0xDA, 0xB4, 0xA5, 0x84, 0xAD, 0x1A, 0x91, 0x6D, 0x75, 0x5D, 0x8E, 0x4C, 0x7F, 0x10, 0x65, 0xD5, 0x70, 0xB5, 0x69, 0xC2, 0xA5,
  0xDB, 0x8B, 0x4B, 0x49, 0x6E, 0xD3, 0xF2, 0x3D, 0x1F, 0xC3, 0x9F, 0xF2, 0x2C, 0x69, 0x3F, 0xF5, 0xE5, 0x0F, 0xFE, 0x80, 0x2B, 0x4E, 0xB8, 0xAD, 0x3B, 0x54, 0xF1, 0x86, 0x9F, 0xA5, 0xDA, 0x59, 0x7F, 0xC2, 0xBC, 0xD7, 0x24, 0xFB, 0x3C, 0x29,
  0x16, 0xFF, 0x00, 0x22, 0x61, 0xBB, 0x6A, 0x81, 0x9C, 0x79, 0x5C, 0x74, 0xAB, 0x5F, 0xF0, 0x90, 0x78, 0xC3, 0xFE, 0x89, 0xCE, 0xB9, 0xFF, 0x00, 0x7E, 0x66, 0xFF, 0x00, 0xE3, 0x55, 0xE1, 0xD5, 0xCA, 0x71, 0x92, 0x9C, 0x9A, 0x87, 0x5E, 0xEB,
  0xFC, 0xCF, 0xE7, 0x2A, 0xD9, 0x16, 0x3E, 0x55, 0x25, 0x25, 0x4F, 0x46, 0xDF, 0x58, 0xFF, 0x00, 0x99, 0xD5, 0xD1, 0x5C, 0xA7, 0xFC, 0x24, 0x1E, 0x30, 0xFF, 0x00, 0xA2, 0x73, 0xAE, 0x7F, 0xDF, 0x99, 0xBF, 0xF8, 0xD5, 0x1F, 0xF0, 0x90, 0x78,
  0xC3, 0xFE, 0x89, 0xCE, 0xB9, 0xFF, 0x00, 0x7E, 0x66, 0xFF, 0x00, 0xE3, 0x55, 0x1F, 0xD8, 0xF8, 0xDF, 0xE4, 0xFC, 0x57, 0xF9, 0x99, 0xFF, 0x00, 0x60, 0xE6, 0x1F, 0xF3, 0xEF, 0xF1, 0x8F, 0xF9, 0x9D, 0x5D, 0x15, 0xCA, 0x7F, 0xC2, 0x41, 0xE3,
  0x0F, 0xFA, 0x27, 0x3A, 0xE7, 0xFD, 0xF9, 0x9B, 0xFF, 0x00, 0x8D, 0x51, 0xFF, 0x00, 0x09, 0x07, 0x8C, 0x3F, 0xE8, 0x9C, 0xEB, 0x9F, 0xF7, 0xE6, 0x6F, 0xFE, 0x35, 0x47, 0xF6, 0x3E, 0x37, 0xF9, 0x3F, 0x15, 0xFE, 0x61, 0xFD, 0x83, 0x98, 0x7F,
  0xCF, 0xBF, 0xC6, 0x3F, 0xE6, 0x64, 0x7C, 0x49, 0xFF, 0x00, 0x90, 0xA7, 0x87, 0x3F, 0xEB, 0xB3, 0xFF, 0x00, 0xE8, 0x51, 0xD5, 0x7A, 0x6F, 0x89, 0x6D, 0xFC, 0x61, 0xE2, 0x1B, 0xAD, 0x36, 0x6F, 0xF8, 0x41, 0x75, 0xCB, 0x7F, 0xB1, 0x3B, 0x3E,
  0x3E, 0xC9, 0x33, 0xEF, 0xC9, 0x53, 0xFF, 0x00, 0x3C, 0xC6, 0x3E, 0xEF, 0xBF, 0x5A, 0x8F, 0xEC, 0x5E, 0x30, 0xFF, 0x00, 0xA1, 0x1B, 0x5C, 0xFF, 0x00, 0xC0, 0x49, 0xBF, 0xF8, 0x8A, 0xF6, 0xA9, 0x60, 0xAB, 0xC7, 0x0F, 0x4E, 0x0E, 0x3A, 0xAB,
  0xDF, 0x55, 0xDD, 0x9F, 0xB2, 0xF0, 0x1E, 0x36, 0x86, 0x55, 0x96, 0xFB, 0x0C, 0x6C, 0xB9, 0x65, 0x7D, 0xAC, 0xDF, 0x57, 0xDA, 0xE8, 0x9A, 0x8A, 0x87, 0xEC, 0x5E, 0x30, 0xFF, 0x00, 0xA1, 0x1B, 0x5C, 0xFF, 0x00, 0xC0, 0x49, 0xBF, 0xF8, 0x8A,
  0x3E, 0xC5, 0xE3, 0x0F, 0xFA, 0x11, 0xB5, 0xCF, 0xFC, 0x04, 0x9B, 0xFF, 0x00, 0x88, 0xA7, 0xF5, 0x3A, 0xFF, 0x00, 0xCB, 0xF8, 0xA3, 0xED, 0xFF, 0x00, 0xD6, 0x4C, 0xAF, 0xFE, 0x7E, 0xFF, 0x00, 0xE4, 0xB2, 0xFF, 0x00, 0x22, 0x6A, 0x2A, 0x1F,
  0xB1, 0x78, 0xC3, 0xFE, 0x84, 0x6D, 0x73, 0xFF, 0x00, 0x01, 0x26, 0xFF, 0x00, 0xE2, 0x28, 0xFB, 0x17, 0x8C, 0x3F, 0xE8, 0x46, 0xD7, 0x3F, 0xF0, 0x12, 0x6F, 0xFE, 0x22, 0x8F, 0xA9, 0xD7, 0xFE, 0x5F, 0xC5, 0x07, 0xFA, 0xC9, 0x95, 0xFF, 0x00,
  0xCF, 0xDF, 0xFC, 0x96, 0x5F, 0xE4, 0x4D, 0x49, 0xE0, 0xCF, 0xF9, 0x28, 0x7A, 0x97, 0xFD, 0x79, 0x7F, 0x58, 0xEA, 0x2F, 0xB1, 0x78, 0xC3, 0xFE, 0x84, 0x6D, 0x73, 0xFF, 0x00, 0x01, 0x26, 0xFF, 0x00, 0xE2, 0x29, 0x34, 0x5B, 0x1F, 0x18, 0x69,
  0x1E, 0x22, 0xB9, 0xD5, 0xBF, 0xE1, 0x06, 0xD7, 0x25, 0xF3, 0xA1, 0xF2, 0xBC, 0xAF, 0xB2, 0x4C, 0xBB, 0x7E, 0xEF, 0x39, 0xD8, 0x7F, 0xBB, 0xE9, 0xDE, 0x9C, 0xB0, 0x75, 0xDD, 0x29, 0xC7, 0x97, 0x56, 0xAC, 0xB5, 0x5E, 0x47, 0xC9, 0x71, 0xAE,
  0x63, 0x86, 0xCC, 0xF2, 0xA9, 0x61, 0xF0, 0x92, 0xE6, 0x9D, 0xF6, 0xB3, 0x5D, 0x1F, 0x56, 0x92, 0x3D, 0x46, 0x8A, 0xE5, 0x3F, 0xE1, 0x20, 0xF1, 0x87, 0xFD, 0x13, 0x9D, 0x73, 0xFE, 0xFC, 0xCD, 0xFF, 0x00, 0xC6, 0xA8, 0xFF, 0x00, 0x84, 0x83,
  0xC6, 0x1F, 0xF4, 0x4E, 0x75, 0xCF, 0xFB, 0xF3, 0x37, 0xFF, 0x00, 0x1A, 0xAF, 0x0F, 0xFB, 0x1F, 0x1B, 0xFC, 0x9F, 0x8A, 0xFF, 0x00, 0x33, 0xF1, 0x0F, 0xEC, 0x1C, 0xC3, 0xFE, 0x7D, 0xFE, 0x31, 0xFF, 0x00, 0x33, 0xAB, 0xA2, 0xB9, 0x4F, 0xF8,
  0x48, 0x3C, 0x61, 0xFF, 0x00, 0x44, 0xE7, 0x5C, 0xFF, 0x00, 0xBF, 0x33, 0x7F, 0xF1, 0xAA, 0x3F, 0xE1, 0x20, 0xF1, 0x87, 0xFD, 0x13, 0x9D, 0x73, 0xFE, 0xFC, 0xCD, 0xFF, 0x00, 0xC6, 0xA8, 0xFE, 0xC7, 0xC6, 0xFF, 0x00, 0x27, 0xE2, 0xBF, 0xCC,
  0x3F, 0xB0, 0x73, 0x0F, 0xF9, 0xF7, 0xF8, 0xC7, 0xFC, 0xCE, 0xAE, 0x8A, 0xE5, 0x3F, 0xE1, 0x20, 0xF1, 0x87, 0xFD, 0x13, 0x9D, 0x73, 0xFE, 0xFC, 0xCD, 0xFF, 0x00, 0xC6, 0xA8, 0xFF, 0x00, 0x84, 0x83, 0xC6, 0x1F, 0xF4, 0x4E, 0x75, 0xCF, 0xFB,
  0xF3, 0x37, 0xFF, 0x00, 0x1A, 0xA3, 0xFB, 0x1F, 0x1B, 0xFC, 0x9F, 0x8A, 0xFF, 0x00, 0x30, 0xFE, 0xC1, 0xCC, 0x3F, 0xE7, 0xDF, 0xE3, 0x1F, 0xF3, 0x38, 0x3F, 0x0A,
  0xFF, 0x00, 0xC8, 0x2E, 0x5F, 0xFA, 0xEC, 0x7F, 0xF4, 0x15, 0xAD, 0xDA, 0xCB, 0xD2, 0xB4, 0x1F, 0x18, 0x69, 0x96, 0xAD, 0x0F, 0xFC, 0x21, 0x9A, 0xE4, 0xBB, 0x9C, 0xBE, 0x7E, 0xC5, 0x32, 0xF6, 0x03, 0xFB, 0x9E, 0xD5, 0x7B, 0xEC, 0x5E, 0x30,
  0xFF, 0x00, 0xA1, 0x1B, 0x5C, 0xFF, 0x00, 0xC0, 0x49, 0xBF, 0xF8, 0x8A, 0xFA, 0x1A, 0xF8, 0x5A, 0xB2, 0xA8, 0xE5, 0x15, 0xA7, 0xC8, 0xFE, 0x8C, 0xCA, 0xB3, 0xDC, 0xBE, 0x86, 0x0A,
  0x9D, 0x2A, 0x95, 0x2D, 0x24, 0xB5, 0xD2, 0x5F, 0xE4, 0x4D, 0x45, 0x43, 0xF6, 0x2F, 0x18, 0x7F, 0xD0, 0x8D, 0xAE, 0x7F, 0xE0, 0x24, 0xDF, 0xFC, 0x45, 0x1F, 0x62, 0xF1, 0x87, 0xFD, 0x08, 0xDA, 0xE7, 0xFE, 0x02, 0x4D, 0xFF, 0x00, 0xC4, 0x56,
  0x3F, 0x53, 0xAF, 0xFC, 0xBF, 0x8A, 0x3D, 0x0F, 0xF5, 0x93, 0x2B, 0xFF, 0x00, 0x9F, 0xBF, 0xF9, 0x2C, 0xBF, 0xC8, 0x9A, 0x8A, 0x87, 0xEC, 0x5E, 0x30, 0xFF, 0x00, 0xA1, 0x1B, 0x5C, 0xFF, 0x00, 0xC0, 0x49, 0xBF, 0xF8, 0x8A, 0x3E, 0xC5, 0xE3,
  0x0F, 0xFA, 0x11, 0xB5, 0xCF, 0xFC, 0x04, 0x9B, 0xFF, 0x00, 0x88, 0xA3, 0xEA, 0x75, 0xFF, 0x00, 0x97, 0xF1, 0x41, 0xFE, 0xB2, 0x65, 0x7F, 0xF3, 0xF7, 0xFF, 0x00, 0x25, 0x97, 0xF9, 0x14, 0xBC, 0x41, 0xFF, 0x00, 0x20, 0x3B, 0x9F, 0xF8, 0x0F,
  0xFE, 0x84, 0x2B, 0xEA, 0x6F, 0x02, 0x7F, 0xC9, 0x3C, 0xF0, 0xD7, 0xFD, 0x82, 0xAD, 0x7F, 0xF4, 0x52, 0xD7, 0xCB, 0x9A, 0x86, 0x8D, 0xE3, 0x0B, 0xFB, 0x19, 0x2D, 0xBF, 0xE1, 0x0A,
  0xD7, 0x13, 0x7E, 0x3E, 0x6F, 0xB1, 0x4C, 0x71, 0x82, 0x0F, 0x4D, 0x9E, 0xD5, 0xF5, 0x3F, 0x82, 0xE0, 0x9A, 0xD7, 0xC0, 0xBE, 0x1E, 0xB7, 0xB8, 0x8A, 0x48, 0x67, 0x8B, 0x4C, 0xB6, 0x49, 0x23, 0x91, 0x4A, 0xB2, 0x30, 0x89, 0x41, 0x04, 0x1E,
  0x41, 0x07, 0x8C, 0x57, 0xA5, 0x83, 0xA5, 0x2A, 0x74, 0xDA, 0x9A, 0xEA, 0x7C, 0x57, 0x11, 0xE3, 0xA8, 0x63, 0x31, 0x51, 0xA9, 0x87, 0x95, 0xD2, 0x8A, 0x5B, 0x35, 0xAD, 0xDF, 0x7B, 0x77, 0x37, 0x28, 0xA2, 0x8A, 0xEB, 0x3E, 0x7C, 0x28, 0xA2,
  0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2,
  0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0x28, 0xA2, 0x8A, 0x00, 0xFF, 0xD9,
  0x00
};

/**

channel selection : 
For example:

00 => channel 1 & 2 (STM 1)
01 => channel 3 & 4 (STM 2)
10 => channel 5, 6 & 7 (Exclusive Control)
11 => Common items, channel 3 & 4 (DC motor / coil Control)

*/
/*
		CH5_Coil_CC200mV_IN3IN4

*/
void CH5_Coil_CC200mV_IN3IN4()
{
    /*
    1. Channel  : Common items, channel 3 & 4 (DC motor / coil Control)
    2. Register : Input terminal setup
    3. Data     : bit9~8 => BF1 control
                  bit7~6 => PI3 VD terminal setting
                  bit5 => PI2 VD terminal setting 
                  bit4~0 => 3~6ch input terminal control setup
    */
    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3/IN4, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x6);
    /*
    1. Channel  : channel 5, 6 & 7 (Exclusive Control)
    2. Register : 5ch DC motor / coil control
    3. Data     : bit9~6 => Ch5 driving mode,   0000 => 1 line control@ CC IN/IN
												0001 => 1 line control@ CC EN/IN
												0010 => Serial control CC
												0011 => 2 line control CC IN/IN
												0100 => 2 line control CC EN/IN
												0101 => 3 line control CC
												0110 => 1 line control@ FS IN/IN
												0111 => 1 line control@ FS EN/IN
												1000 => Serial control FS
												1001 => 2 line control FS IN/IN
												1010 => 2 line control FS EN/IN
												1011 => 3 line control FS
												1100 => PWM_IN/IN control
												1101 => PWM_EN/IN control
												1110 => 3 line control CC 1-2 phase (5ch/6ch control)
												1111 => 3 line control FS 1-2 phase (5ch/6ch control)
                  bit4   => Ch5 Rotation direction, 0 => Forward
                                                    1 => Reverse
                  bit3   => Ch5 Disable operation mode, 0 => OFF (High impendace)
                                                        1 => Brake
                  bit2   => Ch5 Outout OFF mode, 0 => OFF (High impendace)
                                                 1 => Brake
                  bit1~0 => Ch5 Serial control, 00 => OFF
                                                10 => Reverse
                                                01 => Forward
                                                11 => Brake
    */
    /*
    0xC0 => b1100 0000
    
    5,6,7ch   
    5ch drive mode             : 2 line control CC IN/IN   why?
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0xc0);
    /*
    1. Channel  : channel 5, 6 & 7 (Exclusive Control)
    2. Register : 5ch DC motor / coil control
    3. Data     : bit9~6 => Ch5 constant current value, 0000->1111 => 310mV->160mV
                  bit4~3 => Ch5 Gain, set up the gain for constant current value, 00 => Gain 1 time
                                                                                  01 => Gain 1/2 time
                                                                                  10 => Gain 1/3 time
    */
    /*
    0x2c0 => b10 1100 0000
    5,6,7ch   
    5ch constant current:200mV   
    5ch Gain:x1
    */
    MotorCtrl_RegWrite( 2, 0x9, 0x2c0);
    
    /*
    1. Channel  : Common items, channel 3 & 4 (DC motor / coil Control)
    2. Register : PI Output control, PowerSave control
    3. Data     : bit9   => PS, Power safe mode ON/OFF setting for entire IC, 0 => Power safe ON
                                                                              1 => Power safe OFF
                  bit8   => PS12, Power safe mode ON/OFF setting for 1/2ch
                  bit7~6 => PS34, Power safe mode ON/OFF setting for 3/4ch
                  bit5   => PS5
                  bit4   => PS6
                  bit3~2 => PI3 control, Setup to change the control of PI3 driver, 00 PI driver OFF
																					01 PI driver ON
																					10 Assigned to BF1 output
																					11 Setting prohibited
                  bit1   => PI2
                  bit0   => PI1

    */
    /*
    0x220 => b10 0010 0000
    Common,3,4ch(DC motor/coil control)   
    PS  :OFF   
    PS12:ON   
    PS34:ON   
    PS5 :OFF   
    PS6 :ON   
    PI3 :PI driver OFF   
    PI2 :OFF   
    PI1 :OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x220);
    /*
    1. Channel  : channel 5, 6 & 7 (Exclusive Control)
    2. Register : 5ch/6ch (DC motor / coil control)
                  7ch (Exclusive control) operation control
    3. Data     : bit9~8 => 5ch/6ch/7ch Exclusive control, 00 => No exclusive control
														   01 => 5ch
														   10 => 6ch
														   11 => 7ch
                  bit7~5
                  bit4 => ch7 Enable operation, 0 => Disable operation
                                                1 => Enable operation
                  bit3 => ch6 Rotation direction, 0 => Forward
                                                  1 => Reverse
                  bit2 => ch6 Enable operation
                  bit1 => ch5 Rotation direction
                  bit0 => ch5 Enable operation

    */
    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Enable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x1);
}

/*
		CH5_Coil_CC200mV_Serial_F

*/
void CH5_Coil_CC200mV_Serial_F()
{
    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control     : Invalid   
    PI3 terminal VD : VD function Invalid   
    PI2 terminal VD : VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3/IN4, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x6);

    /*
    0x80 => b1000 0000
    5,6,7ch   
    5ch drive mode             : Serial control CC   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x80);

    /*
    5,6,7ch   
    5ch constant current:200mV   
    5ch Gain:x1
    */
    MotorCtrl_RegWrite( 2, 0x9, 0x2c0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : OFF   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x220);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Enable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x1);

    /*
    5,6,7ch   
    5ch drive mode             : Serial control CC   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : Forward
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x81);

    AHC_OS_Sleep(200);// why ?
    /*
    5,6,7ch   
    5ch drive mode             : Serial control CC   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x80);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : ON   
    PS12 : ON   
    PS34 : ON   
    PS5  : ON   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x0);
}

/*
		CH5_Coil_CC200mV_Serial_R

*/
void CH5_Coil_CC200mV_Serial_R()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3/IN4, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x6);

    /*
    5,6,7ch   
    5ch drive mode             : Serial control CC   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x80);

    //5,6,7ch   5ch constant current:200mV   5ch Gain:x1
    MotorCtrl_RegWrite( 2, 0x9, 0x2c0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : OFF   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x220);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Enable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x1);

    /*
    5,6,7ch   
    5ch drive mode             : Serial control CC   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : Reverse
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x82);

    AHC_OS_Sleep(200);
    /*
    5,6,7ch   
    5ch drive mode             : Serial control CC   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x80);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : ON   
    PS12 : ON   
    PS34 : ON   
    PS5  : ON   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x0);

}

/*
		CH5_Coil_FS_IN3IN4

*/
void CH5_Coil_FS_IN3IN4()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3/IN4, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x6);

    /*
    5,6,7ch   
    5ch drive mode             : 2 line control FS IN/IN   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x240);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : OFF   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x220);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Enable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x1);

}

/*
		CH5_DCM_PWM75_IN3_F

*/
void CH5_DCM_PWM75_IN3_F()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x15);

    /*
    5,6,7ch   
    5ch drive mode             : PWM control IN/IN   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : OFF(Hi-z)   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x300);
    /*
    1. Channel  : channel 5, 6 & 7 (Exclusive Control)
    2. Register : 5ch DC motor / coil control
    3. Data     : bit9~4 => ch5 PWM Drive DUTY Setting
                  bit0   => Carrier frequency
    */
    /*
    0x241 => b10 0100 0001
    5,6,7ch   
    5ch PWM drive mode Duty setting:74.988%   
    Carrier frequency              :D=48
    */
    MotorCtrl_RegWrite( 2, 0xa, 0x241);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : OFF   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x220);

}

/*
		CH5_DCM_PWM75_Serial_F

*/
void CH5_DCM_PWM75_Serial_F()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chF-, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x1d);

    /*
    5,6,7ch   
    5ch drive mode             : PWM control IN/IN   
    5ch Rotation direction     : Forward   
    5ch Disable operation mode : Brake   
    5ch Output OFF mode        : OFF(Hi-z)   
    5ch serial                 : OFF
    */
    MotorCtrl_RegWrite( 2, 0x8, 0x308);

    /*
    5,6,7ch   
    5ch PWM drive mode Duty setting:74.988%   
    Carrier frequency:D=48
    */
    MotorCtrl_RegWrite( 2, 0xa, 0x241);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : OFF   
    PS6  : ON   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x220);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Enable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x1);

    AHC_OS_Sleep(1000);
    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Disable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x0);

    AHC_OS_Sleep(1000);
}

/*
		CH6_Coil_CC200mV_IN5IN6

*/
void CH6_Coil_CC200mV_IN5IN6()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3/IN4, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x6);
    /*
    1. Channel  : channel 5, 6 & 7 (Exclusive Control)
    2. Register : 6ch DC motor / coil control
    3. Data     : bit9~6 => ch6 driving mode,   0000 => 1 line control CC IN/IN
												0001 => 1 line control CC EN/IN
												0010 => 2 line control CC IN/IN
												0011 => 2 line control CC EN/IN
												0100 => 3 line control CC
												0101 => 1 line control FS IN/IN
												0110 => 1 line control FS EN/IN
												0111 => 2 line control FS IN/IN
												1000 => 2 line control FS EN/IN
												1001 => 3 line control FS
												1010 => 3 line control CC 1-2 phase
												1011 => 3 line control FS 1-2 phase
    
                  bit4   => ch6 rotation direction
                  bit3   => ch6 Disable operation mode
                  bit2   => ch6 Output OFF mode

    */
    /*
    5,6,7ch   
    6ch drive mode             : 2 line control CC IN/IN   
    6ch Rotation direction     : Forward   
    6ch Disable operation mode : OFF(Hi-z)   
    6ch Output OFF mode        : OFF(Hi-z)
    */
    MotorCtrl_RegWrite( 2, 0xb, 0x80);
    /*
    1. Channel  : channel 5, 6 & 7 (Exclusive Control)
    2. Register : 6ch DC motor / coil control
    3. Data     : bit9~6 => ch6 constant current value
                  bit4~3 => ch6 gain

    */
    //5,6,7ch   6ch constant current:200mV   6ch Gain:x1
    MotorCtrl_RegWrite( 2, 0xc, 0x2c0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS          : OFF   
    PS12        : ON   
    PS34        : ON   
    PS5         : ON   
    PS6         : OFF   
    PI3 control : PI driver OFF   
    PI2         : OFF   
    PI1         : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x210);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Enable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x4);

}

/*
		CH6_Coil_CC200mV_IN6_F

*/
void CH6_Coil_CC200mV_IN6_F()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chF-, 6chFIN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x1c);

    /*
    5,6,7ch   
    6ch drive mode             : 1 line control CC IN/IN   
    6ch Rotation direction     : Forward   
    6ch Disable operation mode : OFF(Hi-z)   
    6ch Output OFF mode        : OFF(Hi-z)
    */
    MotorCtrl_RegWrite( 2, 0xb, 0x0);

    //5,6,7ch   6ch constant current:200mV   6ch Gain:x1
    MotorCtrl_RegWrite( 2, 0xc, 0x2c0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : ON   
    PS6  : OFF   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x210);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Enable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x4);

}

/*
		CH6_Coil_CC200mV_IN6_R

*/
void CH6_Coil_CC200mV_IN6_R()
{

    /*
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chF-, 6chFIN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x1c);

    /*
    5,6,7ch   
    6ch drive mode             : 1 line control CC IN/IN   
    6ch Rotation direction     : Forward   
    6ch Disable operation mode : OFF(Hi-z)   
    6ch Output OFF mode        : OFF(Hi-z)
    */
    MotorCtrl_RegWrite( 2, 0xb, 0x0);

    //5,6,7ch   6ch constant current:200mV   6ch Gain:x1
    MotorCtrl_RegWrite( 2, 0xc, 0x2c0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : ON   
    PS6  : OFF   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x210);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Reverse   
    6ch Enable operation          : Enable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0xc);

}

/*
		CH6_Coil_FS_IN5IN6

*/
void CH6_Coil_FS_IN5IN6()
{

    /*Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chFIN3/IN4, 6chFIN5/IN6
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x6);

    /*5,6,7ch   
    6ch drive mode             : 2 line control FS IN/IN   
    6ch Rotation direction     : Forward   
    6ch Disable operation mode : OFF(Hi-z)   
    6ch Output OFF mode        : OFF(Hi-z)
    */
    MotorCtrl_RegWrite( 2, 0xb, 0x1c0);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : ON   
    PS6  : OFF   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x210);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control : Without exclusive control   
    7ch Enable operation          : Disable operation   
    6ch Rotation direction        : Forward   
    6ch Enable operation          : Enable operation   
    5ch Rotation direction        : Forward   
    5ch Enable operation          : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x4);

}

/*
		CH6_Coil_FS_IN6_F

*/
void CH6_Coil_FS_IN6_F()
{

    /* 
    Common,3,4ch(DC motor/coil control)   
    BF1 Control:Invalid   
    PI3 terminal VD:VD function Invalid   
    PI2 terminal VD:VD function Invalid   
    3-6ch Control input terminal:3chF-, 4chF-, 5chF-, 6chFIN6 
    */
    MotorCtrl_RegWrite( 3, 0x1, 0x1c);

    /*
    5,6,7ch   
    6ch drive mode             : 1 line control FS IN/IN   
    6ch Rotation direction     : Forward   
    6ch Disable operation mode : OFF(Hi-z)   
    6ch Output OFF mode        : OFF(Hi-z)
    */
    MotorCtrl_RegWrite( 2, 0xb, 0x140);

    /*
    Common,3,4ch(DC motor/coil control)   
    PS   : OFF   
    PS12 : ON   
    PS34 : ON   
    PS5  : ON   
    PS6  : OFF   
    PI3 control:PI driver OFF   
    PI2  : OFF   
    PI1  : OFF
    */
    MotorCtrl_RegWrite( 3, 0x4, 0x210);

    /*
    5,6,7ch   
    5ch/6ch/7ch exclusive control:Without exclusive control   
    7ch Enable operation   : Disable operation   
    6ch Rotation direction : Forward   
    6ch Enable operation   : Enable operation   
    5ch Rotation direction : Forward   
    5ch Enable operation   : Disable operation
    */
    MotorCtrl_RegWrite( 2, 0xf, 0x4);

}


/*************************** End of file ****************************/

// Sample code for memory pool
//
//////////////////////////////////////////////////////////////////////


extern MMP_ERR DSC_FaceDetect(MMP_BOOL bEnable);
extern void SetRawPreviewMode(MMP_BOOL bForcedPreviewModeEn_in, MMP_UBYTE bForcedPreviewMode_in); // bForcedPreviewMode_in 0 for 2568x1932, 1 for 1292x967, 2 for 1928x1087, 3 for 644x481(30p), 4 for 644x482(120p)
extern int DSC_StartPreview( void );
extern int DSC_StopPreview(void);
extern int DramToFile( INT8* szFilename, INT8* pbyBuffer, UINT32 ulSize );

extern AHC_BOOL AHC_SwitchMediaPath(void);
extern AHC_BOOL AHC_FormatStorageMedia(UINT8 byMediaID);
extern MMP_ERR 	MMPS_AUDIO_SetPlayVolumeDb(MMP_BYTE ulInputDb);
extern MMP_ERR	MMPS_AUDIO_SetPlayAnalogGain(MMP_UBYTE ubAGain);
extern MMP_ERR	MMPS_AUDIO_SetPlayDigitalGain(MMP_UBYTE ubDGain);
extern MMP_ERR 	MMPF_SF_ReadData(MMP_ULONG ulSFAddr, MMP_ULONG ulDmaAddr, MMP_ULONG ulByteCount);
extern AHC_BOOL AHC_PARAM_Menu_Read(UINT8 *readback,AHC_VALUE_ACCESS_PATH accesspath);
extern MMP_ERR 	MMPS_USB_StopDevice(void);
extern MMP_ERR 	MMPS_3GPRECD_PauseRecord(void);
extern MMP_ERR 	MMPS_3GPRECD_ResumeRecord(void);
extern AHC_BOOL AHC_PARAM_Menu_WriteEx(char *filename);
extern int		VideoFunc_Record(void);
extern int 		sprintf(char * /*s*/, const char * /*format*/, ...);
extern MMP_ERR 	MMPS_Sensor_SetCaptureMode(MMP_UBYTE ubSnrSel, MMP_UBYTE ubCaptureMode);
extern AHC_BOOL AHC_IsCalibrationMode(void);
extern AHC_BOOL BrowserFunc_ModeSwitch(void);
extern AHC_BOOL PhotoPBFunc_Start(void);
extern void 	FuncMotorCtrl_ZoomCalibration(void);
#if !defined(CAR_DV)
extern MMP_BOOL ubStartPrintBattery;
extern MMP_BOOL ubLowBatteryTest;
#endif

/*******************************************************************************
 *
 *   UART COMMAND FUNCTIONS
 *
*******************************************************************************/
void UartCmdMode(char* szParam)
{
    int iMode;

    sscanfl( szParam, "%d",&iMode);    
    AHC_SetMode( AHC_MODE_IDLE );
    AHC_SetMode(iMode);
}

void UartCmdMount(char* szParam)
{
    int iMedia;

    sscanfl( szParam, "%d",&iMedia);    

    AHC_MountStorageMedia(iMedia);
}

void UartCmdESD(char* szParam)
{
#if (ESD_SW_PATCH)

    printc("ESD Simulation\r\n"); 
   
	MMPC_SD_PowerDownMedium();
#endif	
}


void UartCmdPrintVersion(char* szParam)
{
    AHC_PrintFwVersion();
    AHC_PrintBuildTime();
}

void UartCmdFormat(char* szParam)
{
    int iMedia;

    sscanfl( szParam, "%d",&iMedia);    

    AHC_FormatStorageMedia(iMedia);
}

void UartCmdTaskTable(char* szParam)
{
    AHC_PrintAllTask();
}

void UartCmdCheckTaskStack(char* szParam)
{
    AHC_CheckAllTaskStack();
}

void UartCmdReadyTable(char* szParam)
{
    AHC_DebugPrintReadyTable();
}

void UartCmdCurrentTask(char* szParam)
{
    AHC_PrintCurrentTask();
}

void  UartCmd_KeyDef(char* szParam)
{
    UINT32 ulKeyDef;

    sscanfl( szParam, "%d", &ulKeyDef);

    printc("key : %d \r\n", ulKeyDef);
    AHC_SendAHLMessage(AHLM_GPIO_BUTTON_NOTIFICATION, ulKeyDef, 0);
}

void UartOSDGetRGBDotClk( char* szParam )
{
    UINT32 ulDotClk=0;
    MMPS_Display_GetRGBDotClk(&ulDotClk);
    printc("RGB dot clock=%d kHz\r\n",ulDotClk);
}
void
UartOSDSetSemiTransparent( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    //int attr;
	UINT32 iVal[10];

	iCount = sscanfl( szParam, " %d %d %d %d", &id, &iVal[0], &iVal[1], &iVal[2]  );

//    iVal[0] = iEnable;
//    iVal[1] = iType;
//    iVal[2] = iTransParentWeight;

//      AHC_OSD_SEMITP_AVG
//      AHC_OSD_SEMITP_AND
//      AHC_OSD_SEMITP_OR 
//      AHC_OSD_SEMITP_INV

//  transparent weight 0~255

    printc( "AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE" );
    printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );

    bStatus = AHC_OSDSetDisplayAttr( id, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );

    printc( "status = %d\n", bStatus );
    
}


void
UartOSDSetTransparentEnable( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    //int attr;
	UINT32 iVal[10];

	iCount = sscanfl( szParam, "%d %d %x ", &id, &iVal[0], &iVal[1]  );
//    id
//    iVal[0] = iEnable;
//    iVal[1] = iColor;

    printc( "AHC_OSD_ATTR_TRANSPARENT_ENABLE" );
    printc( "DisplayID = %d, enable= %d, color = %X\n", id, iVal[0], iVal[1] );

    bStatus = AHC_OSDSetDisplayAttr( id, AHC_OSD_ATTR_TRANSPARENT_ENABLE, iVal );

    printc( "status = %d\n", bStatus );
        
}


void
UartOSDSetAlphaBlendingEnable( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
	UINT32 iVal[10];
	int i;

	iCount = sscanfl( szParam, "%d %d ", &id, &iVal[0]  );

    // iVal[0] = iEnable;

    iVal[1] = AHC_OSD_ALPHA_ARGB;
    // iVal[1] = AHC_OSD_ALPHA_RGBA;

    for(i=0;i<8;i++) 
    {
        iVal[2+i] = i * 256 / 8;
    }    

    printc( "AHC_OSD_ATTR_ALPHA_BLENDING_ENABLE" );
    printc( "DisplayID = %d, enable= %d, \n", id, iVal[0]);

    bStatus = AHC_OSDSetDisplayAttr( id, AHC_OSD_ATTR_ALPHA_BLENDING_ENABLE, iVal );

    printc( "status = %d\n", bStatus );
        
}

void
UartOSDSetRotate( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
	UINT32 iVal[10];
        
	iCount = sscanfl( szParam, "%d %d ", &id, &iVal[0]  );
	
    printc( "AHC_OSD_ATTR_ROTATE" );
    printc( "DisplayID = %d, op= %d, \n", id, iVal[0]);
	
    bStatus = AHC_OSDSetDisplayAttr( id, AHC_OSD_ATTR_ROTATE, iVal );	

    printc( "status = %d\n", bStatus );
}

void
UartOSDSetMirror( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
	UINT32 iVal[10];

	iCount = sscanfl( szParam, "%d %d ", &id, &iVal[0]  );
	
    printc( "AHC_OSD_ATTR_MIRROR" );
    printc( "DisplayID = %d, op= %d, \n", id, iVal[0]);
	
    bStatus = AHC_OSDSetDisplayAttr( id, AHC_OSD_ATTR_MIRROR, iVal );
    
    printc( "status = %d\n", bStatus );
    
}

void
UartOSDInit( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int iWidth;
    int iHeight;
    int iColorFormat;

    // OSD_COLOR_ARGB32
    
	iCount = sscanfl( szParam, "%d %d %d", &iWidth, &iHeight, &iColorFormat  );

    printc( "AHC_OSDInit( %d,%d,%d,);\n", iWidth,iHeight, iColorFormat );

    bStatus = AHC_OSDInit(	iWidth,
    						iHeight,
							iWidth,
    						iHeight,
       						PRIMARY_DATESTAMP_WIDTH,
    						PRIMARY_DATESTAMP_HEIGHT,
    						THUMB_DATESTAMP_WIDTH,
    						THUMB_DATESTAMP_HEIGHT,
    						iColorFormat,AHC_TRUE);

    printc( "status = %d\n", bStatus );
}

void
UartOSDUninit( char* szParam )
{
    AHC_BOOL bStatus;
    printc( "AHC_OSDUninit();\n");

    bStatus = AHC_OSDUninit();

    printc( "status = %d\n", bStatus );
}


void
UartOSDCreateBuffer( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int iWidth;
    int iHeight;
    int iColorFormat;
    int id;

    // OSD_COLOR_ARGB32
    
	iCount = sscanfl( szParam, "%d %d %d %d",&id, &iWidth, &iHeight, &iColorFormat  );

    printc( "AHC_OSDCreateBuffer( %d, %d,%d,%d );\n", id, iWidth,iHeight, iColorFormat );

    bStatus = AHC_OSDCreateBuffer(id, iWidth,iHeight,iColorFormat);

    printc( "status = %d\n", bStatus );
}


void
UartOSDSetCurrentDisplay( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;

	iCount = sscanfl( szParam, "%d ",&id  );

    printc( "AHC_OSDSetCurrentDisplay( %d );\n", id );

    bStatus = AHC_OSDSetCurrentDisplay(id);

    printc( "status = %d\n", bStatus );
    
}


void
UartOSDGetCurrentDisplay( char* szParam )
{
    AHC_BOOL bStatus;
    printc( "status = %d\n", bStatus );  
}



void
UartOSDRefresh( char* szParam )
{
    AHC_BOOL bStatus;

    printc( "AHC_OSDRefresh();\n");

    bStatus = AHC_OSDRefresh();

    printc( "status = %d\n", bStatus );
    
}

extern AHC_OSD_INSTANCE 		*m_OSD[];

void
UartOSDGetDisplayAttr( char* szParam )
{
#if 0
	int iCount;
	int id;
	
	iCount = sscanfl( szParam, "%d", &id );

	printc( "m_OSD[%d]->id: %d;\n", id, m_OSD[id]->id);
	printc( "m_OSD[%d]->Color: %d;\n", id, m_OSD[id]->Color);
	printc( "m_OSD[%d]->TransparentColor: %d;\n", id, m_OSD[id]->TransparentColor);
    printc( "m_OSD[%d]->TransparentEnable: %d;\n", id, m_OSD[id]->TransparentEnable);
    printc( "m_OSD[%d]->ColorFormat: %d;\n", id, m_OSD[id]->ColorFormat);
	printc( "m_OSD[%d]->width: %d;\n", id, m_OSD[id]->width); 
	printc( "m_OSD[%d]->AlphaBlendingEnable: %d;\n", id, m_OSD[id]->AlphaBlendingEnable); 
	printc( "m_OSD[%d]->AlphaFormat: %d;\n", id, m_OSD[id]->AlphaFormat);    
#endif
}


void
UartOSDSetSetActive( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int enable;
    int id;

	iCount = sscanfl( szParam, "%d %d",&id, &enable  );

    printc( "AHC_OSDSetActive(%d, %d);\n", id, enable );

    bStatus = AHC_OSDSetActive(id,enable);

    printc( "status = %d\n", bStatus );
    
}

void
UartOSDSetClearBuffer( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    //int enable;
    int id;

	iCount = sscanfl( szParam, "%d",&id );

    printc( "AHC_OSDClearBuffer(%d );\n", id);

    bStatus = AHC_OSDClearBuffer(id);

    printc( "status = %d\n", bStatus );
    
}


void
UartOSDDestroyBuffer( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    //int enable;
    int id;

	iCount = sscanfl( szParam, "%d",&id );

    printc( "AHC_OSDDestroyBuffer(%d );\n", id);

    bStatus = AHC_OSDDestroyBuffer(id);

    printc( "status = %d\n", bStatus );
    
}


void
UartOSDSetColor( char* szParam )
{
    //AHC_BOOL bStatus;
    int iCount;
    int iColor;

    // OSD_COLOR_ARGB32
    
	iCount = sscanfl( szParam, "%x ",&iColor  );

    printc( "AHC_OSDSetColor( 0x%x );\n", iColor );

	#ifdef ENABLE_GUI_SUPPORT_MULTITASK
    AHC_OSDSetColor(0, iColor);
	#else
    AHC_OSDSetColor(iColor);
	#endif    
}

void
UartOSDDrawPixel( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    int x,y;
    
	iCount = sscanfl( szParam, "%d %d %d",&id, &x, &y  );

    printc( "AHC_OSDDrawPixel(%d, %d, %d);\n", id, x, y );

    bStatus = AHC_OSDDrawPixel(id,x,y);

    printc( "status = %d\n", bStatus );
    
}

void
UartOSDDrawRect( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    int x1,y1;
    int x2,y2;
        
	iCount = sscanfl( szParam, "%d %d %d %d %d",&id, &x1, &y1,&x2, &y2 );

    printc( "AHC_OSDDrawRect(%d, %d, %d, %d, %d);\n", id, x1,y1,x2,y2);

    bStatus = AHC_OSDDrawRect(id,x1,y1,x2,y2);

    printc( "status = %d\n", bStatus );
    
}

void
UartOSDDrawFillRoundedRect( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    int x1,y1;
    int x2,y2;
    int radius;
	iCount = sscanfl( szParam, "%d %d %d %d %d %d",&id, &x1, &y1,&x2, &y2, &radius );

    printc( "AHC_OSDDrawRect(%d, %d, %d, %d, %d, %d);\n", id, x1,y1,x2,y2,radius );

    bStatus = AHC_OSDDrawFillRoundedRect(id,x1,y1,x2,y2,radius);

    printc( "status = %d\n", bStatus );
    
}

void
UartOSDDrawFillRect( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    int x1,y1;
    int x2,y2;
        
	iCount = sscanfl( szParam, "%d %d %d %d %d",&id, &x1, &y1,&x2, &y2 );

    printc( "AHC_OSDDrawFillRect(%d, %d, %d, %d, %d);\n", id, x1,y1,x2,y2);

    bStatus = AHC_OSDDrawFillRect(id,x1,y1,x2,y2);

    printc( "status = %d\n", bStatus );
    
}



void
UartOSDDrawInvertRect( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    int id;
    int x1,y1;
    int x2,y2;
        
	iCount = sscanfl( szParam, "%d %d %d %d %d",&id, &x1, &y1,&x2, &y2 );

    printc( "AHC_OSDDrawInvertRect(%d, %d, %d, %d, %d);\n", id, x1,y1,x2,y2);

    bStatus = AHC_OSDDrawInvertRect(id,x1,y1,x2,y2);

    printc( "status = %d\n", bStatus );
    
}



void
UartOSDDrawText( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    char str[64]={0};
    int x,y,id;
        
	iCount = sscanfl( szParam, "%d %d %d %s",&id, &x, &y,&str );

	#ifdef ENABLE_GUI_SUPPORT_MULTITASK
    AHC_OSDSetFont(id, &GUI_Font16_ASCII);
	#else
    AHC_OSDSetFont(&GUI_Font16_ASCII);
	#endif
	
    printc( "AHC_OSDDrawText(%d, %d, %d, %s, %d);\n", id, x,y, str, strlen(str) );

    bStatus = AHC_OSDDrawText(id,(UINT8*)str,x,y, strlen(str));

    printc( "status = %d\n", bStatus );
    
}


void
UartOSDDrawJpeg( char* szParam )
{
    AHC_BOOL bStatus;
    int iCount;
    //int data;
    //int size;
    int x,y,id;
        
//	iCount = sscanfl( szParam, "%d %X %d",&id, &data, &size, &x, &y );
	iCount = sscanfl( szParam, "%d %d %d",&id, &x, &y );

    printc( "AHC_OSDDrawJpeg(%d, %X, %d, %d, %d);\n", id, acbayer_pattern, sizeof(acbayer_pattern), x, y );

    bStatus = AHC_OSDDrawJpegScale(id,(void*)acbayer_pattern,sizeof(acbayer_pattern),x,y,1,2);

    printc( "status = %d\n", bStatus );
    
}

MMP_ERR MMPF_FS_Format(const MMP_BYTE *pDevice);

void
UartFormatSD( char* szParam )
{
	
//	MMPF_FS_Format( FS_1ST_DEV );
	MMPF_FS_Format( "SD:0:" );
   
}


void
UartDummy( char* szParam )
{

   int Var1;
   int Var2;
   char szFilename[100];
   
   sscanfl( szParam, " %d %x %s ", &Var1, &Var2,szFilename );
   
   UartExecuteCommandEx( "osdinit 360 320 3"); 

   printc( "%d %d [%s]\n", Var1, Var2, szFilename );
  

}

MMP_ULONG MMPF_OsCounterGetFreqKhz(void);
MMP_ULONG MMPF_OsCounterGetFreqHz(void);

void
UartCounterGet( char* szParam )
{

    MMP_ULONG  ulCounter;
  
    ulCounter =  MMPF_OsCounterGet() /MMPF_OsCounterGetFreqKhz();
    
    printc( "ulCounter = %d\n", ulCounter );

}

void
UartCounterInit( char* szParam )
{

    MMP_ULONG  ulCounter;

    // TIMER_CLOCK_SELECT_MCLK_DIV_32    
    MMPF_OsCounterInit(2, MMP_TRUE ); 
  
    ulCounter =  MMPF_OsCounterGet() /MMPF_OsCounterGetFreqKhz();
    
    printc( "ulCounter = %d\n", ulCounter );

}

#if (SUPPORT_TIMING_MARK == 1)
void
UartTimingMarkInit( char* szParam )
{   
	MMPF_TimingInit(5000);
	MMPF_TimingStart(0x08); //Mark TBD TIMING_GROUP_MOTOR
 
}

int iTiming = 0;

void
UartTimingMark( char* szParam )
{    
	MMPF_TimingMarkF( 0x01, "[TEST] %d ", iTiming); //Mark TBD TIMING_GROUP_BOOT
	iTiming++;	
}

void
UartTimingMarkDump( char* szParam )
{

	MMPF_TimingStop();

	MMPF_TimingDump(0);
	
	iTiming++;
}
#endif
//------------------------------------------------------------------------------
//  Function    : DrawPointOnImage
//  Description : for ADAS dubug use
//------------------------------------------------------------------------------
void DrawPointOnImage(MMP_USHORT usPointX, MMP_USHORT usPointY, MMP_USHORT usWidth, MMP_USHORT usHeight, MMP_ULONG uiBaseAddr)
{
    #define PIXELNUMPERPOINT (1)
    #define PIXELVALUE       (0)
    MMP_ULONG  uiDrawBufferAddr;
    MMP_ULONG  i, j;
    for(i = 0;i < PIXELNUMPERPOINT*4; i++)
    {
        for(j = 0;j < PIXELNUMPERPOINT; j++)
        {
            uiDrawBufferAddr = uiBaseAddr + ((usPointY + i) * usWidth) + (usPointX + j);
            *(volatile MMP_ULONG*)(uiDrawBufferAddr) = PIXELVALUE;
        }
    }
}
//------------------------------------------------------------------------------
//  Function    : DrawlineOnImage
//  Description : for ADAS dubug use
//------------------------------------------------------------------------------
void DrawlineOnImage(MMP_USHORT usPointY, MMP_USHORT usWidth, MMP_ULONG uiBaseAddr)
{
    #define PIXELNUMPERLINE  (2)
    #define LINEVALUE        (255)
    MMP_ULONG  uiDrawBufferAddr;
    MMP_ULONG  i;
    for(i = 0;i < PIXELNUMPERLINE; i++)
    {
            uiDrawBufferAddr = uiBaseAddr + ((usPointY + i) * usWidth);
            MEMSET((MMP_ULONG*)uiDrawBufferAddr, LINEVALUE, usWidth);
    }
}

//------------------------------------------------------------------------------
//  Function    : Uartcmd_DumpADASPara
//  Description : dump ADAS parameters and save ADAS image to SD card
//------------------------------------------------------------------------------
void Uartcmd_DumpADASPara( char* szParam )
{
#if (SUPPORT_ADAS)
    ADAS_init_params ADASInitParas;
    MMP_ULONG        ulDramAddr, ulSramAddr;
    char*            fileName = "SD:\\ADAS_Image.yuv";
    MMP_SCAL_FIT_RANGE 		sFitRangeBayer;
	MMP_SCAL_GRAB_CTRL		sGrabctlBayer;
    MMP_ULONG               uiOffsetX = 0, uiOffsetY = 0;               //offset of OSD start and preview start(in OSD)
    MMP_ULONG               uiOSD_W   = 0, uiOSD_H   = 0;               //OSD_W buffer width calculate by DUPLICATE 
    MMP_ULONG               uiPreview_width = 0, uiPreview_height = 0;  //Preview_width in OSD buffer calculate by DUPLICATE 
    MMP_USHORT              usPreviewMode;
    MMPS_3GPRECD_CONFIGS    *pVideoConfig = MMPS_3GPRECD_GetConfig(); 
    MMP_BOOL                bAdasCmd;
    MMP_UBYTE               ubSnrSel = 0;
    MMPF_SENSOR_RESOLUTION  *pResTable = gsSensorFunction->MMPF_Sensor_GetResTable(ubSnrSel);
    MMP_USHORT              usCurPreviewMode = 0;
    extern MMPD_FCTL_ATTR     m_ADASFctlAttr;
    extern MMP_SCAL_FIT_RANGE gsADASFitRange;
    extern MMP_SCAL_GRAB_CTRL gsADASGrabctl;
    extern fcws_tuning_params OSDfcwsTuningParms;
    extern fcws_tuning_params ADASfcwsTuningParms;
    sscanfl( szParam, "%d",&bAdasCmd);
    if(bAdasCmd == MMP_TRUE){
        printc("Set ADAS Output Log on\r\n");
        ADAS_CTL_SetADASOutputLog(MMP_TRUE);
    }
    else if(bAdasCmd == MMP_FALSE){
        printc("Set ADAS Output Log off\r\n");
        ADAS_CTL_SetADASOutputLog(MMP_FALSE);
    }
    else{
        printc("Invalid command, please input 1/0 to turn on/off ADAS Output Log!\r\n");
    }
    if(ADAS_CTL_GetAdasInitParam(&ADASInitParas) != MMP_ERR_NONE){
        printc("GetAdasInitParam failed!!\r\n");
    }else{
        MMP_UBYTE ubPosi;
        //dump paramters
        printc("\r\n=============ADAS Current Init Parameters=============\r\n");
        
        printc("====Basic Setup Parameters====\r\n");
        printc("Camera_focal          : %f mm\r\n",(float)ADASInitParas.ADAS_input_params.camera_focal/100);
        printc("Sensor_cell_width     : %f um\r\n",(float)ADASInitParas.ADAS_input_params.sensor_cell_width/100);
        printc("Camera_height         : %d cm\r\n",ADASInitParas.user_calib_camera_height);
        ubPosi = ADASInitParas.LDWS_input_params.LDWS_pos - 0x84;
        if(ubPosi == LDWS_SETUP_CENTER){
            printc("LdwsSetupPosi         : LDWS_SETUP_CENTER\r\n");
        }else if(ubPosi == LDWS_SETUP_LEFT){
            printc("LdwsSetupPosi         : LDWS_SETUP_LEFT\r\n");
        }else if(ubPosi == LDWS_SETUP_RIGHT){
            printc("LdwsSetupPosi         : LDWS_SETUP_RIGHT\r\n");
        }
        printc("====Preview Parameters and Scale Ratio====\r\n");
        printc("Image_width           : %d\r\n",ADASInitParas.ADAS_input_params.image_width);
        printc("Image_height          : %d\r\n",ADASInitParas.ADAS_input_params.image_height);
        printc("dz_N                  : %d\r\n",ADASInitParas.ADAS_input_params.dz_N);
        printc("dz_M                  : %d\r\n",ADASInitParas.ADAS_input_params.dz_M);
        
        printc("====Triangle point Parameters====\r\n");
        printc("CalibrationImageWidth : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth);
        printc("CalibrationImageHeight: %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageHeight);
        printc("CalibrationUpPointX   : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationUpPointX);
        printc("CalibrationUpPointY   : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationUpPointY);
        printc("CalibrationLeftPointX : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationLeftPointX);
        printc("CalibrationLeftPointY : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationLeftPointY);
        printc("CalibrationRightPointX: %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationRightPointX);
        printc("CalibrationRightPointY: %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationRightPointY);
        printc("DepartureHighThr1     : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.departureHighThr1);
        printc("DepartureHighThr2     : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.departureHighThr2);
        printc("DepartureLowThr1      : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.departureLowThr1);
        printc("DepartureLowThr2      : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.departureLowThr2);
        printc("DepartureMiddleThr1   : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.departureMiddleThr1);
        printc("DepartureMiddleThr2   : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.departureMiddleThr2);
        printc("AlarmShowCnt          : %d\r\n",ADASInitParas.LDWS_input_params.LDWS_params.alarmShowCnt);

        printc("====Calib Start/End Y Parameters====\r\n");
        printc("Calib_y_start: %d\r\n",ADASInitParas.user_calib_y_start);
        printc("Calib_y_end: %d\r\n",ADASInitParas.user_calib_y_end);
        printc("====ADAS YN/YM Reference Parameters ====\r\n");
        printc("====ADASFitRange Paramters====\r\n");
        printc("gsADASFitRange.fitmode    : %d\r\n",gsADASFitRange.fitmode);
        printc("gsADASFitRange.scalerType : %d\r\n",gsADASFitRange.scalerType);
        printc("gsADASFitRange.ulInWidth  : %d\r\n",gsADASFitRange.ulInWidth);
        printc("gsADASFitRange.ulInHeight : %d\r\n",gsADASFitRange.ulInHeight);
        printc("gsADASFitRange.ulOutWidth : %d\r\n",gsADASFitRange.ulOutWidth);
        printc("gsADASFitRange.ulOutHeight: %d\r\n",gsADASFitRange.ulOutHeight);
        printc("gsADASFitRange.ulInGrabW  : %d\r\n",gsADASFitRange.ulInGrabW);
        printc("gsADASFitRange.ulInGrabH  : %d\r\n",gsADASFitRange.ulInGrabH);
        printc("gsADASFitRange.ulInGrabX  : %d\r\n",gsADASFitRange.ulInGrabX);
        printc("gsADASFitRange.ulInGrabY  : %d\r\n",gsADASFitRange.ulInGrabY);
        printc("gsADASGrabctl.ulScaleYN   : %d\r\n",gsADASGrabctl.ulScaleYN);
        printc("gsADASGrabctl.ulScaleYM   : %d\r\n",gsADASGrabctl.ulScaleYM);
        MMPD_BayerScaler_GetZoomInfo(MMP_BAYER_SCAL_DOWN, &sFitRangeBayer, &sGrabctlBayer);
        printc("sGrabctlBayer.ulScaleYN   : %d\r\n",sGrabctlBayer.ulScaleYN);
        printc("sGrabctlBayer.ulScaleYM   : %d\r\n",sGrabctlBayer.ulScaleYM);
        MMPF_Sensor_GetParam(ubSnrSel, MMPF_SENSOR_CURRENT_PREVIEW_MODE, &usCurPreviewMode);
        printc("pResTable->ubHBinningN[usCurPreviewMode] : %d\r\n",pResTable->ubHBinningN[usCurPreviewMode]);
        printc("pResTable->ubHBinningM[usCurPreviewMode] : %d\r\n",pResTable->ubHBinningM[usCurPreviewMode]);
        uiOSD_W = STRETCH_W(ORIGINAL_OSD_W); 
        uiOSD_H = STRETCH_H(ORIGINAL_OSD_H);
        if(usPreviewMode == VIDRECD_FULL_PREVIEW_MODE || usPreviewMode == VIDRECD_NORMAL_PREVIEW_MODE)
        {
        #ifdef VERTICAL_PANEL  //TBD, this conversion should be set by MMPC_3gpRecd_InitConfig in ait_config.c
        uiPreview_width  = pVideoConfig->previewdata->usVidPreviewBufH[VIDRECD_FULL_PREVIEW_MODE];
        uiPreview_height = pVideoConfig->previewdata->usVidPreviewBufW[VIDRECD_FULL_PREVIEW_MODE];
        #else
        uiPreview_width  = pVideoConfig->previewdata->usVidPreviewBufW[VIDRECD_FULL_PREVIEW_MODE];
        uiPreview_height = pVideoConfig->previewdata->usVidPreviewBufH[VIDRECD_FULL_PREVIEW_MODE];    
        #endif
        }
        else
        {
            uiPreview_width  = pVideoConfig->previewdata->usVidPreviewBufW[usPreviewMode];
            uiPreview_height = pVideoConfig->previewdata->usVidPreviewBufH[usPreviewMode]; 
        }
        if(OSD_DISPLAY_SCALE_LCD)
	    {
	        uiPreview_width  = uiPreview_width  / OSD_DISPLAY_SCALE_LCD;
	        uiPreview_height = uiPreview_height / OSD_DISPLAY_SCALE_LCD;
	    }
        if(uiOSD_W > uiPreview_width)
        {
            uiOffsetX = (uiOSD_W - uiPreview_width) / 2;
        }
        if(uiOSD_H > uiPreview_height)
        {
            uiOffsetY = (uiOSD_H - uiPreview_height) / 2;
        } 
		#if (MENU_GENERAL_LDWS_CALIBRATION_EN)
        printc("====Calibration Coversion Parameters ====\r\n");
        printc("OSDfcwsTuningParms.CalibrationStarY  : %d\r\n",OSDfcwsTuningParms.CalibrationStarY);
        printc("OSDfcwsTuningParms.CalibrationEndY   : %d\r\n",OSDfcwsTuningParms.CalibrationEndY);
        printc("uiOSD_W                              : %d\r\n",uiOSD_W);
        printc("uiOSD_H                              : %d\r\n",uiOSD_H);
        printc("uiPreview_width                      : %d\r\n",uiPreview_width);
        printc("uiPreview_height                     : %d\r\n",uiPreview_height);
        printc("uiOffsetX                            : %d\r\n",uiOffsetX);
        printc("uiOffsetY                            : %d\r\n",uiOffsetY);
        printc("ADASfcwsTuningParms.CalibrationStarY : %d\r\n",ADASfcwsTuningParms.CalibrationStarY);
        printc("ADASfcwsTuningParms.CalibrationEndY  : %d\r\n",ADASfcwsTuningParms.CalibrationEndY);
        printc("ADASfcwsTuningParms.cardv_height_pos : %d cm\r\n",ADASfcwsTuningParms.cardv_height_pos);
        printc("=============  End of dump parameters    =============\r\n");
		#endif
        //save ADAS image to SD card
        printc("Draw Start/End Line and Triangle Points on ADAS Image and Save to SD card\r\n");
        printc("Please check %s\r\n",fileName);
        //Steal StillCapture Buffer to save ADAS Image
        MMPS_3GPRECD_GetStillCaptureAddr(&ulSramAddr, &ulDramAddr);
        MEMCPY((MMP_ULONG*)ulDramAddr,
               (MMP_ULONG*)(m_ADASFctlAttr.ulBaseAddr[0]),
               ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth*
               ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageHeight);
        //DrawLine
        DrawlineOnImage(ADASInitParas.user_calib_y_start,
                        ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth,
                        ulDramAddr);
        DrawlineOnImage(ADASInitParas.user_calib_y_end,
                        ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth,
                        ulDramAddr);
        //DrawPointInImage
        DrawPointOnImage(ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationUpPointX, 
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationUpPointY, 
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth,
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageHeight,
                         ulDramAddr);
        DrawPointOnImage(ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationLeftPointX, 
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationLeftPointY, 
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth,
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageHeight,
                         ulDramAddr);
        DrawPointOnImage(ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationRightPointX, 
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationRightPointY, 
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageWidth,
                         ADASInitParas.LDWS_input_params.LDWS_params.laneCalibrationImageHeight,
                         ulDramAddr);
        //
        //DramToFile
        DramToFile((INT8*)fileName, (INT8*)ulDramAddr, (UINT32)ADASInitParas.ADAS_input_params.image_width*ADASInitParas.ADAS_input_params.image_height);	
    }
#else
    printc("Not supporting ADAS\r\n");
#endif
}

//------------------------------------------------------------------------------
//  Function    : Uartcmd_DumpADASPara
//  Description : dump ADAS parameters and save ADAS image to SD card
//------------------------------------------------------------------------------
void UartCmd_MIMF_OutputResult(char* szParam)
{
    UINT32  uiFileID;
    AHC_ERR err;    
    char* fileName = "SD:\\outputmimf.txt";
    err = AHC_FS_FileOpen((INT8 *)fileName, AHC_StrLen(fileName), "wb", AHC_StrLen("wb"), &uiFileID);
    
    if (err != MMP_ERR_NONE){
        printc("ERR:file open fails...\r\n");
    }
    else{
        printc("File open : %s\r\n", fileName);                 
    }
    
    if(err == AHC_ERR_NONE)
    {
        UINT32   uiWriteCount;
        UINT32   uiFileTotalCount;
        UINT32   uiTotalByte;
        UINT32   i;
        UINT32   uiDcfIndex;
        UINT32   sDB;
        AHC_BOOL bIsRearCam;
        INT8     FilePathName[MAX_FILE_NAME_SIZE];
        INT8 	 WriteData[256] = {0};
        
        AHC_UF_GetTotalFileCount(&uiFileTotalCount);
        for(i = 0; i < uiFileTotalCount; i++)
        {
            MEMSET(&WriteData,  0, sizeof(WriteData));
            AHC_MIMF_IndexReverseMapping(i, &uiDcfIndex, &sDB, &bIsRearCam);
            AHC_UF_GetFilePathNamebyIndex(i, FilePathName);
            uiTotalByte += sprintf(WriteData, "\r\nUF Index : %d === DB : %d DCF Index : %d IsRearCam : %d FullPathName : %s",
                                   i, sDB, uiDcfIndex, bIsRearCam, FilePathName);
            AHC_FS_FileWrite(uiFileID, (UINT8*)&WriteData, uiTotalByte, &uiWriteCount);
            uiTotalByte = 0;
        }
        AHC_FS_FileClose(uiFileID);
    }
}

void UartCmd_GetRaw(char* szParam)
{
    MMP_UBYTE bySensorIndex = 0;
	MMP_ULONG uiAddress;
    MMP_UBYTE uiValue;
    MMP_UBYTE uiValue1;
    MMP_USHORT W,H;
    char* fileName = "SD:\\ait.raw";

    sscanfl( szParam, "%d", &bySensorIndex );

    if( bySensorIndex == 0 )
    {
    	uiAddress = 0x80006022;
    	uiValue = 0x00;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x800060B0;
    	uiValue = 0x01;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x80006B17;
    	uiValue = 03;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x80006B19;
    	uiValue = 0x00;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x80006B10;
    	uiValue = 0x0A;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;    
        uiAddress = 0x80006022;
    	uiValue = 0x01;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        
        AHC_OS_SleepMs(500);
        
        uiAddress = 0x80006022;
    	uiValue = 0x00;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        
        uiAddress = 0x80006093;
    	uiValue1 = *(MMP_UBYTE*)uiAddress;
    	uiAddress = 0x80006092;
    	uiValue = *(MMP_UBYTE*)uiAddress;
    	W= ((MMP_USHORT)uiValue1 << 8) | uiValue; 
       
        uiAddress = 0x80006097;
    	uiValue1 = *(MMP_UBYTE*)uiAddress;
    	uiAddress = 0x80006096;
    	uiValue = *(MMP_UBYTE*)uiAddress;
    	H= ((MMP_USHORT)uiValue1 << 8) | uiValue; 
    }
    else
    {
    	uiAddress = 0x80006023;
    	uiValue = 0x00;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x800060B1;
    	uiValue = 0x01;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x80006B17;
    	uiValue = 03;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x80006B19;
    	uiValue = 0x01;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        uiAddress = 0x80006B10;
    	uiValue = 0x0A;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;    
        uiAddress = 0x80006023;
    	uiValue = 0x01;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        
        AHC_OS_SleepMs(500);
        
        uiAddress = 0x80006023;
    	uiValue = 0x00;
        *(volatile MMP_UBYTE*)(uiAddress) = uiValue;
        
        uiAddress = 0x8000609B;
    	uiValue1 = *(MMP_UBYTE*)uiAddress;
    	uiAddress = 0x8000609A;
    	uiValue = *(MMP_UBYTE*)uiAddress;
    	W= ((MMP_USHORT)uiValue1 << 8) | uiValue; 
       
        uiAddress = 0x8000609F;
    	uiValue1 = *(MMP_UBYTE*)uiAddress;
    	uiAddress = 0x8000609E;
    	uiValue = *(MMP_UBYTE*)uiAddress;
    	H= ((MMP_USHORT)uiValue1 << 8) | uiValue; 
    }
   
    printc("UartCmd_GetRaw.....\r\n");
    printc("W = %d\r\n", W);
    printc("H = %d\r\n", H);

	DramToFile((INT8*)fileName, (INT8*)0x3000000, (UINT32)W*H);	
	
	printc("UartCmd_GetRaw: Done!!\r\n");
}

void UartCmd_AE_Enable(char* szParam)
{
#if 0
    int enable;

	ISP_IF_VERSION ver = ISP_IF_AE_GetVer();
	
    sscanfl( szParam, "%d ",&enable);

	if( enable )
	{
		ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AE, 1 );
		printc( "AE (%s) Enable \n", ver.ID);
	}
	else
	{
		ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AE, 0 );
		printc( "AE (%s) Disable \n", ver.ID);
	}
#endif	
}

void UartCmd_AE_Get_Wnd_Size(char* szParam)
{
#if 0
	ISP_UINT32 w,h;

	w = ISP_IF_AE_GetWndWidth();
	h = ISP_IF_AE_GetWndHeight();

	printc( "AE Window Size = %d x %d (unit)\n", w, h);
#endif	
}

void UartCmd_AF_ZTModeEnable(char* szParam)
{
#if 0
    int enable;

    sscanfl( szParam, "%d ",&enable);

	if( enable )
	{
		//ISP_IF_AF_SetZoomTracking(ISP_AF_ZTRACK_ENB); //Rogers:***
		printc( "AF ZT Enable \n");
	}
	else
	{
		//ISP_IF_AF_SetZoomTracking(ISP_AF_ZTRACK_DSB); //Rogers:***
		printc( "AF ZT DISABLE \n");
	}
#endif
}

void UartCmd_AF_Enable(char* szParam)
{
#if 0
    int enable;

	ISP_IF_VERSION ver = ISP_IF_AF_GetVer();
	
    sscanfl( szParam, "%d ",&enable);

	if( enable )
	{
		ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AF, 1 );
		printc( "AF (%s) Enable \n", ver.ID);
	}
	else
	{
		ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AF, 0 );
		printc( "AF (%s) Disable \n", ver.ID);
	}
#endif	
}

void UartCmd_AWB_Enable(char* szParam)
{
#if 0
    int enable;

	ISP_IF_VERSION ver = ISP_IF_AWB_GetVer();
	
    sscanfl( szParam, "%d ",&enable);

	if( enable )
	{
		ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AWB, 1 );
		printc( "AWB (%s) Enable \n", ver.ID);
	}
	else
	{
		ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AWB, 0 );
		printc( "AWB (%s) Disable \n", ver.ID);
	}
#endif	
}

void UartCmd_IQ_Enable(char* szParam)
{
#if 0
    int enable;

    sscanfl( szParam, "%d ",&enable);

	ISP_IF_IQ_SetDoIQEnable(enable );
	printc( "Do IQ Enable = %d \n",enable);
#endif
}

void UartCmd_3A_Enable(char* szParam)
{
#if 0
    int enable;

    sscanfl( szParam, "%d ",&enable);

	if( enable )
	{
		ISP_IF_3A_Control(ISP_3A_ENABLE);
		printc( "3A Enable \n");
	}
	else
	{
		ISP_IF_3A_Control(ISP_3A_DISABLE);
		printc( "3A Disable \n");
	}
#endif	
}

void UartCmd_FD_Enable(char* szParam)
{
#if (SUPPORT_FDTC)
    int enable;

    sscanfl( szParam, "%d ",&enable);

	if( enable )
	{
		//DSC_FaceDetect(MMP_TRUE);
		printc( "FD Enable \n");
	}
	else
	{
		//DSC_FaceDetect(MMP_FALSE);
		printc( "FD Disable \n");
	}
#endif	
}



void UartCmd_GetFDResult(char* szParam)
{
#if (SUPPORT_FDTC)
    MMP_UBYTE bFaceNum;
	int i;
	MMPF_FDTC_RESULT *fdtcresult;
	MMP_USHORT usFdInW, usFdInH;
	
	MMPF_FDTC_GetFaceDetectResult(&bFaceNum, &fdtcresult, &usFdInW, &usFdInH);
	printc( "FD Number = %d \n",bFaceNum);
	if( bFaceNum > 0)
	{
		
		for(i=0;i<bFaceNum;i++)
		{
			printc( "FD#%d , usFacePosX=%d, usFacePosY=%d, usFaceWidthHeight=%d, InImage=(%d X %d)\n",
				i,fdtcresult[i].usFacePosX,fdtcresult[i].usFacePosY,fdtcresult[i].usFaceWidthHeight,usFdInW,usFdInH);
		}
	}
	else
	{
		printc( "FD None \n");
	}
#endif	
}


void UartCmd_SetJpegQuality(char* szParam)
{
    int quality;
    sscanfl( szParam, "%d ",&quality);
	AHC_SetCompressionQuality(quality);

	printc( "JPEG quality set to %d \n", quality);
}

void UartCmd_Get_AE_WndDiv(char* szParam)
{
#if 0
	ISP_UINT32 	wndSize;

	wndSize = ISP_IF_AE_GetAccDiv();

	printc("AE window size = %d \n", wndSize);
#endif
}

void UartCmd_Get_AE_WndACC(char* szParam)
{
#if 0
    ISP_UINT8 	wnd;
	ISP_UINT32 	acc;

    sscanfl( szParam, "%d ", &wnd);

	acc = ISP_IF_AE_GetAccByWnd(wnd);

	printc("AE wnd[%d] = %d \n", wnd, acc);
#endif
}

void UartCmd_Get_AWB_WndACC(char* szParam)
{
#if 0
    ISP_UINT8 	wnd,color;
	ISP_UINT32 	acc[4];

    sscanfl( szParam, "%d ", &wnd);

	for(color=0; color<4; ++color)
	{
		acc[color] = ISP_IF_AWB_GetAccByWnd(wnd, color);
	}
	printc("AWB wnd[%d]: R = %d, Gr = %d, Gb = %d, B = %d\n", wnd, acc[0], acc[1], acc[2], acc[3]);
#endif
}

void UartCmd_Get_WndACC(char* szParam)
{
#if 0
    ISP_UINT8 	wnd,color;
	ISP_UINT32 	acc[4],accY;

    sscanfl( szParam, "%d ", &wnd);

	accY = ISP_IF_AE_GetAccByWnd(wnd);
	
	for(color=0; color<4; ++color)
	{
		acc[color] = ISP_IF_AWB_GetAccByWnd(wnd, color);
	}
	
	printc("ACC Wnd[%d]: (Y,R,Gr,Gb,B) = %d\t %d\t %d\t %d\t %d \n", wnd, accY, acc[0], acc[1], acc[2], acc[3]);
#endif	
}

void UartCmd_Get_AFACC(char* szParam)
{
#if 0
    ISP_UINT8 	wnd,filter;
	ISP_UINT32 	acc[5];

    sscanfl( szParam, "%d", &wnd);

	printc("AV:%d SV:%d TV:%d \n",ISP_IF_AE_GetExpInfoAv(),ISP_IF_AE_GetExpInfoSv(),ISP_IF_AE_GetExpInfoTv()); 
	for(wnd=0;wnd<9;wnd++)
	{
		for(filter=0; filter<5; filter++)
		{
			acc[filter] = ISP_IF_AF_GetAccByWnd(wnd, filter);
		}
		printc("AF ACC Wnd[%d] (High,Low,Lumi) = (%7d,%9d,%9d,%9d,%9d)\n", wnd, acc[0], acc[1], acc[2], acc[3], acc[4]);
	}
#endif	
}


void UartCmd_DSC_Preview(char* szParam)
{
    int enable;
    MMP_ERR err = MMP_ERR_NONE;
    
    sscanfl( szParam, "%d ",&enable);

    //MMPS APIs are not allowed be called in the Firmware
	if( enable )
	{
        MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_FALSE, MMP_TRUE);

        MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_MAIN_LCD);

        MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY, MMP_DISPLAY_WIN_MAIN, MMP_DISPLAY_WIN_PIP, MMP_DISPLAY_WIN_MAX);
        
        MMPS_DSC_ResetPreviewMode();
        MMPS_DSC_SetPreviewMode(DSC_NORMAL_PREVIEW_MODE);

        err = MMPS_Sensor_Initialize(PRM_SENSOR, 1, 1/*MMP_SNR_DSC_PRW_MODE*/);        //Andy Liu TBD
        
      	MMPS_Sensor_SetCaptureMode(PRM_SENSOR, 0);
        if (err == MMP_ERR_NONE) {
            err = MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_TRUE, MMP_FALSE);
        }
		printc( "DSC Preview ON \n");
	}
	else
	{
        MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_FALSE, MMP_FALSE);
		printc( "DSC Preview OFF \n");
	}
	UartCmd_AE_Get_Wnd_Size(0);
}



void UartCmd_Preview_Set_Resolution(char* szParam)
{
	//ISP_SENSOR_RESOL res;  //Rogers:***
    MMP_ERR err = MMP_ERR_NONE;
	int index;

	sscanfl( szParam, "%d ",&index);

    #if 0 //Rogers:***
	switch(index)
	{
		case 0:
			res = ISP_SENSOR_RESOL_640x480; 		// VGA 30
			break;
		case 1:
			res = ISP_SENSOR_RESOL_640x480_120p; 	// VGA 120
			break;
		case 2:
			res = ISP_SENSOR_RESOL_1280x720; 		// HDTV 30
			break;
		case 3:
			res = ISP_SENSOR_RESOL_1920x1080; 		// Full HD
			break;
		case 4:
			res = ISP_SENSOR_RESOL_2560x1920; 		// 5M output
			break;
		default:
			res = ISP_SENSOR_RESOL_640x480; 		// VGA 30			
			//break;
	}
    #endif
    
        MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_FALSE, MMP_FALSE);

        MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_MAIN_LCD);

        MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY, MMP_DISPLAY_WIN_MAIN, MMP_DISPLAY_WIN_PIP, MMP_DISPLAY_WIN_MAX);

        MMPS_DSC_ResetPreviewMode(); 
        MMPS_DSC_SetPreviewMode(DSC_NORMAL_PREVIEW_MODE);

        err = MMPS_Sensor_Initialize(0/*MAIN_SENSOR*/, 1, 1/*MMP_SNR_DSC_PRW_MODE*/);        //Andy Liu TBD
        
      	MMPS_Sensor_SetCaptureMode(PRM_SENSOR, 0);
        if (err == MMP_ERR_NONE) {
            MMPS_DSC_SetPreviewMode(DSC_JPEG_RESOL_2560x1920);
            err = MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_TRUE, MMP_FALSE);
        }
}

void UartCmd_SetAWBMode(char* szParam)
{
#if 0
	ISP_AWB_MODE curAwb, preAwb;
	
	sscanfl( szParam, "%d ",&curAwb);

	preAwb = ISP_IF_AWB_GetMode();
	ISP_IF_AWB_SetMode(curAwb);
	printc( "AWB mode is changed from %d to %d \n", preAwb, curAwb);
#endif
}

void UartCmd_GetAWBMode(char* szParam)
{
#if 0
	ISP_AWB_MODE curAwb;
	
	curAwb = ISP_IF_AWB_GetMode();
	printc( "Current AWB mode is %d\n", curAwb);
#endif
}

void UartCmd_SetWBOnePushTrig(char* szParam)
{ 
    #if 0  
	ISP_ONEPUSH_WB_TRIG curAwb, preAwb;
	
	sscanfl( szParam, "%d ",&curAwb);

	preAwb = ISP_IF_AWB_GetOnePushWbTrig();
	ISP_IF_AWB_SetOnePushWbTrig(curAwb); //Rogers:***
	printc( "One Push WB Trigger is changed from %d to %d \n", preAwb, curAwb);
	#endif

}

void UartCmd_SetAeMode(char* szParam)
{
    #if 0 //Rogers:***
	ISP_AE_MODE ae_mode_now;
	int index;
	sscanfl( szParam, "%d ",&index);

	ae_mode_now = ISP_IF_AE_GetMode();
	switch(index)
	{
		case 0:
			ISP_IF_AE_SetMode(ISP_AE_MODE_AUTO);
			printc( "AE_MODE from %d to %d \n",ae_mode_now,index);
			break;

		case 1:
			ISP_IF_AE_SetMode(ISP_AE_ISO_PRIORITY);
			printc( "AE_MODE from %d to %d \n",ae_mode_now,index);
			break;
		
		case 2:
			ISP_IF_AE_SetMode(ISP_AE_SHUTTER_PRIORITY);
			printc( "AE_MODE from %d to %d \n",ae_mode_now,index);
			break;
			
		case 3:
			ISP_IF_AE_SetMode(ISP_AE_APERTURE_PRIORITY);
			printc( "AE_MODE from %d to %d \n",ae_mode_now,index);
			break;
			
		case 4:
			ISP_IF_AE_SetMode(ISP_AE_MANUAL);
			printc( "AE_MODE from %d to %d \n",ae_mode_now,index);
			break;
			
		default:
			ISP_IF_AE_SetMode(ae_mode_now);
			printc( "Wrong mode input, use original AE_MODE %d\n",ae_mode_now);
			break;
	}
	#endif
}

void UartCmd_GetAeMode(char* szParam)
{
#if 0
	ISP_AE_MODE ae_mode_now;
	
	ae_mode_now = ISP_IF_AE_GetMode();
	
	switch(ae_mode_now)
	{
		case ISP_AE_MODE_P:
			printc( "AE mode now is %d (ISP_AE_MODE_P) \n",ae_mode_now);
			break;

		case ISP_AE_MODE_A:
			printc( "AE mode now is %d (ISP_AE_MODE_A) \n",ae_mode_now);
			break;
			
		case ISP_AE_MODE_S:
			printc( "AE mode now is %d (ISP_AE_MODE_S) \n",ae_mode_now);
			break;
			
		case ISP_AE_MODE_M:
			printc( "AE mode now is %d (ISP_AE_MODE_M) \n",ae_mode_now);
			break;
			
		default:
			printc( "Unknown mode %d\n",ae_mode_now);
			break;
	}
#endif	
}

void UartCmd_SetAeLockMode(char* szParam)
{
#if 0 //Rogers:*** 
	ISP_AE_LOCK curAeLock, preAeLock;
	
	sscanfl( szParam, "%d ",&curAeLock);

	preAeLock = ISP_IF_AE_GetAELock();
	ISP_IF_AE_SetAELock(curAeLock);
	printc( "AE LOCKMODE is changed from %d to %d \n", preAeLock, curAeLock);
#endif	
}

void UartCmd_GetAeLockMode(char* szParam)
{
#if 0 //Rogers:*** 
	ISP_AE_LOCK aeLock;
	aeLock = ISP_IF_AE_GetAELock();
	printc( "AE lock mode now is %d \n", aeLock);
#endif	
}

void UartCmd_SetAeIsoMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_ISO ae_mode_now;
	int index;
	sscanfl( szParam, "%d ",&index);

	ae_mode_now = ISP_IF_AE_GetISOMode();
	ISP_IF_AE_SetISOMode(index);
	printc( "AE ISO from %d to %d \n",ae_mode_now,index);
#endif	
}

void UartCmd_GetAeIsoMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_ISO ae_mode_now;
	ae_mode_now = ISP_IF_AE_GetISOMode();
	printc( "AE ISO mode now is %d \n",ae_mode_now);
#endif	
}

void UartCmd_SetAeEvBiasMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_EV_BIAS ae_mode_now;
	int index;
	sscanfl( szParam, "%d ",&index);

	ae_mode_now = ISP_IF_AE_GetEVBias();
	ISP_IF_AE_SetEVBias(index);
	printc( "AE EV bias from %d to %d \n",ae_mode_now,index);
#endif	
}

void UartCmd_GetAeEvBiasMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_EV_BIAS ae_mode_now;
	ae_mode_now = ISP_IF_AE_GetEVBias();
	printc( "AE EV bias mode now is %d \n",ae_mode_now);
#endif	
}

void UartCmd_SetAeMeterMode(char* szParam)
{
#if 0
	ISP_AE_METERING ae_mode_now;
	int index;
	sscanfl( szParam, "%d ",&index);

	ae_mode_now = ISP_IF_AE_GetMetering();
	ISP_IF_AE_SetMetering(index);
	printc( "AE Metering from %d to %d \n",ae_mode_now,index);
#endif	
}

void UartCmd_GetAeMeterMode(char* szParam)
{
#if 0
	ISP_AE_METERING ae_mode_now;
	ae_mode_now = ISP_IF_AE_GetMetering();
	printc( "AE Metering mode now is %d \n",ae_mode_now);
#endif	
}


void UartCmd_SetAeSISMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_STILL_IS ae_mode_now;
	int enable;
	sscanfl( szParam, "%d ",&enable);

	ae_mode_now = ISP_IF_AE_GetStillImageStablizer();
	ISP_IF_AE_SetStillImageStablizer(enable);
	printc( "Still image stablizer enable from %d to %d \n",ae_mode_now,enable);
#endif	
}

void UartCmd_GetAeSISMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_STILL_IS ae_mode_now;

	ae_mode_now = ISP_IF_AE_GetStillImageStablizer();
	printc( "Still image stablizer enable is %d \n",ae_mode_now);
#endif	
}


void UartCmd_GetSnrTRow(char* szParam)
{
#if 0
	ISP_UINT32 trow;
	
	trow = ISP_IF_SNR_GetTRow(0);

	printc( "Sensor TRow is %d \n", trow);
#endif	
}
	
void UartCmd_GetAeFlickerMode(char* szParam)
{
#if 0
	ISP_AE_FLICKER flk;
	
	flk = ISP_IF_AE_GetFlicker();

	printc( "AE Flicker mode now is %d \n", flk);
#endif	
}

void UartCmd_SetAeFlickerMode(char* szParam)
{
#if 0
	ISP_AE_FLICKER curFlk, preFlk;

	sscanfl( szParam, "%d ",&curFlk);

	preFlk = ISP_IF_AE_GetFlicker();
	
	ISP_IF_AE_SetFlicker(curFlk);

	printc( "AE Flicker mode changed from %d to %d \n", preFlk, curFlk );
#endif	
}


void UartCmd_SetAeSpeedMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_SPEED curSpd, preSpd;

	sscanfl( szParam, "%d ", &curSpd );

	preSpd = ISP_IF_AE_GetConvergenceSpeedMode();
	
	ISP_IF_AE_SetConvergenceSpeedMode( curSpd );

	printc( "AE speed mode changed from %d to %d \n", preSpd, curSpd );
#endif	
}


void UartCmd_GetAeSpeedMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_SPEED spd;
	
	spd = ISP_IF_AE_GetConvergenceSpeedMode();

	printc( "AE speed mode now is %d \n", spd );
#endif	
}

void UartCmd_SetAeSlowShutMode(char* szParam)
{
#if 0 //Rogers:***
	int shut_en,shut_ori;
	
	sscanfl( szParam, "%d ", &shut_en );
	
	shut_ori = ISP_IF_AE_GetSlowShutter();
	ISP_IF_AE_SetSlowShutter( shut_en );

	printc( "AE slow shutter mode changes from %d to %d\n", shut_ori,shut_en );
#endif	
}


void UartCmd_GetAeSlowShutMode(char* szParam)
{
#if 0 //Rogers:***
	ISP_AE_SLOW_SHUTTER shut_en;
	
	shut_en = ISP_IF_AE_GetSlowShutter();

	printc( "AE slow shutter mode now is %d \n", shut_en );
#endif	
}

void UartCmd_AE_Set_MaxAgainMultiple( char* szParam )
{
#if 0
	INT32 test,multiple;
	sscanfl( szParam, "%d ", &multiple);
	if (multiple<=0)
	{
		printc("MaxAgainMultiple = %d,use default MaxAgain\n",multiple);
		ISP_IF_AE_SetManualMaxAgainMultiple(0);		
	}
	else{
		ISP_IF_AE_SetManualMaxAgainMultiple(multiple);		
	}
	
	test = ISP_IF_AE_GetManualMaxAgainMultiple();
	printc("MaxAgainMultiple = %d\n",test);	
#endif	
}

void UartCmd_AE_Get_MaxAgainMultiple( char* szParam )
{
#if 0
	INT32 test;
	
	test = ISP_IF_AE_GetManualMaxAgainMultiple();
	printc("MaxAgainMultiple = %d\n",test);	
#endif	
}

void UartCmd_AE_Set_MaxDgainMultiple( char* szParam )
{	
}

void UartCmd_AE_Get_MaxDgainMultiple( char* szParam )
{
#if 0
	INT32 test;
	
	test = ISP_IF_AE_GetManualMaxDgainMultiple();
	printc("MaxDgainMultiple = %d\n",test);	
#endif	
}

void UartCmd_AE_Set_MaxTotalGainMultiple( char* szParam )
{
#if 0
	INT32 test,multiple;
	sscanfl( szParam, "%d ", &multiple);
	if (multiple<=0){
		printc("MaxTotalGainMultiple = %d,use default MaxTotalGain\n",multiple);
		ISP_IF_AE_SetManualMaxTotalGainMultiple(0);		
	}else{
		ISP_IF_AE_SetManualMaxTotalGainMultiple(multiple);		
	}
	
	test = ISP_IF_AE_GetManualMaxTotalGainMultiple();
	printc("MaxTotalGainMultiple = %d\n",test);	
#endif	
}

void UartCmd_AE_Get_MaxTotalGainMultiple( char* szParam )
{
#if 0
	INT32 test;
	
	test = ISP_IF_AE_GetManualMaxTotalGainMultiple();
	printc("MaxTotalGainMultiple = %d\n",test);	
#endif	
}

void UartCmd_AE_SetTv( char* szParam )
{
#if 0
	UINT32 value;
	sscanfl( szParam, "%d ", &value);
	
	//ISP_IF_AE_SetManualTv(value<<16);
	ISP_IF_AE_SetManualTv(value);
	
	value = ISP_IF_AE_GetManualTv();
	printc("Tv set to %d\n",value);	
#endif	
}

void UartCmd_AE_SetSv( char* szParam )
{
#if 0
	UINT32 value;
	sscanfl( szParam, "%d ", &value);
	 
	ISP_IF_AE_SetManualSv(value<<16);
	
	value = ISP_IF_AE_GetManualSv();
	printc("Sv set to %d\n",value);	
#endif	
}

void UartCmd_AE_GetTv( char* szParam )
{
#if 0
	UINT32 value;
	
	value = ISP_IF_AE_GetManualTv();
	printc("Tv is %d\n",value);	
#endif	
}

void UartCmd_AE_GetSv( char* szParam )
{
#if 0
	UINT32 value;
	
	value = ISP_IF_AE_GetManualSv();
	printc("Sv is %d\n",value);	
#endif	
}

void UartCmd_AE_SetShutterMode( char* szParam )
{
#if 0 //Rogers:***	
	ISP_AE_SHT ae_shutter_mode_now;
	int index;
	sscanfl( szParam, "%d ",&index);

	ae_shutter_mode_now = ISP_IF_AE_GetShutterMode();
	switch(index)
	{
		case 0:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_AUTO);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
			
		case 1:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_1);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;	
				
		case 2:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_2);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;	
				
		case 3:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_4);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
			
		case 4:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_8);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
		
		case 5:	
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_15);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;

		case 6:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_30);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
		
		case 7:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_60);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
			
		case 8:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_125);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
			
		case 9:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_500);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
		
		case 10:	
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_1000);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;

		case 11:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_2000);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
		
		case 12:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_4000);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
			
		case 13:
			ISP_IF_AE_SetShutterMode(ISP_AE_SHUTTER_MANUAL);
			printc( "AE_Shutter_MODE from %d to %d \n",ae_shutter_mode_now,index);
			break;
			
			
		default:
			ISP_IF_AE_SetShutterMode(ae_shutter_mode_now);
			printc( "Wrong mode input, use original AE_Shutter_MODE %d\n",ae_shutter_mode_now);
			break;
	}	
#endif	
}

void UartCmd_AE_GetShutterMode( char* szParam )
{
#if 0 //Rogers:***
	UINT32 value;
	
	value = ISP_IF_AE_GetShutterMode();
	printc("ShutterMode is %d\n",value);	
#endif	
}

void UartCmd_Preview_Get_Resolution(char* szParam)
{
#if 0 //Rogers:***
	ISP_SENSOR_RESOL res;

	res = ISP_IF_SNR_GetCurResol();

	switch(res)
	{
		case ISP_SENSOR_RESOL_NULL:
			printc( "Preview resolution = ISP_SENSOR_RESOL_NULL\n");
			break;
		case ISP_SENSOR_RESOL_320x240:
			printc( "Preview resolution = ISP_SENSOR_RESOL_320x240\n");
			break;
		case ISP_SENSOR_RESOL_512x384:
			printc( "Preview resolution = ISP_SENSOR_RESOL_512x384\n");
			break;

		case ISP_SENSOR_RESOL_640x480:
			printc( "Preview resolution = ISP_SENSOR_RESOL_640x480\n");
			break;

		case ISP_SENSOR_RESOL_800x600:
			printc( "Preview resolution = ISP_SENSOR_RESOL_800x600\n");
			break;

		case ISP_SENSOR_RESOL_1024x768:
			printc( "Preview resolution = ISP_SENSOR_RESOL_1024x768\n");
			break;

		case ISP_SENSOR_RESOL_1280x1024:
			printc( "Preview resolution = ISP_SENSOR_RESOL_1280x1024\n");
			break;

		case ISP_SENSOR_RESOL_1280x960:
			printc( "Preview resolution = ISP_SENSOR_RESOL_1280x960\n");
			break;

		case ISP_SENSOR_RESOL_1600x1200:
			printc( "Preview resolution = ISP_SENSOR_RESOL_1600x1200\n");
			break;
			
		case ISP_SENSOR_RESOL_2048x1536:
			printc( "Preview resolution = ISP_SENSOR_RESOL_2048x1536\n");
			break;	
		case ISP_SENSOR_RESOL_2560x1920:
			printc( "Preview resolution = ISP_SENSOR_RESOL_2560x1920\n");
			break;
		case ISP_SENSOR_RESOL_3264x2448:
			printc( "Preview resolution = ISP_SENSOR_RESOL_3264x2448\n");
			break;
		case ISP_SENSOR_RESOL_1280x720:
			printc( "Preview resolution = ISP_SENSOR_RESOL_1280x720\n");
			break;
		case ISP_SENSOR_RESOL_1920x1080:
			printc( "Preview resolution = ISP_SENSOR_RESOL_1920x1080\n");
			break;
		case ISP_SENSOR_RESOL_640x480_120p:
			printc( "Preview resolution = ISP_SENSOR_RESOL_640x480_120p\n");
			break;				
	}
#endif	
}


void UartCmd_StillCapture_Set_Resolution(char* szParam)
{
	UINT32 tarWidth,tarHeight;

	sscanfl( szParam, "%d %d",&tarWidth, &tarHeight);
	AHC_SetImageSize(STILL_CAPTURE_MODE,tarWidth,tarHeight);
	printc( "Set still capture image size to = %d x %d\n", tarWidth, tarHeight);
	AHC_GetImageSize(STILL_CAPTURE_MODE,&tarWidth,&tarHeight);
	printc( "Return still capture image size to = %d x %d\n", tarWidth, tarHeight);
}

void UartCmd_StillCapture_Get_Resolution(char* szParam)
{
	UINT32 CaptureWidth,CaptureHeight;
	AHC_GetImageSize(STILL_CAPTURE_MODE,&CaptureWidth,&CaptureHeight);
	printc( "Get still capture image size = %d x %d\n", CaptureWidth, CaptureHeight);

}
void UartCmd_Preview_Mode(char* szParam)
{
#if 0 //Rogers:***
    int mode;
    MMP_ERR err = MMP_ERR_NONE;
	ISP_SENSOR_RESOL res;

    sscanfl( szParam, "%d ",&mode);

	switch(res)
	{
		case 0:
			res = ISP_SENSOR_RESOL_1280x960;
			break;
			
		case 1:
			res = ISP_SENSOR_RESOL_1920x1080;
			break;	
	}

#if 0	
		DSC_StopPreview();
#else
        MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_FALSE, MMP_FALSE);
#endif

	ISP_IF_SNR_SetResolution(res);

	
#if 0	
		DSC_StartPreview();
#else
        MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_MAIN_LCD);

        MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY, MMP_DISPLAY_WIN_MAIN, MMP_DISPLAY_WIN_PIP, MMP_DISPLAY_WIN_MAX);

        MMPS_DSC_ResetPreviewMode(); 
        MMPS_DSC_SetPreviewMode(DSC_NORMAL_PREVIEW_MODE);

        err = MMPS_Sensor_Initialize(MAIN_SENSOR, 1, 1/*MMP_SNR_DSC_PRW_MODE*/);        
        
      	MMPS_Sensor_SetCaptureMode(PRM_SENSOR, 0);
        if (err == MMP_ERR_NONE) {
            err = MMPS_DSC_EnablePreviewDisplay(PRM_SENSOR, MMP_TRUE, MMP_FALSE);
        }
#endif

#endif	
}



void UartCmd_AE_Log_Start(char* szParam)
{
#if 0
	int mode;
	
	sscanfl( szParam, "%d ",&mode);

	// mode 2 = > test 0
	// mode 3 = > test 1

	ISP_IF_CMD_SendCommandtoAE(mode,0,0,0);
#endif	
}

void UartCmd_Save_AE_Log(char* szParam)
{
#if 0
	char* fileName = "SD:\\aelog.txt";

	DramToFile((INT8*)fileName, (INT8*)ISP_IF_AE_GetLogAddr(), (UINT32)1024*10);

	ISP_IF_CMD_SendCommandtoAE(4,0,0,0); // log end
#endif	
	
}

void UartCmd_Save_AF_Log(char* szParam)
{
#if 0
	char* fileName = "SD:\\aflog.bin";
	DramToFile(fileName, (INT8*)ISP_IF_AF_GetLogAddr(), 16368);   
#endif	
}


#define ACC_LOG_DATA_ADDR 0x3500000
void UartCmd_Save_ACC_Log(char* szParam)
{
#if 0 //Rogers:***
	char* fileName = "SD:\\afFpsAcc.bin";

	unsigned short fps_min = 50;
	unsigned short fps_max = 800;
	unsigned short accNumEachFps = 4;

	int log_len;
	int i=0,wnd,filter,k;
	unsigned short tarPos;
	unsigned int* Ptr = (unsigned int*)ACC_LOG_DATA_ADDR;
	ISP_AF_STYLE ori_style = ISP_IF_AF_GetAFStyle();
	
	ISP_IF_AF_SetAFStyle(ISP_AF_STYLE_STILL_ONESHOT);
	MMPF_OS_Sleep(10);

	log_len = (fps_max-fps_min+1)*accNumEachFps*50*4;
	for(tarPos=fps_max;tarPos>=fps_min;tarPos--)
	{
		// move motor to that place
		ISP_IF_AF_SetPos(tarPos);
		ISP_IF_MOTOR_GoToAFPos();
		while(FuncMotorCtrl_FocusReady()==MT_STATE_BUSY);

		MMPF_OS_Sleep(66); // wait 2 frames
		// log data

		for(k=0;k<accNumEachFps;k++)
		{
			Ptr[i] = (unsigned int)tarPos;
			i++;
			Ptr[i] = (unsigned int)ISP_IF_AE_GetExpInfoAv();
			i++;
			Ptr[i] = (unsigned int)ISP_IF_AE_GetExpInfoSv();
			i++;
			Ptr[i] = (unsigned int)ISP_IF_AE_GetExpInfoTv();
			i++;
			Ptr[i] = (unsigned int)FuncMotorCtrl_ZoomCurrentIndex();
			i++;
			for(wnd=0;wnd<9;wnd++)
			{
				for(filter=0;filter<5;filter++)
				{
					Ptr[i] = (unsigned int)ISP_IF_AF_GetAccByWnd(wnd, filter);
					i++;
				}
			}

			MMPF_OS_Sleep(33); // wait 1 frames
		}

		if(tarPos%100 == 0)
			printc("log tarPos = %d ,log_len = %d, Sv=%d\n",tarPos,log_len,ISP_IF_AE_GetExpInfoSv());
			
	}
	printc("log len = %d \n",i);

	ISP_IF_AF_SetAFStyle(ori_style);
	
	DramToFile(fileName, (INT8*)Ptr, log_len);   
#endif	
}


void UartCmd_AFMotor_Move_To(char* szParam)
{
#if 0 //Rogers:***
    int tarPos, curSpdMode, currentPos; // , filter=0, wnd=4 , acc[3];
	unsigned int time1,time2;

    sscanfl( szParam, "%d ",&tarPos);

	time1 = MMPF_OsCounterGetUs();
	
	currentPos = ISP_IF_AF_GetPos();
	curSpdMode = ISP_IF_AF_GetFocusMotorSpeedMode();

	ISP_IF_AF_SetPos(tarPos);
	ISP_IF_MOTOR_GoToAFPos();

	while(FuncMotorCtrl_FocusReady()==MT_STATE_BUSY);
	//MMPF_OS_Sleep(100);
	time2 = MMPF_OsCounterGetUs();

	printc("Motor moving time is %d us \n",time2-time1);
	//for(filter=0; filter<3; ++filter)
	//{
	//	acc[filter] = ISP_IF_AF_GetAccByWnd(wnd, filter);
	//}
	//printc("AF ACC Wnd[%d] (High,Low,Lumi) = (%7d,%9d,%9d)\n", wnd, acc[0], acc[1], acc[2]);

	printc( "AF motor moves from %d to %d with speed mode %d\n", currentPos, tarPos,curSpdMode);
#endif	
}

void UartCmd_CurrFocusPosi(char* szParam)
{
#if 0 //Rogers:***
	int currentPos = ISP_IF_AF_GetPos();
	int currentPos2 = FuncMotorCtrl_FocusGetPosition();
	printc( "AF motor current posi is ISP: %d Motor: %d \n", currentPos,currentPos2);
#endif	
}

void UartCmd_ZoomMotor_Move_To(char* szParam)
{
#if 0
    int tarPos, currentPos;

    sscanfl( szParam, "%d ",&tarPos);

	currentPos = ISP_IF_AF_GetZoomTarPos();

	ISP_IF_AF_SetZoomTarPos(tarPos);

	ISP_IF_MOTOR_GoToZoomPos();

	printc( "Zoom motor move from %d to %d\n", currentPos, tarPos);
#endif	
}

void UartCmd_CurrZoomPosi(char* szParam)
{
#if 0
    int currentPos, currentPos2;
	currentPos = ISP_IF_AF_GetZoomTarPos();
	currentPos2 = FuncMotorCtrl_ZoomCurrentIndex();
	printc( "Zoom current posi is %d , from motor driver: %d\n", currentPos, currentPos2);
#endif	
}

void UartCmd_AF_SetInfPos(char* szParam)
{
#if 0
    int tarInfpos, currentIntPos;
    sscanfl( szParam, "%d ",&tarInfpos);

	currentIntPos = ISP_IF_AF_GetINFPos();
	ISP_IF_AF_SetINFPos(tarInfpos);

	printc( "AF Inf Position is changed from %d to %d\n", currentIntPos, tarInfpos );
#endif	
}

void UartCmd_AF_GetInfPos(char* szParam)
{
#if 0
    int currentIntPos;
	currentIntPos = ISP_IF_AF_GetINFPos();

	printc( "Current AF Inf Position is %d\n", currentIntPos );
#endif	
}

void UartCmd_AF_SetCurr2InfPos(char* szParam)
{
#if 0
    int tarInfpos, currentIntPos;
    sscanfl( szParam, "%d ",&tarInfpos);

	currentIntPos = ISP_IF_AF_GetCurr2INFPos();
	ISP_IF_AF_SetCurr2INFPos(tarInfpos);

	printc( "AF Curr2INF Position is changed from %d to %d\n", currentIntPos, tarInfpos );
#endif	
}

void UartCmd_AF_GetCurr2InfPos(char* szParam)
{
#if 0
    int currentIntPos;
	currentIntPos = ISP_IF_AF_GetCurr2INFPos();

	printc( "Current AF Curr2Inf Position is %d\n", currentIntPos );
#endif	
}

void UartCmd_AF_SetStyle(char* szParam)
{
#if 0 //Rogers:***
    ISP_AF_STYLE tarStyle, curStyle;
	
    sscanfl( szParam, "%d ",&tarStyle );

	curStyle = ISP_IF_AF_GetAFStyle();
	ISP_IF_AF_SetAFStyle(tarStyle);

	printc( "AF Style is changed from %d to %d\n", curStyle, tarStyle );
#endif	
}

void UartCmd_AF_GetStyle(char* szParam)
{
#if 0 //Rogers:***
    ISP_AF_STYLE curStyle;
	
	curStyle = ISP_IF_AF_GetAFStyle();

	printc( "Current AF Style is %d\n", curStyle );
#endif	
}

void UartCmd_AF_SetMovieType(char* szParam)
{
#if 0 //Rogers:***
    ISP_AF_MOVIE_TYPE tarStyle, curStyle;
	
    sscanfl( szParam, "%d ",&tarStyle );

	curStyle = ISP_IF_AF_GetAFMovieType();
	ISP_IF_AF_SetAFMovieType(tarStyle);

	printc( "AF Movie type is changed from %d to %d\n", curStyle, tarStyle );
#endif	
}

void UartCmd_AF_GetMovieType(char* szParam)
{
#if 0 //Rogers:***
    ISP_AF_MOVIE_TYPE curStyle;
	
	curStyle = ISP_IF_AF_GetAFMovieType();

	printc( "Current AF Movie type is %d\n", curStyle );
#endif	
}

void UartCmd_AF_SetActiveSpot(char* szParam)
{
#if 0 //Rogers:***
    ISP_UINT16 x0, x1, y0, y1;
	ISP_UINT16 Pos[4];

	// spot region is (x0,y0) to (x1, y1)
    sscanfl( szParam, "%d %d %d %d", &x0, &x1, &y0, &y1 );

	Pos[0] = x0;
	Pos[1] = x1;
	Pos[2] = y0;
	Pos[3] = y1;


	ISP_IF_AF_SetWindowMode(ISP_AF_WNDMODE_ACTSPOT_WND);
	ISP_IF_AF_SetActiveSpotWindow(Pos);


	printc( "AF Win Mode is active spot, Pos is (%d,%d) to (%d,%d) \n", x0, y0, x1, y1 );
#endif	
}


void UartCmd_GetSceneMode(char* szParam)
{
#if 0 //Rogers:***
    ISP_SCENE sceneMode;
	
	sceneMode = ISP_IF_F_GetScene();

	printc( "Current Scene Mode is %d\n", sceneMode);
#endif	
}


void UartCmd_SetSceneMode(char* szParam)
{
#if 0 //Rogers:***
    ISP_SCENE tar, cur;
	
    sscanfl( szParam, "%d ",&tar);

	cur = ISP_IF_F_GetScene(); 
	ISP_IF_F_SetScene(tar);

	printc( "Scene Mode is changed from %d to %d\n", cur, tar);
#endif	
}

void UartCmd_GetImageEffectMode(char* szParam)
{
#if 0 //Rogers:***
    ISP_IMAGE_EFFECT moode;
	
	moode = ISP_IF_F_GetImageEffect();

	printc( "Current image effect mode is %d\n", moode);
#endif	
}

void UartCmd_SetImageEffectMode(char* szParam)
{
#if 0
    ISP_IMAGE_EFFECT tar, cur;
	
    sscanfl( szParam, "%d ", &tar );

	//cur = ISP_IF_F_GetImageEffect();  //Rogers:*** 
	ISP_IF_F_SetImageEffect(tar);

	printc( "Image effect mode is changed from %d to %d\n", cur, tar );
#endif	
}

void UartCmd_SetSatLevel(char* szParam)
{
#if 0
    int tar;
	
    sscanfl( szParam, "%d ", &tar );

	ISP_IF_F_SetSaturation(tar);

	printc( "Saturation level is set to %d\n", tar );
#endif	
}



void UartCmd_SetVifLatchByte(char* szParam)
{
#if 0 //Rogers:***
    int mode, tar, cur, cur2;
	AITPS_VIF  pVIF = AITC_BASE_VIF;
	
    sscanfl( szParam, "%x %x",&mode, &tar);

	cur = pVIF->VIF_SENSR_CTL; 
	#if (CHIP == P_V2)
	cur2 = pVIF->VIF_SENSOR_CLK_DELAY_CTL;
	#endif
	if(mode == 1)
	{
		pVIF->VIF_SENSR_CTL = tar;
		printc( "VIF_SENSR_CTL is from %x to %x\n", cur, tar);
	}
	else if(mode == 2)
	{
		pVIF->VIF_SENSOR_CLK_DELAY_CTL = tar;
		printc( "VIF_SENSOR_CLK_DELAY_CTL is from %x to %x\n", cur2, tar);
	}
	else
	{
		printc( "curr VIF_SENSR_CTL=%x, VIF_SENSOR_CLK_DELAY_CTL=%x\n", cur, cur2);
	}
#endif	
}

void UartCmd_SetSnrReg(char* szParam)
{
#if 0
    int mode, addr, tar;	
    unsigned short cur2,cur;
    sscanfl( szParam, "%x %x %x",&mode, &addr, &tar);

    ISP_HDM_IF_I2C_Read(0x5D,addr, &cur, 0x02);

	if(mode == 1)
	{
		ISP_IF_SNR_WriteI2C(addr,tar);
        ISP_HDM_IF_I2C_Read(0x5D,addr, &cur2, 0x02);
		printc( "Sensor reg=%x is from %x to %x\n", addr, cur,cur2);
	}
	else
	{
		printc( "Sensor reg=%x is %x\n", addr, cur);
	}
#endif	
}

void UartCmd_SetISPColorID(char* szParam)
{
#if 0
    int tar;

	sscanfl( szParam, "%d", &tar);
	
	ISP_IF_SNR_SetColorID(tar);
	ISP_IF_IQ_SetDirection(0);  // just test, just set a don't use in product

	printc( "SNR Flip is to %d \n", tar);	
#endif	
}

void UartCmd_SNR_Flip(char* szParam)
{
    int tar;

	sscanfl( szParam, "%d", &tar);
	
	AHC_Set_SensorFlip(tar);

	printc( "SNR Flip is to %d \n", tar);	
}

void UartCmd_WDR(char* szParam)
{
    int mode;

	sscanfl( szParam, "%d", &mode);

    //ISP_IF_F_SetWDR(128);
	AHC_SetAeWDRMode(mode);

	printc( "WDR  setting %d \n", mode);
}

void UartCmd_AF_Still_Opr(char* szParam)
{
#if 0 //Rogers:***
    ISP_AF_OPERATION preOp, tarOp;

	// 0x00 : NoRequest, 0x01 : Still Start, 0x02 : Still Cancel

    //sscanfl( szParam, "%d ",&tarOp);

	preOp = ISP_IF_AF_GetSillAFOperation();

	if( preOp ==  ISP_AF_OPERATION_NOREQ )
	{
		tarOp = ISP_AF_OPERATION_START;
	}
	else
	{
		tarOp = ISP_AF_OPERATION_CANCEL;
	}

	ISP_IF_AF_SetSillAFOperation(tarOp);


	printc( "Still AF operation change from %d to %d\n", preOp, tarOp);
#endif	
}

void UartCmd_AF_SetAitMOVParms(char* szParam)
{
#if 0 //Rogers:***
	int curAfMovParm, preAfMovParm;
	int type,errstatus;
	char StrBuf[64];
	
	sscanfl( szParam, "%d %d",&type, &curAfMovParm);
	switch(type)
	{
	case ISP_AF_MOVIE_DZOOM_AUTOADJU_EN: sprintf(StrBuf,"DzoomAutoAdjuEn"); 				break;
	case ISP_AF_MOVIE_DZOOM_AUTOADJU_THR: 	sprintf(StrBuf,"DzoomAutoAdjuThr");		break;
	default:								sprintf(StrBuf,"Unsupported!");				break;
	}
	preAfMovParm = ISP_IF_AF_GetMovieTuningParams(type);
	errstatus = ISP_IF_AF_SetMovieTuningParams(type,curAfMovParm);

	printc( "%s is changed from %d to %d, ErrStatus:%d\n", StrBuf, preAfMovParm, curAfMovParm, errstatus);
#endif	
}

void UartCmd_AF_GetAitMOVParms(char* szParam)
{
#if 0 //Rogers:***
	unsigned int curAfMovParmsType;
	char StrBuf[64];
	int out;

	sscanfl( szParam, "%d ",&curAfMovParmsType);
	switch(curAfMovParmsType)
	{
	case ISP_AF_MOVIE_DZOOM_AUTOADJU_EN: sprintf(StrBuf,"DzoomAutoAdjuEn"); 				break;
	case ISP_AF_MOVIE_DZOOM_AUTOADJU_THR: 	sprintf(StrBuf,"DzoomAutoAdjuThr");		break;
	default:								sprintf(StrBuf,"Unsupported!");				break;
	}
	out = ISP_IF_AF_GetMovieTuningParams(curAfMovParmsType);
	printc( "%s is %d \n", StrBuf,out);
#endif	
}


void UartCmd_AF_GetAitIQTuningParms(char* szParam)
{
#if 0 //Rogers:***
	unsigned int curParmsType;
	char StrBuf[64];
	int out;

	sscanfl( szParam, "%d ",&curParmsType);
	switch(curParmsType)
	{
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_AUTOADJU_EN: sprintf(StrBuf,"DZOOM_SHARP_AUTOADJU_EN"); 				break;
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_AUTOADJU_THR: 	sprintf(StrBuf,"DZOOM_SHARP_AUTOADJU_THR");		break;
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_LEVEL_LOW: 	sprintf(StrBuf,"DZOOM_SHARP_LEVEL_LOW");		break;
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_LEVEL_HIGH: 	sprintf(StrBuf,"DZOOM_SHARP_LEVEL_HIGH");		break;
	default:								sprintf(StrBuf,"Unsupported!");				break;
	}
	out = ISP_IF_IQ_GetTuningParams(curParmsType);
	printc( "%s is %d \n", StrBuf,out);
#endif	
}

void UartCmd_AF_SetAitIQTuningParms(char* szParam)
{
#if 0 //Rogers:***
	int curParmsType, preParmsType;
	int type,errstatus;
	char StrBuf[64];
	
	sscanfl( szParam, "%d %d",&type, &curParmsType);
	switch(curParmsType)
	{
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_AUTOADJU_EN: sprintf(StrBuf,"DZOOM_SHARP_AUTOADJU_EN"); 				break;
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_AUTOADJU_THR: 	sprintf(StrBuf,"DZOOM_SHARP_AUTOADJU_THR");		break;
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_LEVEL_LOW: 	sprintf(StrBuf,"DZOOM_SHARP_LEVEL_LOW");		break;
	case ISP_IQ_TUNEPARMS_DZOOM_SHARP_LEVEL_HIGH: 	sprintf(StrBuf,"DZOOM_SHARP_LEVEL_HIGH");		break;
	default:								sprintf(StrBuf,"Unsupported!");				break;
	}
	preParmsType = ISP_IF_IQ_GetTuningParams(type);
	errstatus = ISP_IF_IQ_SetTuningParams(type,curParmsType);

	printc( "%s is changed from %d to %d, ErrStatus:%d\n", StrBuf, preParmsType, curParmsType, errstatus);
#endif	
}

void UartCmd_AF_SetManRgeMode(char* szParam)
{
#if 0 //Rogers:***
	int pos_min,pos_max,step;
	sscanfl( szParam, "%d %d %d",&pos_min,&pos_max,&step);

	ISP_IF_AF_SetLensV2InfPosCtlMode(ISP_AFINFPOS_LENSV_CTL_DIS);
	ISP_IF_AF_SetAfRangeAndStepSize((MMP_USHORT)pos_min,(MMP_USHORT)pos_max,(MMP_USHORT)step);
	ISP_IF_AF_SetAFStyle(ISP_AF_STYLE_STILL_ONESHOT);
	ISP_IF_AF_SetMode(ISP_AF_MODE_MANUALRANGESTEP);
	
	printc( "AF mode changed to ISP_AF_MODE_MANUALRANGESTEP, and (min,max,step)=(%d,%d,%d)\n", pos_min,pos_max,step);
#endif	
}

void UartCmd_AF_GetManRgeMode(char* szParam)
{
#if 0 //Rogers:***
	MMP_USHORT pos_min,pos_max,step;

	ISP_IF_AF_GetAfRangeAndStepSize(&pos_min,&pos_max,&step);
	
	printc( "When AF mode is ISP_AF_MODE_MANUALRANGESTEP, (min,max,step)=(%d,%d,%d)\n", pos_min,pos_max,step);
#endif	
}

void UartCmd_AF_SetManAfPos(char* szParam)
{
#if 0 //Rogers:***
	int pos;
	sscanfl( szParam, "%d",&pos);

	ISP_IF_AF_SetAFStyle(ISP_AF_STYLE_MANUAL);
	ISP_IF_AF_ManualSetFocusPos(pos);
	printc("AF mode swithc to ISP_AF_MODE_MANUAL, position moves to %d \n",pos);
#endif	
}

void UartCmd_Set_ISP_DGain(char* szParam)
{
#if 0
    unsigned int gain;

    sscanfl( szParam, "%d ",&gain);

	//AE_AGAIN_1X ~ AE_AGAIN_1X * 8

	if( gain < 1 )
	{
		gain = 1;
	}
	else if( gain > 8 )
	{
		gain = 8;
	}

	ISP_IF_SNR_SetDGain( (gain * 0x0200) );	

	printc( "Set ISP Digital Gain to %d\n", gain);
	//printc( "[ISP_SRC_CTL] = %x, [ISP_DGAIN_L] = %x\n", OPR_XBYTE[ISP_SRC_CTL], OPR_XBYTE[ISP_DGAIN_L]);
#endif	
}



void UartCmd_Set_ExpTime(char* szParam)
{
#if 0
    unsigned int mSec;

    sscanfl( szParam, "%d ",&mSec);
	
	//ISP_IF_SNR_SetExpTime( (mSec<<16) );

	ISP_IF_SNR_SetExpTime( (mSec*65536/1000) );


	//
	//mSec = ISP_IF_AE_GetExpTime();
	//mSec >>= 16;
	//

	//printc( "Set Exp time to %d mSec\n", mSec );
#endif	
}

void UartCmd_Get_ExpTime(char* szParam)
{
#if 0
    unsigned int mSec;

	mSec = ISP_IF_AE_GetExpTime();
	mSec >>= 16;

	printc( "Exp time = %d mSec\n", mSec );
#endif	
}



void UartCmd_Set_AE_AGain(char* szParam)
{
#if 0
    unsigned int gain;

    sscanfl( szParam, "%d ",&gain);

	/*
	if( gain < 1 )
	{
		gain = 1;
	}
	else if( gain > 8 )
	{
		gain = 8;
	}	

	gain <<= 16;
	*/
	gain = (gain*ISP_IF_AE_GetAGainBase())/1000;
	//
	printc( "Input gain =  %d * 1000 \n", gain );

	ISP_IF_AE_SetAGain( gain );
	
	ISP_IF_SNR_SetAnalogGain( ISP_IF_AE_GetAGain() );


	//
	gain = ISP_IF_AE_GetAGain();
	//gain >>= 16;
	//

	printc( "Set AE AGain to %d \n", gain );
#endif	
}


void UartCmd_Set_AE_DGain(char* szParam)
{
#if 0	
	unsigned int gain;

    sscanfl( szParam, "%d ",&gain);

	gain = (gain*65536)/1000;

	ISP_IF_AE_SetSensorDigitalGain(gain);
	
	//printc( "Input gain =  %d \n", gain );

	//gAEConfig.SensorDGain = gain;
	
	ISP_IF_SNR_SetDigitalGain( gain );

	gain = ISP_IF_AE_GetSensorDigitalGain();

	printc( "Set AE DGain to %d \n", gain );
#endif	
}

//manual
void UartCmd_Set_AE_Manual_AGain(char* szParam)
{
#if 0
    unsigned int gain;

    sscanfl( szParam, "%d ",&gain);

#if 0
	/*
	if( gain < 1 )
	{
		gain = 1;
	}
	else if( gain > 8 )
	{
		gain = 8;
	}	

	gain <<= 16;
	*/
	gain = (gain*65536)/1000;
#endif

	// gain = gain*AE_AGAIN_1X;
	if(gain < AE_AGAIN_MIN)
		gain = AE_AGAIN_MIN;
	else if(gain > AE_AGAIN_MAX)
		gain = AE_AGAIN_MAX;

	printc( "Input gain =  %d \n", gain );

	//ISP_IF_AE_SetAGain( gain );
	ISP_IF_AE_SetManualSensorAGain( gain );
	
	//ISP_IF_SNR_SetAnalogGain( ISP_IF_AE_GetAGain() );

	gain = ISP_IF_AE_GetManualSensorAGain();
	//gain >>= 16;
	printc( "Set AE AGain to %d \n", gain );
#endif	
}

void UartCmd_Set_AE_Manual_DGain(char* szParam)
{	
#if 0
	unsigned int gain;

    sscanfl( szParam, "%d ",&gain);

	//gain = (gain*65536)/1000;
	// gain = gain*AE_DGAIN_1X;
	if(gain < AE_DGAIN_MIN)
		gain = AE_DGAIN_MIN;
	else if(gain > AE_DGAIN_MAX)
		gain = AE_DGAIN_MAX;
		
	printc( "Input gain =  %d \n", gain );

	//gAEConfig.SensorDGain = gain;
	//ISP_IF_SNR_SetDigitalGain( gain );
	ISP_IF_AE_SetManualSensorDGain( gain );

	gain = ISP_IF_AE_GetManualSensorDGain();

	printc( "Set AE DGain to %d \n", gain );
#endif	
}

void UartCmd_Set_AE_Manual_ExpTime(char* szParam)
{
#if 0
    unsigned int mSec;

    sscanfl( szParam, "%d ",&mSec);
	
	// ISP_IF_AE_SetManualExpTime( (mSec<<16) );
	ISP_IF_AE_SetManualExpTime( mSec );

	//ISP_IF_SNR_SetExpTime( (mSec*65536/1000) );
	//
	mSec = ISP_IF_AE_GetManualExpTime();
	//mSec >>= 16;
	//
	printc( "Set Manual Exp time to %d mSec\n", mSec );
#endif	
}

void UartCmd_Get_AE_Manual_ExpTime(char* szParam)
{
#if 0
    unsigned int mSec;

	mSec = ISP_IF_AE_GetManualExpTime();
	printc( "Manual Exp time = %d mSec\n", mSec );
	mSec >>= 16;
	printc( "Manual Exp time = %d mSec\n", mSec );
#endif	
}
//manual end

void UartCmd_Get_AE_MaxSvType(char* szParam)
{
#if 0
    unsigned int type;

	type = ISP_IF_AE_GetMaxSvType();
	printc( "AE Maximum Sv type = %d \n", type );
#endif	
}

void UartCmd_Set_AE_MaxSvType(char* szParam)
{
#if 0
    unsigned int type,ori_type;

    sscanfl( szParam, "%d ",&type);
	ori_type = ISP_IF_AE_GetMaxSvType();
	ISP_IF_AE_SetMaxSvType(type);
	//ISP_IF_IQ_UpdateInputSize(); // just to reset AE
	printc( "AE Maximum Sv type is from %d to %d \n", ori_type, type );
#endif	
}

void UartCmd_Get_AE_GGainParm(char* szParam)
{
#if 0 //Rogers:***
	unsigned int curEn;
	curEn = ISP_IF_AE_GetGammaGain(ISP_AE_GGAIN_ADJU_EN);
	printc( "Current GGain en =%d\n", curEn);
#endif	
}

void UartCmd_Set_AE_GGainParm(char* szParam)
{
#if 0 //Rogers:***
	unsigned int curEn,tarEn;
	sscanfl( szParam, "%d ",&tarEn);

	curEn = ISP_IF_AE_GetGammaGain(ISP_AE_GGAIN_ADJU_EN);
	ISP_IF_AE_SetGammaGain(ISP_AE_GGAIN_ADJU_EN,tarEn);
	
	printc( "AE GGain en is from %d to %d\n", curEn,tarEn);
#endif	
}


void UartCmd_Motor_Init(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_Initialize();

	printc( "Set Motor Init\n");
#endif
}

void UartCmd_Motor_Forward(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_ZoomStart(0 );

	printc( "Set Motor Forward\n");
#endif
}

void UartCmd_Motor_Backward(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_ZoomStart(1);

	printc( "Set Motor Backward\n");
#endif
}

void UartCmd_Motor_Stop(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_ZoomStop();

	printc( "Set Motor Stop\n");
#endif
}

void UartCmd_Zoom_Home(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_ZoomHome();

	printc( "Set Zoom Home\n");
#endif
}

void UartCmd_Focus_Home(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_FocusHome();

	printc( "Set Focus Home\n");
#endif
}

void UartCmd_Focus_Stop(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_FocusStop();

	printc( "Set Focus Stop\n");
#endif
}

void UartCmd_ZoomMotor_Selftest(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_ZoomSelftest();

	printc( "Set Zoom Motor test\n");
#endif
}

void UartCmd_ZoomMotor_Burnin(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_ZoomCalibration();
#endif
}

void UartCmd_FocusMotor_Selftest(char* szParam)
{
#if 0	// TY Miao - TBD
    FuncMotorCtrl_FocusSelftest();

	printc( "Set Focus Motor test\n");
#endif
}

void UartCmd_Motor_SetAF(char* szParam)
{
#if 0
    int tarPos, currentPos, filter=0, wnd=4, acc[3];

    sscanfl( szParam, "%d ",&tarPos);

	currentPos = FuncMotorCtrl_FocusGetPosition();

//	ISP_IF_AF_SetPos(tarPos);
//	ISP_IF_MOTOR_GoToAFPos();
    printc("Current Pos: %d\n",currentPos);

    if(0 == FuncMotorCtrl_FocusReady())
    FuncMotorCtrl_FocusSetPosition(tarPos);

	for(filter=0; filter<3; ++filter)
	{
		acc[filter] = ISP_IF_AF_GetAccByWnd(wnd, filter);
	}
	printc("AF ACC Wnd[%d] (High,Low,Lumi) = (%7d,%9d,%9d)\n", wnd, acc[0], acc[1], acc[2]);

	printc( "AF motor move from %d to %d\n", currentPos, tarPos);
#endif	
}


void UartCmdMotorStatus( char* szParam )
{
#if 0	// TY Miao - TBD
    MMP_UBYTE val = 0;
    val = FuncMotorCtrl_FocusReady();
    printc("focus status: %d\n",val);
#endif
}

extern MMP_BOOL FuncMotorCtrl_FocusExcitationCtrl(MMP_BOOL bEnable);

void
UartCmdMotorExciteCtrl( char* szParam )
{
#if 0
    MMP_ULONG uiValue;

	sscanfl( szParam, "%d", &uiValue );

	if(0 == uiValue)
        ISP_IF_MOTOR_SetFocusExcite(MMP_FALSE);
    else
        ISP_IF_MOTOR_SetFocusExcite(MMP_TRUE);
	#if 0
	if(0 == uiValue)
        FuncMotorCtrl_FocusExcitationCtrl(MMP_FALSE);
    else
        FuncMotorCtrl_FocusExcitationCtrl(MMP_TRUE);
	#endif
#endif	
}

void UartCmd_Media_Switch(char* szParam)
{
	printc("Switch Media Path\n");
	AHC_SwitchMediaPath();
	
}

#define AIT_BOOT_HEADER_ADDR     0x106200
#define DEAULT_SETTING_ADDR		 0x4C00000
void UartCmd_NAND_Operation(char* szParam)
{
	AIT_STORAGE_INDEX_TABLE* pAit_boot_header = (AIT_STORAGE_INDEX_TABLE *)AIT_BOOT_HEADER_ADDR;
	unsigned char command;
	unsigned char sector;
	sscanfl( szParam, "%d %d",&command,&sector);
	if(command)
	{
		printc("ReadSector\n");
		printc("sector : 0x%x\n",sector);
		//MMPF_STORAGE_DevRead(0,3,pAit_boot_header->it[13].ulStartSec,pAit_boot_header->it[13].ulSecSize,(void *)DEAULT_SETTING_ADDR);
		MMPF_STORAGE_DevRead(0,3,0,pAit_boot_header->it[13].ulSecSize,(void *)DEAULT_SETTING_ADDR);
	}
	else
	
	{
		printc("WriteSector\n");
		printc("sector : 0x%x\n",sector);
		MMPF_STORAGE_DevWrite(0, 3, 0, pAit_boot_header->it[14].ulSecSize,(void *)DEAULT_SETTING_ADDR);
	}
	
	
}

void UartCmd_PlaySound_Operation(char* szParam)
{
	unsigned char soundtype,path;
	sscanfl( szParam, "%d %d",&soundtype,&path);
	AHC_PlaySoundEffect(soundtype);
	
	
}
void UartCmd_LoadSound_Operation(char* szParam)
{
	AHC_LoadSoundEffect();
}
void UartCmd_SetAudioVolun_DB_Operation(char* szParam)
{
	UINT32 Orivolume,Aftervolume,again,dgain;
	sscanfl( szParam, "%d %x %x,",&Aftervolume,&again,&dgain);
	Orivolume = 0;
	AHC_GetParam(PARAM_ID_AUDIO_VOLUME_DB,&Orivolume);
	AHC_SetParam(PARAM_ID_AUDIO_VOLUME_DB,Aftervolume);
	if(Aftervolume > 96)
	{
		printc("The SW volume ranges from 0dB to 96dB!\r\n");
		Aftervolume = 96;
	}
	printc("Change SW volume from %d dB to %d dB\n",Orivolume, Aftervolume);	
	MMPS_AUDIO_SetPlayVolumeDb(Aftervolume);
	printc("Change HW A gain to 0x%x\n",again); //Total 1 bytes 4bits for left/right each.
	MMPS_AUDIO_SetPlayAnalogGain(again);   //mute, -42, -36,-30,-26,-22,-18,-14,-10,-6,-4,-2,0,2,4,6 
	printc("Change HW D gain to 0x%x\n",dgain); //6'b 111111~100000 0.5dB per step 0~-15.5dB
	MMPS_AUDIO_SetPlayDigitalGain(dgain);  //6'b 011111~000001 1dB per step -16~46dB 000000: mute 
	
}

void UartCmd_Init_ISP_Value_Operation(char* szParam)
{
	AHC_PARAM_ISP_Init();
}
void UartCmd_Write_ISP_Value_Operation(char* szParam)
{
	AHC_PARAM_ISP_Write(0); //0:Factory 1:User
}
void UartCmd_Read_ISP_Value_Operation(char* szParam)
{	
	AHC_ISP_PARAM *readback;
	AHC_PARAM_ISP_Read(readback,0);
}
void UartCmd_Write_Menu_Value_Operation(char* szParam)
{
	UINT32 path;
	sscanfl( szParam, "%d ",&path);
	AHC_PARAM_Menu_Write(path); //0:Factory Fat
								//1:Factory Raw
								//2:User Fat
								//3:User Raw
}
void UartCmd_Read_Menu_Value_Operation(char* szParam)
{	
	UINT32 path;
	MenuInfo *readback= (MenuInfo *)0x4000000;
	sscanfl( szParam, "%d ",&path);
	AHC_PARAM_Menu_Read((UINT8*)readback,path); //0:Factory Fat
										//1:Factory Raw
										//2:User Fat
										//3:User Raw
	ListAllMenuSetting(readback);
}
void UartCmd_Write_Saturate_Center(char* szParam)
{
    INT16 center;
    sscanfl( szParam, "%d ",&center);
    AHC_SetColorSaturateCenter(center);
}
void UartCmd_Write_Saturate_Level(char* szParam)
{
    INT16 val;
    INT32 ret;
    sscanfl( szParam, "%d ",&val);
    ret = AHC_SetColorSaturateLevel(val);
    if (ret != 0)
    printc("MMP_SENSOR_ERR_PARAMETER");
}
void UartCmd_Write_Sharpness_Center(char* szParam)
{
    INT16 center;
    sscanfl( szParam, "%d ",&center);
    AHC_SetColorSharpnessCenter(center);
}
void UartCmd_Write_Sharpness_Level(char* szParam)
{
    INT16 val;
    INT32 ret;
    sscanfl( szParam, "%d ",&val);
    ret = AHC_SetColorSharpnessLevel(val);
    if (ret != 0)
    printc("MMP_SENSOR_ERR_PARAMETER");
}
void UartCmd_Write_Gamma_Center(char* szParam)
{
    INT16 center;
    sscanfl( szParam, "%d ",&center);
    AHC_SetColorGammaCenter(center);
}
void UartCmd_Write_Gamma_Level(char* szParam)
{
    INT16 val;
    INT32 ret;
    sscanfl( szParam, "%d ",&val);
    ret = AHC_SetColorGammaLevel(val);
    if (ret != 0)
    printc("MMP_SENSOR_ERR_PARAMETER");
}
void UartCmd_Write_Contrast_Center(char* szParam)
{
    INT16 center;
    sscanfl( szParam, "%d ",&center);
    AHC_SetColorContrastCenter(center);
}
void UartCmd_Write_Contrast_Level(char* szParam)
{
    INT16 val;
    INT32 ret;
    sscanfl( szParam, "%d ",&val);
    ret = AHC_SetColorContrastLevel(val);
    if (ret != 0)
    printc("MMP_SENSOR_ERR_PARAMETER");
}
void UartCmd_Create_Factory_Settings_Operation(char* szParam)
{	
	UINT32 type;
	sscanfl( szParam, "%d ",&type);
	//AHC_SwitchMediaPath();	
	AHC_FormatStorageMedia(5);
	AHC_FormatStorageMedia(6);	
#if 0	// TY Miao - TBD
	FactoryMenuClear();

	if(type == 0) // Use curent Settings as Factory Setting
	{
		Save2FactorySetting();
	}
	else if(type ==1 ) //
	{
		FactoryMenuSettingInit(); //Use default Factory Setting
	}	
#endif

	AHC_PARAM_Menu_Write(0);
	//AHC_SwitchMediaPath();
}

void UartCmd_ReadNAND_Operation(char* szParam)
{		
	printc("Not support ReadNand operation\r\n");
	#if 0
	MMPF_NAND_ReadSector(0x4C00000,1,0xff);
	#endif
}
void UartCmd_WriteNAND_Operation(char* szParam)
{	
	printc("Not support WriteNand operation\r\n");
	#if 0
	unsigned char i,table[255];
	for(i = 0;i<0xFF;i++)
	table[i] = i;
	MMPF_NAND_WriteSector((int)table,1, 0xff);
	#endif
}
void UartCmd_SetLCDBrightness_Operation(char* szParam)
{
	UINT8 brightness;
	sscanfl( szParam, "%d,",&brightness);
	AHC_LCD_SetBrightness(brightness);
	printc("Set LCD brightness : %d\r\n",brightness);
}
void UartCmd_SetLCDContrast_Operation(char* szParam)
{
	UINT8 contrast;
	sscanfl( szParam, "%d,",&contrast);
	AHC_LCD_SetContrast(contrast);
	printc("Set LCD contrast : %d\r\n",contrast);
}
void UartCmd_SetLCDContrast_R_Operation(char* szParam)
{
	UINT8 contrast;
	sscanfl( szParam, "%d,",&contrast);
	AHC_LCD_SetContrast_R(contrast);
	printc("Set LCD contrast R : %d\r\n",contrast);
}
void UartCmd_SetLCDBrightness_R_Operation(char* szParam)
{
	UINT8 brightness;
	sscanfl( szParam, "%d,",&brightness);
	AHC_LCD_SetBrightness_R(brightness);
	printc("Set LCD Brightness R : %d\r\n",brightness);
}
void UartCmd_SetLCDContrast_B_Operation(char* szParam)
{
	UINT8 contrast;
	sscanfl( szParam, "%d,",&contrast);
	AHC_LCD_SetContrast_B(contrast);
	printc("Set LCD contrast B : %d\r\n",contrast);
}
void UartCmd_SetLCDBrightness_B_Operation(char* szParam)
{
	UINT8 brightness;
	sscanfl( szParam, "%d,",&brightness);
	AHC_LCD_SetBrightness_B(brightness);
	printc("Set LCD Brightness B : %d\r\n",brightness);
}
void UartCmd_LCD_Direction_Operation(char* szParam)
{
	AHC_BOOL invert;
	sscanfl( szParam, "%d,",&invert);
	AHC_LCD_Direction(invert);
	printc("invert LCD panel : %d\r\n",invert);
}
void UartCmd_WriteLCDReg_Operation(char* szParam)
{
	UINT32 reg;
	UINT8  value;
	sscanfl( szParam, "%X %X,",&reg,&value);
	AHC_LCD_Write_Reg(reg,value);
}
void UartCmd_SetRTCValue_Operation(char* szParam)
{	
    UINT16 uwYear,uwMonth,uwDay,uwDayInWeek,uwHour,uwMinute,uwSecond;
    UINT8 ubAmOrPm, b_12FormatEn;
	AHC_BOOL success;

    uwDayInWeek = 0;
    ubAmOrPm = 0;
    b_12FormatEn = 0;
    
	sscanfl( szParam, "%d %d %d %d %d %d,",&uwYear,&uwMonth,&uwDay,&uwHour,&uwMinute,&uwSecond);
	AHC_SetParam(PARAM_ID_USE_RTC,1);
	success = AHC_SetClock(uwYear,  uwMonth,  uwDay, uwDayInWeek, uwHour,  uwMinute,  uwSecond, ubAmOrPm, b_12FormatEn);
	if(success)
	{
		printc("Set RTC time yy/mm/dd h:min:sec: %d/%d/%d/ %d:%d:%d\r\n",uwYear,uwMonth,uwDay,uwHour,uwMinute,uwSecond);
	}
	else
	{
		printc("RTC Setting Fail!\r\n");
	}
	
}
void UartCmd_GetRTCValue_Operation(char* szParam)
{
    UINT16 uwYear,uwMonth,uwDay,uwDayInWeek,uwHour,uwMinute,uwSecond;
    UINT8 ubAmOrPm, b_12FormatEn;
    AHC_BOOL success;

    AHC_SetParam(PARAM_ID_USE_RTC,1);    
    success = AHC_GetClock( &uwYear, &uwMonth, &uwDay, &uwDayInWeek, &uwHour, &uwMinute, &uwSecond, &ubAmOrPm, &b_12FormatEn);

    if(success)
    {
        printc("Get RTC time yy/mm/dd h:min:sec: %d/%d/%d %d:%d:%d\r\n",uwYear,uwMonth,uwDay,uwHour,uwMinute,uwSecond);
    }
    else
    {
        printc("Get RTC value Fail!\r\n");
    }

}
void UartCmd_AF_Inf_Pos_Cali(char* szParam)
{
#if 0
	PLCali_AF_Inf_Pos();
#endif	
}

void UartCmd_AEAWB_Cali(char* szParam)
{
#if 0
	// load LS CS tables for following calibration~~
	PLCali_LSCS_SetFromSD();
	
	// for high temperature AWB rgb average
	PLCali_AWB_GetRgbAve(1);

	PLCheck_AE();
#endif		
}

void UartCmd_AWBHiLo_Cali(char* szParam)
{
#if 0
	// load LS CS tables for following calibration~~
	PLCali_LSCS_SetFromSD();

	// for low temperature AWB rgb average
	PLCali_AWB_GetRgbAve(0);

	// to generate AWB calibration data
	PLCali_AWB_CalcData();

	// write result to ISP.bin
	PLCali_ReadCaliBinToFlash(0);
#endif		
}

void UartCmd_AWBCalcData(char* szParam)
{
#if 0
	// to generate AWB calibration data
	PLCali_AWB_CalcData();
#endif	
}

void UartCmd_GetAWBXY_Cali(char* szParam)
{
#if 0
	int mode;
	ISP_INT32 pxy[2];

	sscanfl( szParam, "%d",&mode);
	ISP_IF_AWB_CaliLineAdjXyMeasurement(pxy);

	if(mode == 0)
		DramToFile("SD:\\CaliAwbRefCamXY0.bin",(INT8*)pxy,sizeof(ISP_INT32)*2);
	else
		DramToFile("SD:\\CaliAwbRefCamXY1.bin",(INT8*)pxy,sizeof(ISP_INT32)*2);

	printc("AWB cali mode:%d (X,Y)=(%d,%d) \n",mode,pxy[0],pxy[1]);
#endif	
}

void UartCmd_GetAWBRgb_Cali(char* szParam)
{
#if 0
	int mode;

	sscanfl( szParam, "%d",&mode);
	PLCali_AWB_GetRgbAve(mode);
#endif	
}


void UartCmd_LSCS_Cali(char* szParam)
{
#if 0
	PLCali_LSCS();
#endif
}

void UartCmd_LSCS_Raw(char* szParam)
{
#if 0
	PLCali_LSCS_Raw();
#endif
}

void UartCmd_ISPModuleSwitch(char* szParam)
{
#if 0
	int module, enable, ori_mode;
	sscanfl( szParam, "%d %d",&module,&enable);

	ori_mode = ISP_IF_IQ_GetSwitch(module);

	ISP_IF_IQ_SetSwitch(module,enable);
	
	printc("isp module: %d is switched from %d to %d \n",module,ori_mode,enable);
#endif	
}

void UartCmd_SDCTest(char* szParam)
{
#if 0
	int xpos[1]={0};
	int ypos[1]={0};

	ISP_IF_R_SetStaticDefectPos(1,xpos,ypos);
	
	printc("SDC test enable \n");
#endif	
}

void UartCmd_ISP_Get_ID(char* szParam)
{
#if 0
	ISP_UINT32 gid,eid,tid,shutter,again,isp_dgain,snr_dgain,exptime;
	
	gid = ISP_IF_IQ_GetID(0);
	eid = ISP_IF_IQ_GetID(1);
	tid = ISP_IF_IQ_GetID(2);
	printc( "gid = %d\teid= %d\ttid= %d\n", gid,eid,tid );
	
	shutter   = ISP_IF_AE_GetShutter();
	again     = ISP_IF_AE_GetAGain();
	isp_dgain = ISP_IF_AE_GetDGain();
	snr_dgain = ISP_IF_AE_GetSensorDigitalGain();
	exptime   = ISP_IF_AE_GetExpTime();
	
	//printc( "Shutter = %d\tAGain= %d\tISP_DGain = %d\tExptime = %d\tSensor_Dgain = %d\tGGain = %d\n", shutter,again,isp_dgain,exptime,snr_dgain,ISP_IF_AE_GetGammaGain(ISP_AE_GGAIN_CURRUSED));
#endif
}

void UartCmd_AE_Cali(char* szParam)
{
#if 0
	PLCali_AE();
#endif
}

void UartCmd_AE_MinGainChk(char* szParam)
{
#if 0
	PLCheck_AE();
#endif
}

void UartCmd_LSCS_SetFromSD(char* szParam)
{
#if 0
	PLCali_LSCS_SetFromSD();
#endif
}

void UartCmd_Raw_beforeISP(char* szParam)
{
#if 0 
	int mode;
	sscanfl( szParam, "%d",&mode);
	
	CaptureRaw(mode,"SD:\\aitRaw.raw");
#endif	
}

void UartCmd_Raw_AfterCS(char* szParam)
{
#if 0
	int mode, IsTransfer16Bits;
	sscanfl( szParam, "%d %d",&mode,&IsTransfer16Bits);
	
	CaptureRaw_LsCsOn(mode,"SD:\\aitAfterCsRaw",IsTransfer16Bits);
#endif	
}

void UartCmd_SetContrast(char* szParam)
{
#if 0
	int level;
	sscanfl( szParam, "%d",&level);
	
	ISP_IF_F_SetContrast(level);
	
	level = ISP_IF_F_GetContrast();
	
	printc("contrast level set to %d\n",level);
#endif	
}

void UartCmd_GetContrast(char* szParam)
{
#if 0
	printc("contrast level is %d\n",ISP_IF_F_GetContrast());
#endif

}

void UartCmd_SetSharpness(char* szParam)
{
#if 0
	int level;
	sscanfl( szParam, "%d",&level);
	
	ISP_IF_F_SetSharpness(level);
	
	level = ISP_IF_F_GetSharpness();
	
	printc("contrast level set to %d\n",level);
#endif	
}

void UartCmd_GetSharpness(char* szParam)
{
#if 0
	printc("contrast level is %d\n",ISP_IF_F_GetSharpness());
#endif
}

void UartCmd_GetJPG(char* szParam)
{
#if 0	// TY Miao - TBD
	SetKeyPadEvent(KEYPAD_S09_PRESS);	//use keypad 9
#endif
}

void UartCmd_SetCancelFlickMode(char* szParam)
{
#if 0
	int enable;
	sscanfl( szParam, "%d",&enable);
	
	ISP_IF_AE_SetCancelFlickerMode(enable);
	
	enable = ISP_IF_AE_GetCancelFlickerMode();
	
	printc("CancelFlickerMode set to %d\n",enable);
#endif	
}

void UartCmd_GetCancelFlickMode(char* szParam)
{
#if 0
	int enable;
	
	enable = ISP_IF_AE_GetCancelFlickerMode();
	
	printc("CancelFlickerMode set to %d\n",enable);
#endif	
}

void UartCmd_CheckCaliBin(char* szParam)
{
#if 0
	char tmp_char[128];
	sscanfl( szParam, "%s",tmp_char);

	PLCali_CheckCaliBin(tmp_char);
#endif
}

void UartCmd_ReadCaliBinToSD(char* szParam)
{
#if 0
	PLCali_ReadCaliBinToFlash(0);
#endif
}

void UartCmd_ReadCaliBinToFlash(char* szParam)
{
#if 0
	PLCali_ReadCaliBinToFlash(1);
#endif
}

void UartCmd_ResetCaliBinToFlash(char* szParam)
{
#if 0
	PLCali_ResetCaliBinToFlash();
#endif
}


void UartCmd_AF_GetResult(char* szParam)
{
	ISP_AF_RESULT result;

	result = ISP_IF_AF_GetResult();
	printc("AF result is %d\n", result);
}

void UartCmd_AWB_GetRGB_Gain_WhiteBlkCnt(char* szParam)
{
#if 0
	printc( "awb GainR = %d\n", ISP_IF_AWB_GetGainR() );
	printc( "awb GainGr = %d\n", ISP_IF_AWB_GetGainG() );
	printc( "awb GainB = %d\n", ISP_IF_AWB_GetGainB() );
	printc( "awb white block count = %d\n", ISP_IF_AWB_GetWhiteBlockCount() );
#endif	
}

void UartCmd_AF_GetStillafPos(char* szParam)
{
#if 0
	int stillcnt;
	sscanfl( szParam, "%d,",&stillcnt);
	PLCali_AF_GetStillafPos(stillcnt);
#endif	
}

void UartCmd_ADX2003_ADC_Measure_Lens_Temp(char* szParam)
{
	#if(ADX2003_EN)
	MMP_ULONG level = 0;
	MMP_UBYTE  source = 0;
	MMP_ERR		status;
	status = ADX2003_ADC_Measure_Lens_Temp(&level, &source);
	printc("level(voltage) : %d mVolt, status=%d\n",level,status);
	#else
	#endif
}

void
UartCmdSetDebugLevel( char* szParam )
{
	extern	MMP_ULONG	dbg_level;
    MMP_ULONG uiValue;

	sscanfl( szParam, "%d", &uiValue );

	dbg_level = uiValue;

}

void UartCmdSetDebugBreak( char* szParam )
{
	extern	MMP_ULONG	gubMmpDbgBk;
    MMP_ULONG uiValue;

	sscanfl( szParam, "%d", &uiValue );

	gubMmpDbgBk = uiValue;
    AHC_SetDbgBreak(uiValue);
    printc(FG_YELLOW("Debug Break[EN/DIS:1/0]=%d\n"),gubMmpDbgBk);

}

void UartCmdGetDebugBreak( char* szParam )
{
	extern	MMP_ULONG	gubMmpDbgBk;
    MMP_UBYTE *ubAhcDbgBrkFg;

    AHC_GetDbgBreak(*ubAhcDbgBrkFg);
    printc(FG_YELLOW("gubMmpDbgBk=%d\n"),gubMmpDbgBk);
    printc(FG_YELLOW("ubAhcDbgBrkFg=%d\n"),*ubAhcDbgBrkFg);    

}
void
UartCmdFunctionMenu( char* szParam )
{
#if (AHC_DRAM_SIZE == COMMON_DRAM_SIZE_64MB)
#if 0//(JobDispatch_En)
	extern void FunctionMenu(void);
	
	FunctionMenu();
#endif	
#endif	
}

void
UartCmdUsbSetMode( char* szParam )
{

	int uiMode = 0;//MMPS_USB_PCSYNC_MODE;
	
	sscanfl( szParam, "%x", &uiMode);

    if( uiMode == 0xFF )
    {
        MMPS_USB_StopDevice();
        printc("StopUSBDevice\r\n");
    }
    else
    {
		MMPS_USB_SetMode(uiMode);
    	switch (uiMode)
    	{
    		case MMPS_USB_NONE_MODE:
    		printc("SetUSB_NONE_MODE\r\n");
    		break;
    		case MMPS_USB_PCCAM_MODE:
    		printc("SetUSB_UVC_MODE\r\n");
    		break;
    		case MMPS_USB_MSDC_MODE:
    		printc("SetUSB_MSDC_MODE\r\n");
    		break;
    		default:
    		printc("SetUSB_MODE\r\n");
    		break;
    	}
    }
}

#define NO_DETECT_HDMI 1
void UartCmd_HDMI(char* szParam)
{
    UINT16 uiItem;
    UINT16 uwWidth, uwHeight;
	UINT32 iVal[10];
	UINT16 uwDisplayID;
	AHC_DISPLAY_HDMIOUTPUTMODE HdmiMode;
	
	sscanfl( szParam, "%d",&uiItem);

    AHC_GetHdmiDisplayWidthHeight(&uwWidth, &uwHeight);
	printc("HDMI Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 
	
    switch(uiItem) {
    case 0: //Init
        printc("HDMI: Init\n"); 
#if  NO_DETECT_HDMI
        if(1)
#else
        if(MMPF_HDMI_IsConnect())
#endif        
        {
            printc("HDMI: connect \n"); 
            uwDisplayID = 1;
            
            AHC_OSDUninit();
            AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

            AHC_SetDisplayOutputDev(DISP_OUT_HDMI, AHC_DISPLAY_DUPLICATE_1X);

                        
        //Set full OSD by uwDisplayID = 0 
            AHC_GetHDMIOutputMode(&HdmiMode);
            if(HdmiMode == AHC_DISPLAY_HDMIOUTPUT_1920X1080I){
                AHC_OSDInit(	uwWidth/2,
                				uwHeight,
                				uwWidth/2,
                				uwHeight,
                				PRIMARY_DATESTAMP_WIDTH,
                				PRIMARY_DATESTAMP_HEIGHT,
                				THUMB_DATESTAMP_WIDTH,
                				THUMB_DATESTAMP_HEIGHT,
                				OSD_COLOR_ARGB32,
                				AHC_TRUE);
            }else{
                AHC_OSDInit(	uwWidth/2,
                				uwHeight/2,
                				uwWidth/2,
                				uwHeight,
                				PRIMARY_DATESTAMP_WIDTH,
                				PRIMARY_DATESTAMP_HEIGHT,
                				THUMB_DATESTAMP_WIDTH,
                				THUMB_DATESTAMP_HEIGHT,
                				OSD_COLOR_ARGB32,
                				AHC_TRUE);
 			}
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
			#endif
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight-1);             

   
        //Set Video OSD 240x240 by uwDisplayID = 1
            uwDisplayID = 1;
            AHC_OSDCreateBuffer(uwDisplayID ,240, 80,OSD_COLOR_ARGB32); 
            iVal[0] = (uwWidth- 240*2)/2;
            iVal[1] = 0;
            AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

            //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
            iVal[0] = 1;
            iVal[1] = 0;
            iVal[2] = 50;
            AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );
    
            AHC_OSDSetCurrentDisplay(uwDisplayID);
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(uwDisplayID,0x000000FF);
			#else
            AHC_OSDSetColor(0x000000FF);
            #endif
            AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,80-1);

        //Set Video OSD 240x240 by uwDisplayID = 16
            uwDisplayID = 16;
            AHC_OSDCreateBuffer(uwDisplayID ,240, 80,OSD_COLOR_ARGB32); 
            iVal[0] = (uwWidth- 240*2)/2;
            iVal[1] = uwHeight - 80;
            AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

            //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
            iVal[0] = 1;
            iVal[1] = 0;
            iVal[2] = 50;
            AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );
    
            AHC_OSDSetCurrentDisplay(uwDisplayID);
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(uwDisplayID, 0x00FF0000);
			#else
            AHC_OSDSetColor(0x00FF0000);
			#endif
            AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,80-1);
                
            
        }
    break;
    case 1: //HDMI: only OSD full range
        printc("HDMI: only OSD full range\n"); 
#if  NO_DETECT_HDMI
        if(1)
#else
        if(MMPF_HDMI_IsConnect())
#endif        
        {
            printc("HDMI: connect \n"); 
            uwDisplayID = 1;
            
        //Show only OSD(full by uwDisplayID = 0)
            AHC_OSDSetActive(uwDisplayID, 0);
            AHC_OSDSetCurrentDisplay(0);
            AHC_OSDSetActive(0, 1);
        }
    break;
    case 2: //HDMI: OSD + Video
        printc("HDMI: OSD + Video \n"); 
#if  NO_DETECT_HDMI
        if(1)
#else
        if(MMPF_HDMI_IsConnect())
#endif        
        {
            uwDisplayID = 1;
                  
        //Show Video+OSD(240x240 by uwDisplayID = 1)
            AHC_OSDSetActive(0, 0);
            AHC_OSDSetActive(uwDisplayID, 0); 
            AHC_OSDSetActive(16, 0);

            //VideoPBMode_Start(); 
            //VideoPBFunc_Play(); 
            AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK          

            AHC_OSDSetCurrentDisplay(uwDisplayID);
            AHC_OSDSetActive(uwDisplayID, 1); 
            
            AHC_OSDSetCurrentDisplay(16);
            AHC_OSDSetActive(16, 1); 
        }
    break;
    case 3: //HDMI: OSD + Still
        printc("HDMI: OSD + Still \n"); 
#if  NO_DETECT_HDMI
        if(1)
#else
        if(MMPF_HDMI_IsConnect())
#endif        
        {
            uwDisplayID = 1;
                  
        //Show Video+OSD(240x240 by uwDisplayID = 1)
            AHC_OSDSetActive(0, 0);
            AHC_OSDSetActive(uwDisplayID, 0); 
            AHC_OSDSetActive(16, 0);
            
#if 0	// TY Miao - TBD
            PhotoPBFunc_Start();
#endif            
            AHC_OSDSetCurrentDisplay(uwDisplayID);
            AHC_OSDSetActive(uwDisplayID, 1);  

            AHC_OSDSetCurrentDisplay(16);
            AHC_OSDSetActive(16, 1); 

            AHC_OSDRefresh();
        }
    break;
    case 4: //HDMI: change to HDMI720P mode
        printc("HDMI: change to HDMI720P mode \n"); 
        AHC_SetHDMIOutputMode(AHC_DISPLAY_HDMIOUTPUT_1280X720P);  
    break;
    case 5: //HDMI: change to HDMI1080I mode
        printc("HDMI: change to HDMI1080I mode \n");
        AHC_SetHDMIOutputMode(AHC_DISPLAY_HDMIOUTPUT_1920X1080I); 
    break;

    case 9: //Init
        printc("HDMI: LCD output\n"); 

        AHC_OSDUninit();
        AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

        MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_NONE);
        AHC_SetDisplayOutputDev(DISP_OUT_LCD, AHC_DISPLAY_DUPLICATE_1X);

        AHC_OSDInit(	320,
        				240,
						320,
        				240,
        				PRIMARY_DATESTAMP_WIDTH,
        				PRIMARY_DATESTAMP_HEIGHT,
        				THUMB_DATESTAMP_WIDTH,
        				THUMB_DATESTAMP_HEIGHT,
        				OSD_COLOR_ARGB32,
        				AHC_TRUE);


        //StateSwitchMode(AHC_MENU_BROWSER_STATE);//AHC_MENU_BROWSER_STATE
        BrowserFunc_ModeSwitch();
    break;
    }
}

void UartCmd_TV(char* szParam)
{
    UINT16 uiItem;
    UINT16 uwWidth, uwHeight;
	UINT32 iVal[10];
	UINT16 uwDisplayID;
	static UINT8 bTvOutMode = 1; //0: LCD, 1: NTSC TV, 2: PAL TV
	
	sscanfl( szParam, "%d",&uiItem);
    
    switch(uiItem) {
    case 0: //TV-out: Init
        printc("TV-out: Init\n"); 

        AHC_OSDUninit();
        AHC_SetMode( 0x00 ); //AHC_MODE_IDLE
        switch (bTvOutMode) {
        case 0:
            #if 0
            AHC_SetDisplayOutputDev(DISP_OUT_LCD, AHC_DISPLAY_DUPLICATE_1X);
            AHC_OSDInit(	uwWidth,
            				uwHeight,
            				uwWidth,
            				uwHeight,
            				PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,
            				OSD_COLOR_ARGB32,AHC_TRUE);
       
            AHC_OSDSetColor(0x0000FF00);
            AHC_OSDDrawFillRect(0,0,0,uwWidth-1,uwHeight-1);             
            
        //BrowserFunc_ModeSwitch();
            #endif
        break;
        case 1:
            AHC_SetDisplayOutputDev(DISP_OUT_TV_NTSC, AHC_DISPLAY_DUPLICATE_1X);
            AHC_GetNtscTvDisplayWidthHeight(&uwWidth, &uwHeight);
	        printc("TV Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 

	        AHC_OSDInit(	uwWidth/2,
	        				uwHeight/2,
	        				uwWidth/2,
	        				uwHeight/2,
	        				PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,
	        				OSD_COLOR_ARGB32,
	        				AHC_TRUE);
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
            #endif
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight/2-1);   
        break;
        case 2:
            AHC_SetDisplayOutputDev(DISP_OUT_TV_PAL, AHC_DISPLAY_DUPLICATE_1X);
            AHC_GetNtscTvDisplayWidthHeight(&uwWidth, &uwHeight);
        	printc("TV Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 

        	AHC_OSDInit(   uwWidth/2,
                            uwHeight/2,
                            uwWidth/2,
                            uwHeight/2,
        					PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,
            				OSD_COLOR_ARGB32,
            				AHC_TRUE);

			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
            #endif
            
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight/2-1);              	
        break;
        }
        
    //Set Video OSD 240x240 by uwDisplayID = 16
        uwDisplayID = 16;
        AHC_OSDCreateBuffer(uwDisplayID ,240, 80,OSD_COLOR_ARGB32); 
        iVal[0] = (uwWidth- 240*2)/2;
        iVal[1] = uwHeight - 80;
        AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

        //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
        iVal[0] = 1;
        iVal[1] = 0;
        iVal[2] = 50;
        AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );

        AHC_OSDSetCurrentDisplay(uwDisplayID);
		#ifdef ENABLE_GUI_SUPPORT_MULTITASK
        AHC_OSDSetColor(uwDisplayID, 0x00FF0000);
		#else
        AHC_OSDSetColor(0x00FF0000);
        #endif
        AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,80-1);      
    break;
    case 1: //TV-out: only OSD full range
        printc("TV-out: only OSD full range\n"); 
            
        //Show only OSD(full by uwDisplayID = 0)
        uwDisplayID = 1;
        AHC_OSDSetActive(uwDisplayID, 0);
        AHC_OSDSetCurrentDisplay(0);
        AHC_OSDSetActive(0, 1);
    break;
    case 2: //TV-out: OSD + Video
        printc("TV-out: OSD + Video \n"); 
           
        //Show Video+OSD(240x240 by uwDisplayID = 1)
        AHC_OSDSetActive(0, 0);
        uwDisplayID = 16;
        AHC_OSDSetActive(uwDisplayID, 0);

        //VideoPBMode_Start(); 
        //VideoPBFunc_Play(); 
        AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK          

        //AHC_OSDSetCurrentDisplay(uwDisplayID);
        //AHC_OSDSetActive(uwDisplayID, 1);  
    break;
    case 3: //TV-out: OSD + Still
        printc("TV-out: OSD + Still \n"); 

       //Show Video+OSD(240x240 by uwDisplayID = 1)
        AHC_OSDSetCurrentDisplay(0);
        AHC_OSDSetActive(0, 0);
        uwDisplayID = 16;
        AHC_OSDSetCurrentDisplay(uwDisplayID);
        AHC_OSDSetActive(uwDisplayID, 0); 
        
#if 0	// TY Miao - TBD
        PhotoPBFunc_Start();
#endif

        //AHC_OSDSetCurrentDisplay(uwDisplayID);
        //AHC_OSDSetActive(uwDisplayID, 1);  
        
        //AHC_OSDRefresh();

        #if 0
        //Dump Display Register
        {
            MMP_ULONG uiAddress;
            MMP_UBYTE uiValue;
            MMP_ULONG i; 
            
            uiAddress = 0x80007000;
            for(i=0; i<0x400; i++) {
                uiValue = *(MMP_UBYTE*)(uiAddress+i);
                printc("Reg0x%X = 0x%X\r\n", uiAddress+i, uiValue);
            }                    
        }
        #endif
    break;
    case 4: //TV-out: change to NTSC mode
        printc("TV-out: change to NTSC mode \n"); 
        bTvOutMode = 1;
        MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_NTSC_TV);  
    break;
    case 5: //TV-out: change to PAL mode
        printc("TV-out: change to PAL mode \n");
        bTvOutMode = 2;
        MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_PAL_TV);  
    break;

    case 9: //TV-out: LCD output
        printc("TV-out: LCD output\n"); 
        //bTvOutMode = 0;
        AHC_OSDUninit();
        AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

        //MMPS_Display_SetOutputPanel(MMP_DISPLAY_PRM_CTL, MMP_DISPLAY_SEL_NONE);
        AHC_SetDisplayOutputDev(DISP_OUT_LCD, AHC_DISPLAY_DUPLICATE_1X);

        AHC_OSDInit(   320,
                        240,
						320,
                        240,
                        PRIMARY_DATESTAMP_WIDTH,
            			PRIMARY_DATESTAMP_HEIGHT,
            			THUMB_DATESTAMP_WIDTH,
            			THUMB_DATESTAMP_HEIGHT,
            			OSD_COLOR_ARGB32,
            			AHC_TRUE);


        //StateSwitchMode(AHC_MENU_BROWSER_STATE);//AHC_MENU_BROWSER_STATE
        BrowserFunc_ModeSwitch();
    break;
    }
}


#if defined(MSB2531_CMD_CTRL)&&(MSB2531_CMD_CTRL == 1)
void UartCmd_MSB2531_SwMode(char* szParam)
{
	printc("%s:szParam=%d\n",__func__,szParam[0]);
}
#endif

void SleepSec(MMP_ULONG sec){
    MMP_ULONG i;
    
    for(i=0;i<sec;i++)
        MMPF_OS_Sleep_MS(1000);
}

// copy from AHC_BOOL AHC_PlaySoundEffect(AHC_SOUNDEFFECT_SHUTTER)
AHC_BOOL PlayWavFile1(void)
{
    	
	MMPS_AUDIO_FILEINFO	fileinfo;
	MMPS_AUDIO_WAV_INFO	wavinfo; 
    MMP_ERR 			mmps_status;
    UINT32 				value;
	UINT8				ubSoundEffectStatus = 0;
	UINT32				ulDacStatus = 0;
	char         		path[256]; 
	
	AIHC_GetMovieConfig(AHC_AUD_PRERECORD_DAC, &ulDacStatus );
	if((MenuSettingConfig()->uiBeep == BEEP_OFF)||(ulDacStatus == AHC_FALSE))
	{
		return AHC_SUCCESS;
	}
	#if 0
	else if(!AHC_GetSoundEffectExist())
	{
		return AHC_FALSE;
	}
	#endif
	AHC_GetSoundEffectStatus(&ubSoundEffectStatus);
	
	if(ubSoundEffectStatus == AHC_SOUND_EFFECT_STATUS_START)
		mmps_status = MMPS_AUI_StopWAVPlay();

	STRCPY(path, "SF:0:\\");
	STRCAT(path, "Shutter.wav"); 
	
#if 1

	#if (FS_INPUT_ENCODE == UCS2)
	uniStrcpy(fileinfo.bFileName, path);
	fileinfo.usFileNameLength = uniStrlen((short *)fileinfo.bFileName);
    #elif (FS_INPUT_ENCODE == UTF8)
    STRCPY(fileinfo.bFileName, path);
	fileinfo.usFileNameLength = STRLEN(path);
	#endif
	
	MMPS_AUI_SetMediaPath(MMPS_AUI_MEDIA_PATH_CARD);
	mmps_status =MMPS_AUI_InitializeWAVPlay(&fileinfo, &wavinfo);
                   
#else // Playback streaming Mode
	fileinfo.ubBuf 		= (UINT8 *)SoundEffectFile[soundtype].ulStartAddress;
    fileinfo.ulBufSize 	= SoundEffectFile[soundtype].ulSize;	
	
	MMPS_AUI_SetMediaPath(MMPS_AUI_MEDIA_PATH_MMP_MEM);
    mmps_status =MMPS_AUI_InitializeWAVPlay(&fileinfo, &wavinfo);
    
    RTNA_DBG_Str(3, "Choose Streaming player\r\n");
#endif
		
    AHC_GetParam(PARAM_ID_AUDIO_VOLUME_DB,&value);
    
    #if (AUDIO_SET_DB == 0x1)
	MMPS_AUDIO_SetPlayVolumeDb(value);
	#else
    MMPS_AUDIO_SetPlayVolume(value, AHC_FALSE);
    #endif
	
	MMPS_AUI_StartWAVPlay();
	
	#if (SUPPORT_SPEAKER == 1)
	{
        #ifdef TV_SPEAKER_OUT_EN

        #if (SUPPORT_HDMI)
        if(HDMIFunc_GetStatus() == AHC_HDMI_NONE_STATUS)
        #else
        if(1)
        #endif
        {
            AHC_SpeakerEnable(SPEAKER_ENABLE_GPIO, AHC_TRUE);
        }
        else {
            AHC_SpeakerEnable(SPEAKER_ENABLE_GPIO, AHC_FALSE);
        }

        #else

        #if (SUPPORT_HDMI && SUPPORT_TV)
        if(HDMIFunc_GetStatus()==AHC_HDMI_NONE_STATUS && TVFunc_Status()==AHC_TV_NONE_STATUS)
        #elif ((!SUPPORT_HDMI) && SUPPORT_TV)
        if(TVFunc_Status()==AHC_TV_NONE_STATUS)
        #elif (SUPPORT_HDMI && (!SUPPORT_TV))
        if (TVFunc_Status()==AHC_TV_NONE_STATUS)
        #else
        if(1)
        #endif
        {
            AHC_SpeakerEnable(SPEAKER_ENABLE_GPIO, AHC_TRUE);
        }
        else {
            AHC_SpeakerEnable(SPEAKER_ENABLE_GPIO, AHC_FALSE);
        }

        #endif
    }
    #endif
    
    AHC_GetParam(PARAM_ID_AUDIO_VOLUME_DB,&value);
    
    #if (AUDIO_SET_DB == 0x1)
	MMPS_AUDIO_SetPlayVolumeDb(value);
	#else
    MMPS_AUDIO_SetPlayVolume(value, AHC_FALSE);
    #endif 
    
	return AHC_SUCCESS;
}
extern void TouchPanel_Reset(void);
void UartCmd_Test(char* szParam)
{
    UINT16 uiItem = 0;
    UINT16 uwWidth, uwHeight;
	UINT32 iVal[10];
	UINT16 uwDisplayID;
	
	sscanfl( szParam, "%d",&uiItem);

	
    switch(uiItem) {
    case 0: //       
        printc("t 1: DSC Capture test\n"); 
        printc("t 2: DSC Decode test\n");
        printc("t 3: VR test\n"); 
        printc("t 4: VP test\n");
        printc("t 5: USB test\n");
        printc("t 6: HDMI test\n");
		printc("t 7: TV test\n");
		printc("t 8: Video Preview LCD_TV Switch\n");
        printc("t 9: SD format\n"); 
		printc("t 10: Play wave file");
		printc("t 11: Touch Panel Reset");
        printc("t  : test all function\n");
    break;
    case 1: //DSC: Capture
        printc("DSC: Capture..."); 
        AHC_SetMode( AHC_MODE_IDLE );
        AHC_SetMode(AHC_MODE_CAPTURE_PREVIEW);
        AHC_SetMode(AHC_MODE_STILL_CAPTURE);
        printc("End\n"); 
    break;
    case 2: //DSC: Decode
        printc("DSC: Decode..."); 
        AHC_SetMode( AHC_MODE_IDLE );
        AHC_UF_SetCurrentIndex(1);
        AHC_SetMode(AHC_MODE_PLAYBACK);
        printc("End\n"); 
    break;
    case 3: //VR:Start
        printc("VR:Start..."); 
        AHC_SetMode( AHC_MODE_IDLE );
        AHC_SetMode(AHC_MODE_RECORD_PREVIEW);
        VideoFunc_Record();
        printc("End\n"); 
    break;
    case 4: //VP
        printc("VP:Start..."); 
        AHC_SetMode( AHC_MODE_IDLE ); 
        AHC_UF_SetCurrentIndex(2);
        AHC_SetMode(AHC_MODE_PLAYBACK);
        printc("End\n"); 
    break;
    case 5: //USB: MSDC
        printc("MSDC:Start..."); 
        AHC_SetMode( AHC_MODE_IDLE ); 
        AHC_SetMode(AHC_MODE_USB_MASS_STORAGE);
        printc("End\n"); 
    break;
    
    case 6: //HDMI 
        uwWidth = MMPS_Display_GetConfig()->hdmi.usDisplayWidth;
		uwHeight = MMPS_Display_GetConfig()->hdmi.usDisplayHeight;
		printc("HDMI Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 
	      
#if  NO_DETECT_HDMI
        if(1)
#else
        if(MMPF_HDMI_IsConnect())
#endif        
        {
            printc("HDMI: Init\n");
            uwDisplayID = 1;
            
            AHC_OSDUninit();
            AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

            AHC_SetDisplayOutputDev(DISP_OUT_HDMI, AHC_DISPLAY_DUPLICATE_1X);
            
            //AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK
            
        //Set full OSD by uwDisplayID = 0            
            AHC_OSDInit(   uwWidth/2,
                            uwHeight,
                            uwWidth/2,
                            uwHeight,
                            PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,
            				OSD_COLOR_ARGB32,
            				AHC_TRUE);

			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
			#endif
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight-1);
    
        //Set Video OSD 240x240 by uwDisplayID = 1
            AHC_OSDCreateBuffer(uwDisplayID ,240, 240,OSD_COLOR_ARGB32); 
            iVal[0] = uwWidth- 240*2;
            iVal[1] = uwHeight - 240;
            AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

            //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
            iVal[0] = 1;
            iVal[1] = 0;
            iVal[2] = 50;
            AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );
    
            AHC_OSDSetCurrentDisplay(uwDisplayID);
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(uwDisplayID, 0x000000FF);
			#else
            AHC_OSDSetColor(0x000000FF);
            #endif
            AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,240-1);
            MMPF_OS_Sleep(0x100);

        //Show only OSD(full by uwDisplayID = 0)
            printc("HDMI: only OSD full range..."); 
            AHC_OSDSetActive(uwDisplayID, 0);
            AHC_OSDSetCurrentDisplay(0);
            AHC_OSDSetActive(0, 1);
            MMPF_OS_Sleep(0x100);
            printc("End\n"); 

              
        //Show Video+OSD(320x240 by uwDisplayID = 1)
            printc("HDMI: OSD + Video...");  
            AHC_OSDSetActive(0, 0);
            AHC_OSDSetCurrentDisplay(1);
            AHC_OSDSetActive(uwDisplayID, 1);
            AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK 
            MMPF_OS_Sleep(0x1000);
            printc("End\n"); 
            //AHC_SetMode(0x00); //AHC_MODE_IDLE
                               
        }
    break;
    case 7: //TV
        printc("TV:Start..."); 
        uwWidth = MMPS_Display_GetConfig()->ntsctv.usDisplayWidth;
		uwHeight = MMPS_Display_GetConfig()->ntsctv.usDisplayHeight;
		printc("TV Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 

        {
            printc("TV: Init\n");
            uwDisplayID = 1;
            
            AHC_OSDUninit();
            AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

            AHC_SetDisplayOutputDev(DISP_OUT_TV_NTSC, AHC_DISPLAY_DUPLICATE_1X);

            //AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK
            
        //Set full OSD by uwDisplayID = 0            
            AHC_OSDInit(   uwWidth/2,
                            uwHeight,
                            uwWidth/2,
                            uwHeight,
                            PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,OSD_COLOR_ARGB32,AHC_TRUE);

			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
			#endif
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight-1);
    
        //Set Video OSD 240x240 by uwDisplayID = 1
            AHC_OSDCreateBuffer(uwDisplayID ,240, 240,OSD_COLOR_ARGB32); 
            iVal[0] = uwWidth- 240*2;
            iVal[1] = uwHeight - 240;
            AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

            //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
            iVal[0] = 1;
            iVal[1] = 0;
            iVal[2] = 50;
            AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );
    
            AHC_OSDSetCurrentDisplay(uwDisplayID);

			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(uwDisplayID, 0x000000FF);
			#else
            AHC_OSDSetColor(0x000000FF);
			#endif
            AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,240-1);
            MMPF_OS_Sleep(0x100);

        //Show only OSD(full by uwDisplayID = 0)
            printc("TV: only OSD full range..."); 
            AHC_OSDSetActive(uwDisplayID, 0);
            AHC_OSDSetCurrentDisplay(0);
            AHC_OSDSetActive(0, 1);
            //MMPF_OS_Sleep(0x100);
            SleepSec(5);
            printc("End\n"); 

              
        //Show Video+OSD(320x240 by uwDisplayID = 1)
            printc("TV: OSD + Video...");  
            AHC_OSDSetActive(0, 0);
            AHC_OSDSetCurrentDisplay(1);
            AHC_OSDSetActive(uwDisplayID, 1);
            AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK 
            MMPF_OS_Sleep(0x1000);
            printc("End\n"); 
            //AHC_SetMode(0x00); //AHC_MODE_IDLE                      
        }
        printc("TV:...End"); 
    break;

#if 0
    case 8: //Video Preview LCD_TV Switch
    while(1) {    
        printc("Video Preview to LCD:Start..."); 
       
        AHC_OSDUninit();
        AHC_SetMode( AHC_MODE_IDLE ); 
       
     	AHC_SetDisplayOutputDev(DISP_OUT_LCD, AHC_DISPLAY_DUPLICATE_1X);
     	AHC_SetDisplayWindow( DISPLAY_SYSMODE_VIDEOCAPTURE, AHC_TRUE, 0, 0, 0, 320, 240);   
     	
     	InitOSD();
     	//m_TVStatus = AHC_TV_NONE_STATUS;
     	
     	//bPreviewModeTVout = AHC_FALSE;
     	
     	//StateSwitchMode(UI_VIDEO_STATE);
     	AHC_SetMode(AHC_MODE_RECORD_PREVIEW);
     	
     	RTNA_LCD_Backlight(MMP_TRUE);			
             	
        printc("End\n"); 
        

        SleepSec(3);

        
        printc("Video Preview to TV:Start..."); 
        //MMPS_3GPRECD_PreviewStop();

        SetTVState(5/*AHC_TV_VIDEO_PREVIEW_STATUS*/);//??
        
        //AHC_SetMode( AHC_MODE_IDLE );
        
        //AHC_SetParam(PARAM_ID_LCD_STATUS,0);

        //MenuSettingConfig()->uiMOVSize = MOVIE_SIZE_VGA_30P; //Rogers@20120830: for TVOUT_PREVIEW test pass
        //MenuSettingConfig()->uiMOVSize = MOVIE_SIZE_720_60P; //Rogers@20120830: for TVOUT_PREVIEW test pass
        //MenuSettingConfig()->uiMOVSize = MOVIE_SIZE_720P; //Rogers@20120830: for TVOUT_PREVIEW test pass
        MenuSettingConfig()->uiMOVSize = MOVIE_SIZE_1080P;  //Rogers@20120830: for TVOUT_PREVIEW test fail

        TVFunc_PreviewVideo();
   
        printc("End\n"); 

        SleepSec(3);
    }//While(1)    
    break;
#endif
    
    case 9: //SD Formact
        printc("SD Formact..."); 
        MMPF_FS_Format( "SD:0:" );
        printc("End\n"); 
    break;
    
  
    case 10: //Play wave file
        PlayWavFile1();  
    break;

	case 11: //Touch Panel Reset
    break;
    
    default:
        printc("DSC: Capture..."); 
        AHC_SetMode( AHC_MODE_IDLE );
        AHC_SetMode(AHC_MODE_CAPTURE_PREVIEW);
        AHC_SetMode(AHC_MODE_STILL_CAPTURE);
        printc("End\n"); 

        SleepSec(3);

        printc("DSC: Decode..."); 
        AHC_SetMode( AHC_MODE_IDLE );
        AHC_UF_SetCurrentIndex(1);
        AHC_SetMode(AHC_MODE_PLAYBACK);
        printc("End\n"); 

        SleepSec(3);

        printc("VR:Start..."); 
        AHC_SetMode( AHC_MODE_IDLE );
        AHC_SetMode(AHC_MODE_RECORD_PREVIEW);
        VideoFunc_Record();
        printc("End\n"); 

        SleepSec(10);

        printc("VP:Start..."); 
        AHC_SetMode( AHC_MODE_IDLE ); 
        AHC_UF_SetCurrentIndex(2);
        AHC_SetMode(AHC_MODE_PLAYBACK);
        printc("End\n"); 

        SleepSec(12);
        
        printc("HDMI:Start..."); 
        uwWidth = MMPS_Display_GetConfig()->hdmi.usDisplayWidth;
		uwHeight = MMPS_Display_GetConfig()->hdmi.usDisplayHeight;
		printc("HDMI Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 
	      
#if  NO_DETECT_HDMI
        if(1)
#else
        if(MMPF_HDMI_IsConnect())
#endif        
        {
            printc("HDMI: Init\n");
            uwDisplayID = 1;
            
            AHC_OSDUninit();
            AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

            AHC_SetDisplayOutputDev(DISP_OUT_HDMI, AHC_DISPLAY_DUPLICATE_1X);

            SleepSec(6);
            
            //AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK
            
        //Set full OSD by uwDisplayID = 0            
            AHC_OSDInit(   uwWidth/2, 
                            uwHeight,
                            uwWidth/2, 
                            uwHeight,
                            PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,
            				OSD_COLOR_ARGB32,
            				AHC_TRUE);

			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
            #endif
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight-1);
    
        //Set Video OSD 240x240 by uwDisplayID = 1
            AHC_OSDCreateBuffer(uwDisplayID ,240, 240,OSD_COLOR_ARGB32); 
            iVal[0] = uwWidth- 240*2;
            iVal[1] = uwHeight - 240;
            AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

            //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
            iVal[0] = 1;
            iVal[1] = 0;
            iVal[2] = 50;
            AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );
    
            AHC_OSDSetCurrentDisplay(uwDisplayID);
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(uwDisplayID, 0x000000FF);
			#else
            AHC_OSDSetColor(0x000000FF);
            #endif
            AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,240-1);
            MMPF_OS_Sleep(0x100);

        //Show only OSD(full by uwDisplayID = 0)
            printc("HDMI: only OSD full range..."); 
            AHC_OSDSetActive(uwDisplayID, 0);
            AHC_OSDSetCurrentDisplay(0);
            AHC_OSDSetActive(0, 1);
            //MMPF_OS_Sleep(0x100);
            SleepSec(5);
            printc("End\n"); 

              
        //Show Video+OSD(320x240 by uwDisplayID = 1)
            printc("HDMI: OSD + Video...");  
            AHC_OSDSetActive(0, 0);
            AHC_OSDSetCurrentDisplay(1);
            AHC_OSDSetActive(uwDisplayID, 1);
            AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK 
            MMPF_OS_Sleep(0x1000);
            printc("End\n"); 
            //AHC_SetMode(0x00); //AHC_MODE_IDLE                      
        }
        printc("HDMI:...End"); 

        SleepSec(12);


        printc("TV:Start..."); 
        uwWidth = MMPS_Display_GetConfig()->ntsctv.usDisplayWidth;
		uwHeight = MMPS_Display_GetConfig()->ntsctv.usDisplayHeight;
		printc("TV Display(uwWidth,uwHeight)=(%d,%d) \n", uwWidth, uwHeight); 

        {
            printc("TV: Init\n");
            uwDisplayID = 1;
            
            AHC_OSDUninit();
            AHC_SetMode( 0x00 ); //AHC_MODE_IDLE

            AHC_SetDisplayOutputDev(DISP_OUT_TV_NTSC, AHC_DISPLAY_DUPLICATE_1X);

            //AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK
            
        //Set full OSD by uwDisplayID = 0            
            AHC_OSDInit(   uwWidth/2,
                            uwHeight,
                            uwWidth/2,
                            uwHeight,
                            PRIMARY_DATESTAMP_WIDTH,
            				PRIMARY_DATESTAMP_HEIGHT,
            				THUMB_DATESTAMP_WIDTH,
            				THUMB_DATESTAMP_HEIGHT,
            				OSD_COLOR_ARGB32,
            				AHC_TRUE);


			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(0, 0x0000FF00);
			#else
            AHC_OSDSetColor(0x0000FF00);
			#endif
            AHC_OSDDrawFillRect(0,0,0,uwWidth/2-1,uwHeight-1);
    
        //Set Video OSD 240x240 by uwDisplayID = 1
            AHC_OSDCreateBuffer(uwDisplayID ,240, 240,OSD_COLOR_ARGB32); 
            iVal[0] = uwWidth- 240*2;
            iVal[1] = uwHeight - 240;
            AHC_OSDSetDisplayAttr(uwDisplayID, AHC_OSD_ATTR_DISPLAY_OFFSET, iVal);

            //printc( "DisplayID = %d, enable= %d, type = %d, transparent weight = %d\n", id, iVal[0], iVal[1], iVal[2] );
            iVal[0] = 1;
            iVal[1] = 0;
            iVal[2] = 50;
            AHC_OSDSetDisplayAttr( uwDisplayID, AHC_OSD_ATTR_SEMI_TRANSPARENT_ENABLE, iVal );
    
            AHC_OSDSetCurrentDisplay(uwDisplayID);

			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
            AHC_OSDSetColor(uwDisplayID, 0x000000FF);
			#else
            AHC_OSDSetColor(0x000000FF);
			#endif
            AHC_OSDDrawFillRect(uwDisplayID,0,0,240-1,240-1);
            MMPF_OS_Sleep(0x100);

        //Show only OSD(full by uwDisplayID = 0)
            printc("TV: only OSD full range..."); 
            AHC_OSDSetActive(uwDisplayID, 0);
            AHC_OSDSetCurrentDisplay(0);
            AHC_OSDSetActive(0, 1);
            //MMPF_OS_Sleep(0x100);
            SleepSec(5);
            printc("End\n"); 

              
        //Show Video+OSD(320x240 by uwDisplayID = 1)
            printc("TV: OSD + Video...");  
            AHC_OSDSetActive(0, 0);
            AHC_OSDSetCurrentDisplay(1);
            AHC_OSDSetActive(uwDisplayID, 1);
            AHC_SetMode( 0x40 );//AHC_MODE_PLAYBACK 
            MMPF_OS_Sleep(0x1000);
            printc("End\n"); 
            //AHC_SetMode(0x00); //AHC_MODE_IDLE                      
        }
        printc("TV:...End"); 

        SleepSec(12);
        
        
        printc("MSDC:Start..."); 
        AHC_SetMode( AHC_MODE_IDLE ); 
        AHC_SetMode(AHC_MODE_USB_MASS_STORAGE);
        printc("End\n"); 
    break;
    
    }
}

void UartCmd_UIS(char* szParam)
{
	printc("UI S= %d\n",uiGetCurrentState());
}

void UartCmd_CanSendHDMIEvent( char* szParam )
{
	printc("Can Send HDMI Event: %d\r\n",AHC_CanSendHDMIEvent());
}	

void UartCmd_HDMISendEventEnable( char* szParam )
{
	int Enable;
    
	sscanfl( szParam, "%d", &Enable);
    AHC_HDMISendEventEnable((AHC_BOOL) Enable);
}	

void UartCmd_SendAHLMessageEnable( char* szParam )
{
	int Enable;
    
	sscanfl( szParam, "%d", &Enable);
    AHC_SendAHLMessageEnable((AHC_BOOL) Enable);
}	


void UartCmd_SetDisplayMode( char* szParam )
{
	int uiMode = 0xFF;
    
	sscanfl( szParam, "%d", &uiMode);
    AHC_SetDisplayMode(uiMode);
}	
void UartCmd_PIPswp( char* szParam )
{
#if (REAR_CAM_TYPE != REAR_CAM_TYPE_NONE)
    int uiMode = 0xFF;
    extern MMP_USHORT   gsAhcCurrentSensor;
    MMP_BOOL    bUserConfig, bRotate;
    MMP_UBYTE ubRotateDir, sFitMode;
    MMP_USHORT usBufWidth, usBufHeight, usStartX, usStartY, usWinWidth, usWinHeight;
    AHC_WINDOW_RECT sFrontRect,sRearRect;
    MMP_DISPLAY_WIN_ATTR winattr;
    MMP_DISPLAY_DISP_ATTR	dispAtt = {0};

    sscanfl( szParam, "%d", &uiMode);
    switch (uiMode) {
    case 1:
        AHC_HostUVCVideoPreviewStop();
        MMPS_3GPRECD_UVCGetCustomedPrevwAttr(&bUserConfig, &bRotate, &ubRotateDir, &sFitMode,
                &usBufWidth, &usBufHeight,&usStartX, &usStartY, &usWinWidth, &usWinHeight);
        printc("W %d  H %d   bRotate %d\r\n", RTNA_LCD_GetAttr()->usPanelW, RTNA_LCD_GetAttr()->usPanelH, bRotate);
        AHC_HostUVCVideoSetWinAttribute(MMP_DISPLAY_WIN_OVERLAY, RTNA_LCD_GetAttr()->usPanelW, RTNA_LCD_GetAttr()->usPanelH, 0, 0, MMP_SCAL_FITMODE_OPTIMAL, bRotate);

        MMPS_3GPRECD_PreviewStop(gsAhcCurrentSensor);
#if (VERTICAL_LCD == VERTICAL_LCD_DEGREE_0)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 0, MMP_DISPLAY_ROTATE_NO_ROTATE,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2,
                0, 0, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2);
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_90)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_90,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH)/2, (RTNA_LCD_GetAttr()->usPanelW)/2,
                0, 0, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2);
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_270)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_270,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH)/2, (RTNA_LCD_GetAttr()->usPanelW)/2,
                0, 0, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2);
#endif

        MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_PIP,
                MMP_DISPLAY_WIN_MAIN,
                MMP_DISPLAY_WIN_OVERLAY,
                MMP_DISPLAY_WIN_MAX);

        MMPS_3GPRECD_PreviewStart(gsAhcCurrentSensor, MMP_TRUE);
        AHC_HostUVCVideoPreviewStart();
        break;
    case 2:
        MMPS_3GPRECD_UVCGetCustomedPrevwAttr(&bUserConfig, &bRotate, &ubRotateDir, &sFitMode,
                &usBufWidth, &usBufHeight,&usStartX, &usStartY, &usWinWidth, &usWinHeight);
        AHC_HostUVCVideoPreviewStop();
        printc("W %d  H %d   bRotate %d\r\n", RTNA_LCD_GetAttr()->usPanelW, RTNA_LCD_GetAttr()->usPanelH, bRotate);
        AHC_HostUVCVideoSetWinAttribute(MMP_DISPLAY_WIN_OVERLAY, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2,
                (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2, MMP_SCAL_FITMODE_OPTIMAL, bRotate);

        MMPS_3GPRECD_PreviewStop(gsAhcCurrentSensor);
#if (VERTICAL_LCD == VERTICAL_LCD_DEGREE_0)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 0, MMP_DISPLAY_ROTATE_NO_ROTATE,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH),
                0, 0, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH));
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_90) 
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_90,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH), (RTNA_LCD_GetAttr()->usPanelW),
                0, 0, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH));
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_270)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_270,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH), (RTNA_LCD_GetAttr()->usPanelW),
                0, 0, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH));
#endif

        MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY,
                MMP_DISPLAY_WIN_MAIN,
                MMP_DISPLAY_WIN_PIP,
                MMP_DISPLAY_WIN_MAX);
        MMPS_3GPRECD_PreviewStart(gsAhcCurrentSensor, MMP_TRUE);
        AHC_HostUVCVideoPreviewStart();
        break;
    case 3:
        MMPS_3GPRECD_UVCGetCustomedPrevwAttr(&bUserConfig, &bRotate, &ubRotateDir, &sFitMode,
                &usBufWidth, &usBufHeight,&usStartX, &usStartY, &usWinWidth, &usWinHeight);
        AHC_HostUVCVideoPreviewStop();
        printc("W %d  H %d   bRotate %d\r\n", RTNA_LCD_GetAttr()->usPanelW, RTNA_LCD_GetAttr()->usPanelH, bRotate);
        AHC_HostUVCVideoSetWinAttribute(MMP_DISPLAY_WIN_OVERLAY, RTNA_LCD_GetAttr()->usPanelW, RTNA_LCD_GetAttr()->usPanelH, 0, 0, MMP_SCAL_FITMODE_OPTIMAL, bRotate);
        AHC_HostUVCVideoPreviewStart();
        break;
    case 4:
        MMPS_3GPRECD_UVCGetCustomedPrevwAttr(&bUserConfig, &bRotate, &ubRotateDir, &sFitMode,
                &usBufWidth, &usBufHeight,&usStartX, &usStartY, &usWinWidth, &usWinHeight);

        AHC_HostUVCVideoPreviewStop();
        printc("W %d  H %d   bRotate %d\r\n", RTNA_LCD_GetAttr()->usPanelW, RTNA_LCD_GetAttr()->usPanelH, bRotate);

        AHC_HostUVCVideoSetWinAttribute(MMP_DISPLAY_WIN_OVERLAY, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2,
                (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2, MMP_SCAL_FITMODE_OPTIMAL, bRotate);

        AHC_HostUVCVideoPreviewStart();
        break;
    case 5:
        MMPS_3GPRECD_PreviewStop(gsAhcCurrentSensor);
#if (VERTICAL_LCD == VERTICAL_LCD_DEGREE_0)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 0, MMP_DISPLAY_ROTATE_NO_ROTATE,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2,
                0, 0, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2);
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_90) 
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_90,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH)/2, (RTNA_LCD_GetAttr()->usPanelW)/2,
                0, 0, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2);
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_270)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_270,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH)/2, (RTNA_LCD_GetAttr()->usPanelW)/2,
                0, 0, (RTNA_LCD_GetAttr()->usPanelW)/2, (RTNA_LCD_GetAttr()->usPanelH)/2);
#endif
        MMPS_3GPRECD_PreviewStart(gsAhcCurrentSensor, MMP_TRUE);
        break;
    case 6:
        MMPS_3GPRECD_PreviewStop(gsAhcCurrentSensor);
#if (VERTICAL_LCD == VERTICAL_LCD_DEGREE_0)
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 0, MMP_DISPLAY_ROTATE_NO_ROTATE,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH),
                0, 0, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH));
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_90) 
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_90,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH), (RTNA_LCD_GetAttr()->usPanelW),
                0, 0, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH));
#elif (VERTICAL_LCD == VERTICAL_LCD_DEGREE_270) 
        MMPS_3GPRECD_CustomedPreviewAttr(gsAhcCurrentSensor, 1, 1, MMP_DISPLAY_ROTATE_RIGHT_270,
                MMP_SCAL_FITMODE_OPTIMAL, (RTNA_LCD_GetAttr()->usPanelH), (RTNA_LCD_GetAttr()->usPanelW),
                0, 0, (RTNA_LCD_GetAttr()->usPanelW), (RTNA_LCD_GetAttr()->usPanelH));
#endif
        MMPS_3GPRECD_PreviewStart(gsAhcCurrentSensor, MMP_TRUE);
        break;

    case 7://front small    rear big   //7 8 for rear cam = TV decoder lucas 20151210
        AHC_PreviewWindowOp(AHC_PREVIEW_WINDOW_OP_GET | AHC_PREVIEW_WINDOW_REAR,&sRearRect);
        AHC_PreviewWindowOp(AHC_PREVIEW_WINDOW_OP_GET | AHC_PREVIEW_WINDOW_FRONT,&sFrontRect);

        MMPS_Display_SetWinActive(FRONT_CAM_WINDOW_ID , MMP_FALSE);
        MMPS_Display_SetWinActive(REAR_CAM_WINDOW_ID , MMP_FALSE);

    	MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OSD,MMP_DISPLAY_WIN_MAIN,MMP_DISPLAY_WIN_PIP,MMP_DISPLAY_WIN_OVERLAY);

    	MMPS_Display_SetWinScaleAndOffset(FRONT_CAM_WINDOW_ID, MMP_SCAL_FITMODE_OPTIMAL,
    	                                						  sFrontRect.usWidth, sFrontRect.usHeight, sRearRect.usWidth, sRearRect.usHeight, sRearRect.usLeft, sRearRect.usTop);

        MMPS_Display_SetWinScaleAndOffset(REAR_CAM_WINDOW_ID, MMP_SCAL_FITMODE_OPTIMAL,
        		sRearRect.usWidth, sRearRect.usHeight, sFrontRect.usWidth, sFrontRect.usHeight, sFrontRect.usLeft, sFrontRect.usTop);

    	MMPS_Display_SetWinActive(FRONT_CAM_WINDOW_ID , AHC_TRUE);
    	MMPS_Display_SetWinActive(REAR_CAM_WINDOW_ID , AHC_TRUE);
    	break;
    case 8://front big     rear small

        AHC_PreviewWindowOp(AHC_PREVIEW_WINDOW_OP_GET | AHC_PREVIEW_WINDOW_REAR,&sRearRect);
        AHC_PreviewWindowOp(AHC_PREVIEW_WINDOW_OP_GET | AHC_PREVIEW_WINDOW_FRONT,&sFrontRect);

        MMPS_Display_SetWinActive(FRONT_CAM_WINDOW_ID , MMP_FALSE);
        MMPS_Display_SetWinActive(REAR_CAM_WINDOW_ID , MMP_FALSE);
    	MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OSD,MMP_DISPLAY_WIN_MAIN,MMP_DISPLAY_WIN_OVERLAY,MMP_DISPLAY_WIN_PIP);

    	dispAtt.usDisplayWidth = RTNA_LCD_GetAttr()->usPanelW;
    	dispAtt.usDisplayHeight = RTNA_LCD_GetAttr()->usPanelH;
    	MMPD_Display_GetWinAttributes(FRONT_CAM_WINDOW_ID, &winattr);
    	MMPS_Display_SetWindowAttrToDisp(FRONT_CAM_WINDOW_ID, winattr , dispAtt);


    	dispAtt.usDisplayWidth = RTNA_LCD_GetAttr()->usPanelW >> 1;
    	dispAtt.usDisplayHeight = RTNA_LCD_GetAttr()->usPanelH >> 1;
    	MMPD_Display_GetWinAttributes(REAR_CAM_WINDOW_ID, &winattr);
    	MMPS_Display_SetWindowAttrToDisp(REAR_CAM_WINDOW_ID, winattr , dispAtt);

    	MMPS_Display_SetWinActive(FRONT_CAM_WINDOW_ID , AHC_TRUE);
    	MMPS_Display_SetWinActive(REAR_CAM_WINDOW_ID , AHC_TRUE);
    	break;
    }
	#endif
}

void UartCmd_SetWinPriority( char* szParam )
{
	int uiMode = 0xFF;
	
	#if (CHIP == P_V2)
    MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_ICON, MMP_DISPLAY_WIN_OVERLAY, MMP_DISPLAY_WIN_MAIN, MMP_DISPLAY_WIN_PIP);
    #endif
    #if (CHIP == MCR_V2)
    #if UVC_VIDRECD_SUPPORT
    MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY, MMP_DISPLAY_WIN_MAIN, MMP_DISPLAY_WIN_PIP, MMP_DISPLAY_WIN_MAX);
    #else
    MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_MAIN, MMP_DISPLAY_WIN_OVERLAY, MMP_DISPLAY_WIN_PIP, MMP_DISPLAY_WIN_MAX);
    #endif  // UVC_VIDRECD_SUPPORT
    #endif
    
	sscanfl( szParam, "%d", &uiMode);
	switch (uiMode) {
		case 1:
		#if (CHIP == P_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_ICON);
		#endif			
		#if (CHIP == MCR_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_MAX);
		#endif									
			break;
		case 2:
		#if (CHIP == P_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_ICON, 
											MMP_DISPLAY_WIN_MAIN);
		#endif		
		#if (CHIP == MCR_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_PIP,  
											MMP_DISPLAY_WIN_MAIN,
											MMP_DISPLAY_WIN_MAX);
		#endif									
			break;
		case 3:
		#if (CHIP == P_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_PIP, 
								MMP_DISPLAY_WIN_ICON, 
								MMP_DISPLAY_WIN_MAIN, 
								MMP_DISPLAY_WIN_OVERLAY);
		#endif	
		#if (CHIP == MCR_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_PIP, 
								MMP_DISPLAY_WIN_MAIN, 
								MMP_DISPLAY_WIN_OVERLAY,
								MMP_DISPLAY_WIN_MAX);
		#endif	
			break;
		case 4:
		#if (CHIP == P_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_ICON, 
											MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_PIP);
		#endif	
		#if (CHIP == MCR_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_PIP,
											MMP_DISPLAY_WIN_MAX);
		#endif	
			break;
		case 5:
		#if (CHIP == P_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_ICON);
		#endif	
		#if (CHIP == MCR_V2)    
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_MAX);
		#endif	
			break;
		case 6:
		#if (CHIP == P_V2)
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_ICON);
		#endif	
		#if (CHIP == MCR_V2)
			MMPS_Display_SetWinPriority(MMP_DISPLAY_WIN_PIP, 
											MMP_DISPLAY_WIN_OVERLAY, 
											MMP_DISPLAY_WIN_MAIN, 
											MMP_DISPLAY_WIN_MAX);
		#endif	
			break;
	}
}
	
void UartCmd_DisplayRefresh(char* szParam)
{
	MMPS_Display_SetDisplayRefresh(MMP_DISPLAY_PRM_CTL);
}

void UartCmd_Backlight(char* szParam)
{
	MMP_BOOL  enable;
	 
	sscanfl( szParam, "%d ", &enable);
	RTNA_LCD_Backlight(enable); //Andy Liu TBD
}


void
UartCmdChargerOperation( char* szParam )
{
	int uiMode = 0xFF;//MMPS_USB_PCSYNC_MODE;
#if (CHIP == P_V2)
    MMP_UBYTE  tempValue;
#endif
	
	sscanfl( szParam, "%d", &uiMode);

    printc(" DS9525 Charger operation\n");
#if (CHIP == P_V2)
    //Set GPIO as input mode
    MMPF_PIO_EnableOutputMode(MMP_GPIO73, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(MMP_GPIO49, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(MMP_LGPIO27, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(MMP_GPIO69, MMP_FALSE, MMP_TRUE);

    MMPF_PIO_EnableOutputMode(MMP_LGPIO28, MMP_TRUE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(MMP_LGPIO29, MMP_TRUE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(MMP_LGPIO30, MMP_TRUE, MMP_TRUE);

    // PGOOD
    MMPF_PIO_GetData( MMP_GPIO73 , &tempValue);
    printc( " PGOOD = %d\n", tempValue );

    // CHG
    MMPF_PIO_GetData( MMP_GPIO49 , &tempValue);
    printc( " CHG = %d\n", tempValue );

    // USB VBUS
    MMPF_PIO_GetData( MMP_LGPIO27 , &tempValue);
    printc( " USB VBUS = %d\n", tempValue );

    // USB adapter
    MMPF_PIO_GetData( MMP_GPIO69 , &tempValue);
    printc( " USB ID = %d\n", tempValue );

    switch( uiMode )
    {
    case 0xFF:
        break;
    case 0:
        MMPF_PIO_SetData( MMP_LGPIO28, 0, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO29, 0, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO30, 0, MMP_TRUE );
        printc("100mA mode\n");
        break;
    case 1:
        MMPF_PIO_SetData( MMP_LGPIO28, 1, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO29, 0, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO30, 0, MMP_TRUE );
        printc("500mA mode\n");
        break;
    case 2:
        MMPF_PIO_SetData( MMP_LGPIO28, 0, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO29, 1, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO30, 0, MMP_TRUE );
        printc("1.5A mode\n");
        break;
    case 3:
        MMPF_PIO_SetData( MMP_LGPIO28, 1, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO29, 1, MMP_TRUE );
        MMPF_PIO_SetData( MMP_LGPIO30, 1, MMP_TRUE );
        printc("Suspend mode\n");
        break;
    }
#endif
}


void
UartCmdReadKey( char* szParam )
{
	int uiMode = 0xFF;//MMPS_USB_PCSYNC_MODE;	
	sscanfl( szParam, "%X", &uiMode);

    //Set GPIO as input mode
/*
    MMPF_PIO_EnableOutputMode(KEYPAD_S06_GPIO, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(KEYPAD_S08_GPIO, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(KEYPAD_S09_GPIO, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(KEYPAD_S11_GPIO, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(KEYPAD_S12_GPIO, MMP_FALSE, MMP_TRUE);

    MMPF_PIO_GetData( KEYPAD_S06_GPIO , &tempValue);
    printc( " KEYPAD_S06_GPIO = %d\n", tempValue );

    MMPF_PIO_GetData( KEYPAD_S08_GPIO , &tempValue);
    printc( " KEYPAD_S08_GPIO= %d\n", tempValue );

    MMPF_PIO_GetData( KEYPAD_S09_GPIO , &tempValue);
    printc( " KEYPAD_S09_GPIO = %d\n", tempValue );

    MMPF_PIO_GetData( KEYPAD_S11_GPIO , &tempValue);
    printc( " KEYPAD_S11_GPIO = %d\n", tempValue );

    MMPF_PIO_GetData( KEYPAD_S12_GPIO , &tempValue);
    printc( " KEYPAD_S12_GPIO = %d\n", tempValue );
*/    

/*
    MMPF_PIO_EnableOutputMode(LED_GPIO_VIDEO,      MMP_TRUE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(LED_GPIO_PLAYBACK,   MMP_TRUE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(LED_GPIO_CAMERA,     MMP_TRUE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(LCD_GPIO_BACK_LIGHT, MMP_TRUE, MMP_TRUE);

    if( uiMode & 0x01 )
        MMPF_PIO_SetData( LED_GPIO_VIDEO , MMP_TRUE, MMP_TRUE);
    else
        MMPF_PIO_SetData( LED_GPIO_VIDEO , MMP_FALSE, MMP_TRUE);    
    if( uiMode & 0x02 )
        MMPF_PIO_SetData( LED_GPIO_PLAYBACK , MMP_TRUE, MMP_TRUE);
    else
        MMPF_PIO_SetData( LED_GPIO_PLAYBACK , MMP_FALSE, MMP_TRUE);    
    if( uiMode & 0x04 )
        MMPF_PIO_SetData( LED_GPIO_CAMERA , MMP_TRUE, MMP_TRUE);
    else
        MMPF_PIO_SetData( LED_GPIO_CAMERA , MMP_FALSE, MMP_TRUE);    
    if( uiMode & 0x08 )
        MMPF_PIO_SetData( LCD_GPIO_BACK_LIGHT , MMP_TRUE,MMP_TRUE);
    else
        MMPF_PIO_SetData( LCD_GPIO_BACK_LIGHT , MMP_FALSE, MMP_TRUE);    
*/


}

void
UartCmdEnablePi( char* szParam )
{
	int iDevice, iEnable;
	sscanfl( szParam, " %d %d ", &iDevice, &iEnable );

#if BIND_MOTOR_R2A30440NP
    switch(iDevice)
    {
    case 0:
	    R2A30440NP_FocusEnablePR(iEnable);
	    break;
	case 1:
	    R2A30440NP_ZoomEnablePR(iEnable);	
		break;
    }
#endif    
}

#if 0
void
SensorPsenCtrl( MMP_BOOL bHigh );

void
UartCmdSensorPsenCtrl( char* szParam )
{
	int iEnable;
	sscanfl( szParam, " %d", &iEnable );
	SensorPsenCtrl( iEnable );
}
#endif

//------------------------------------------------------------------------------


void
UartCmdReadZFOUT( char* szParam )
{
    MMP_UBYTE  tempValue;
	
     //Set GPIO as input mode
    MMPF_PIO_EnableOutputMode(MMP_GPIO65, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_EnableOutputMode(MMP_GPIO88, MMP_FALSE, MMP_TRUE);
    MMPF_PIO_GetData( MMP_GPIO65 , &tempValue);
    printc( " ZOUT = %d\n", tempValue );    
    MMPF_PIO_GetData( MMP_GPIO88 , &tempValue);
    printc( " FOUT = %d\n", tempValue );
}
MMP_USHORT SensorI2cRead( MMP_USHORT usAddr );
void SensorI2cWrite( MMP_USHORT usAddr, MMP_USHORT usData );

void UartCmdReadSensorI2c( char* szParam )
{
    unsigned int uiAddr;
    MMP_USHORT uiData;
	sscanfl( szParam, " %x ", &uiAddr );    

    //SensorI2cRead( uiAddr );
	gsSensorFunction->MMPF_Sensor_GetReg(PRM_SENSOR,(MMP_USHORT)uiAddr, &uiData);
	printc("0x%X = 0x%X", uiAddr, uiData);
}

void UartCmdWriteSensorI2c( char* szParam )
{
    unsigned int uiAddr, uiData;
	sscanfl( szParam, " %x %x ", &uiAddr, &uiData );
    //SensorI2cWrite( uiAddr, uiData );
	gsSensorFunction->MMPF_Sensor_SetReg(PRM_SENSOR,(MMP_USHORT)uiAddr, (MMP_USHORT)uiData);
	printc("0x%X set to 0x%X", uiAddr, uiData);
}
void UartCmd_ADX2003_PowerOff ( char* szParam )
{
	AHC_PMU_PowerOff();
}
void UartCmd_SleepMode  ( char* szParam )
{
#if 0
	 MMP_BOOL  enable;
	 MMP_USHORT temp;
	 AITPS_VIF  pVIF = AITC_BASE_VIF;
	 sscanfl( szParam, "%d ", &enable);
	 if(enable)
	 {
	 	printc("Enter sleepmode\r\n");
	 	//LCD BackLight
	 	RTNA_LCD_Backlight(!enable);
	 	//Motor
	 	FuncMotorCtrl_ZoomExcitationCtrl(!enable);
	 	FuncMotorCtrl_FocusExcitationCtrl(!enable);
	 	//3A
	 	ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AWB, !enable);
	 	ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AE, !enable );
	 	ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AF, !enable );
	 	//Sensor STB
	    temp = SensorI2cRead(0x0B);
	    printc("temp : %d\r\n",temp); 
	    temp |= (0x0002);
	    printc("temp : %d\r\n",temp);
	    SensorI2cWrite(0x0B,temp);
	    MMPF_OS_Sleep_MS(10);
	 	temp = SensorI2cRead(0x07);
	 	printc("temp : %d\r\n",temp);
	 	temp &= ~(0x0002);
	 	printc("temp : %d\r\n",temp);
	 	SensorI2cWrite(0x07,temp);
	 	MMPF_OS_Sleep_MS(10);
	 	
	 }else
	 {
	 	printc("Enter Normalmode\r\n");
	    //Motor
	    FuncMotorCtrl_ZoomExcitationCtrl(!enable);
	    FuncMotorCtrl_FocusExcitationCtrl(!enable);
	    //Sensor STB
	    
	    MMPF_OS_Sleep_MS(10);
	    temp = SensorI2cRead(0x0B);
	    printc("temp : %d\r\n",temp); 
	    temp = (0x0001);
	    printc("temp : %d\r\n",temp);
	    SensorI2cWrite(0x0B,temp);
	    MMPF_OS_Sleep_MS(10);
	    temp = SensorI2cRead(0x07);
	    printc("temp : %d\r\n",temp); 
	    temp |= (0x0002);
	    printc("temp : %d\r\n",temp);
	    SensorI2cWrite(0x07,temp);
	    //3A
	    ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AWB, !enable);
	 	ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AE, !enable );
	 	ISP_IF_3A_SetSwitch(ISP_3A_ALGO_AF, !enable );
	    //LCD BackLight
	    RTNA_LCD_Backlight(!enable);
	 }    
#endif	 
}

void UartCmd_ErrorMSG( char* szParam )
{
	UINT16 errormessage, sec;
	sscanfl( szParam, "%d %d", &errormessage, &sec);
	AHC_WMSG_Draw(AHC_TRUE,errormessage,sec);	
}

void UartCmd_ErrorMSG_Lens( char* szParam )
{
	UINT16 number;
	sscanfl( szParam, "%d", &number);
	AHC_WMSG_SetLensError(number);
}

void UartCmd_VR_Pause( char* szParam )
{
	MMPS_3GPRECD_PauseRecord();
}

void UartCmd_VR_Resume( char* szParam )
{
	MMPS_3GPRECD_ResumeRecord();
}

void UartCmd_UI( char* szParam )
{
#if 0	// TY Miao - TBD
	UINT16 item;
	sscanfl( szParam, "%d ", &item);

	switch(item) {
	case 1: //LOOP: Video Record Start -> Video Record Stop
	     while(1) {
             AHC_SendAHLMessage(AHLM_GPIO_BUTTON_NOTIFICATION, BUTTON_REC_PRESS, 0);
             MMPF_OS_Sleep_MS(5000);
         }
    break;     
    case 2: //LOOP: Still Capture
	     while(1) {
	         AHC_SendAHLMessage(AHLM_GPIO_BUTTON_NOTIFICATION, BUTTON_FOCUS_PRESS, 0);
	         MMPF_OS_Sleep_MS(2000);
	     	 AHC_SendAHLMessage(AHLM_GPIO_BUTTON_NOTIFICATION, BUTTON_SHUTTER_PRESS, 0);
	     	 MMPF_OS_Sleep_MS(4000);
         }
    break;     
	default:
	     printc("No Test !!\r\n");
    break;
	}
#endif
}



void UartCmd_PMU_ADC_WriteRegister( char* szParam )
{
	MMP_UBYTE reg;
	MMP_USHORT nValue;
	sscanfl( szParam, "%X %X ", &reg,&nValue);
	AHC_PMUCtrl_Write_Reg(reg, nValue); 
	AHC_PMUCtrl_Read_Reg(reg, &nValue);
	printc("ReadBack : 0x%x\r\n",nValue);
}
void UartCmd_PMU_ADC_ReadRegister( char* szParam )
{
	MMP_UBYTE reg;
	MMP_USHORT nValue;
	sscanfl( szParam, "%X", &reg);
	AHC_PMUCtrl_Read_Reg(reg, &nValue);
	printc("ReadBack : 0x%x\r\n",nValue);
}

/*
    Set VIF delay cell
    %d -> Delaycell  0~3
*/
void UartCmd_SensorSetDelayCell( char* szParam )
{
    int iDelayCell;
	sscanfl( szParam, "%d", &iDelayCell);
    
    //SNR_SetDelayCellSeting( iDelayCell ); //Rogers:***

    AHC_SetMode( AHC_MODE_IDLE );
    
    AHC_SetMode( AHC_MODE_RECORD_PREVIEW );    
    
}

void UartCmd_DcfDumpDb( char* szParam )
{
    AHC_UF_DumpDB();
}

void UartCmd_PowerOff( char* szParam )
{
    AHC_NormalPowerOffPath();
}


void UartCmd_StrobeInit( char* szParam )
{
	printc("StrobeInit\r\n");
	#if ENABLE_STROBE
	AHC_STROBE_Initialize();
	#endif
}

void UartCmd_StrobeCharge( char* szParam )
{
	int iOn;
	sscanfl( szParam, "%d", &iOn);
	printc("Charge : %d \r\n", iOn);

	#if ENABLE_STROBE
	if(iOn)
		AHC_STROBE_ChargeOn(MMP_TRUE);
	else
		AHC_STROBE_ChargeOn(MMP_FALSE);
	#endif

}

void UartCmd_StrobeReady( char* szParam )
{
	MMP_BOOL bEnable;
	printc("Charge\r\n");
	#if ENABLE_STROBE
	bEnable = AHC_STROBE_CheckChargeReady();
	#endif
	if(bEnable)
		printc("Ready\r\n");
		
	else{
		printc("Not yet\r\n");
	}
}

void UartCmd_StrobeTriggerInit( char* szParam )
{
	UINT32 time1, time2;
	
	sscanfl( szParam, "%d %d", &time1, &time2);
	printc("time1 : %d, time2 : %d \r\n", time1, time2);
	#if ENABLE_STROBE
	AHC_STROBE_TriggerDuration(time1, time2);
	#endif
}
void UartCmd_StrobeTrigger( char* szParam )
{
	#if ENABLE_STROBE
	AHC_STROBE_Trigger();
	#endif
}

void UartCmd_MotorRegRead( char* szParam )
{
    unsigned int ch, reg, ch_rd, BitSize;
	sscanfl( szParam, "%d %x %x %x", &ch, &reg, &ch_rd, &BitSize );

    MotorCtrl_RegRead(ch, reg, ch_rd, BitSize);

}
void UartCmd_MotorRegWrite( char* szParam )
{
    unsigned int ch, reg, wdata;

	sscanfl( szParam, "%d %x %x ", &ch, &reg, &wdata );
    MotorCtrl_RegWrite( ch, reg, wdata );
}

void UartCmd_MotorZoomMove( char* szParam )
{
#if 0
    unsigned int dir, steps;


	sscanfl( szParam, "%d %d", &dir, &steps);

    // Show the current position
	printc( "Zoom current posi is %d , from motor driver: %d\n", ISP_IF_AF_GetZoomTarPos(), FuncMotorCtrl_ZoomGetPosition());

    // print the operation 
    if( dir )
        printc( "ZOOM move forward %d\n", steps );
    else
        printc( "ZOOM move backward %d\n", steps );        


    // Exectue the operation
    FuncMotorCtrl_ZoomMove( dir,  steps );

    // Show the after position
	printc( "Zoom current posi is %d , from motor driver: %d\n", ISP_IF_AF_GetZoomTarPos(), FuncMotorCtrl_ZoomGetPosition());
#endif

}

void UartCmd_MotorFocusMove( char* szParam )
{
#if 0
    unsigned int dir, steps;

	sscanfl( szParam, "%d %d", &dir, &steps);

    // Show the current position
	printc( "AF motor current posi is ISP: %d Motor: %d \n", ISP_IF_AF_GetPos(0),FuncMotorCtrl_FocusGetPosition());

    // print the operation 
    if( dir )
        printc( "ZOOM move forward %d\n", steps );
    else
        printc( "ZOOM move backward %d\n", steps );

    // Exectue the operation     
    FuncMotorCtrl_FocusMove( dir,  steps );

    // Show the after position
    printc( "AF motor current posi is ISP: %d Motor: %d \n", ISP_IF_AF_GetPos(0),FuncMotorCtrl_FocusGetPosition());
#endif
}


void UartCmd_MotorTest( char* szParam )
{
#if 0	// TY Miao - TBD
    unsigned int i,j;
	sscanfl( szParam, "%d %d", &i,&j );

    printc("cmc = %d\n", i );

    switch(i)
    {
        case 0: CH5_Coil_CC200mV_IN3IN4();    break;
        case 1: CH5_Coil_CC200mV_Serial_F();  break;
        case 2: CH5_Coil_CC200mV_Serial_R();  break;
        case 3: CH5_Coil_FS_IN3IN4();         break;
        case 4: CH5_DCM_PWM75_IN3_F();        break;
        case 5: CH5_DCM_PWM75_Serial_F();     break;
        
        case 6: CH6_Coil_CC200mV_IN5IN6();    break;
        case 7: 
        	FuncMotorCtl_MechanicalShutterDirection(MMP_TRUE);     
        	break;
        case 8: 
        	FuncMotorCtl_MechanicalShutterDirection(MMP_FALSE);     
        	break;
        case 9: CH6_Coil_FS_IN5IN6();         break;
        case 10: CH6_Coil_FS_IN6_F();          break;

        case 21: 
            //Set GPIO as Output mode
            /** motor in3 */
            MMPF_PIO_EnableOutputMode(MMP_GPIO55, MMP_TRUE, MMP_TRUE);
            MMPF_PIO_SetData( MMP_GPIO55, j, MMP_TRUE );
            break;        
        case 22: 
            //Set GPIO as Output mode
            /** motor in4 */
            MMPF_PIO_EnableOutputMode(MMP_GPIO56, MMP_TRUE, MMP_TRUE);
            MMPF_PIO_SetData( MMP_GPIO56, j, MMP_TRUE );
            break;        

        case 23: 
            //Set GPIO as Output mode
            /** motor in5 */
            MMPF_PIO_EnableOutputMode(MMP_GPIO57, MMP_TRUE, MMP_TRUE);
            MMPF_PIO_SetData( MMP_GPIO57, j, MMP_TRUE );
            break;        
            
        case 24: 
            //Set GPIO as Output mode
            /** motor in6 */
            MMPF_PIO_EnableOutputMode(MMP_GPIO58, MMP_TRUE, MMP_TRUE);
            MMPF_PIO_SetData( MMP_GPIO58, j, MMP_TRUE );

            break;        
            
        case 25: 
            //Set GPIO as Output mode
            /** motor in6 */
            if(j == 1)
            	FuncMotorCtl_TriggerMechanicalShutter(MMP_TRUE);
            else if(j == 0)
            	FuncMotorCtl_TriggerMechanicalShutter(MMP_FALSE);
            /*
            MMPF_PIO_EnableOutputMode(MMP_GPIO58, MMP_TRUE, MMP_TRUE);
            MMPF_PIO_SetData( MMP_GPIO58, j, MMP_TRUE );
            */
            break;        

        case 26: 
            FuncMotorCtl_IrisDirection(j);
            break;
            
        case 27: 
            break;
            
        case 28:
        	break;

    }
#endif
}

#define SKIP_SPACE(p) { while (*p == ' '  || \
							   *p == '\t' || \
							   *p == '\r' || \
							   *p == '\n') p++; }
#if (GPS_CONNECT_ENABLE)
#include "ColorDefine.h"
#include "IconDefine.h"

void GPS_DrawInformationPage(void)
{
	if (AHC_GPS_Module_Attached())
	{
		UINT8 bID0 = 0;
		UINT8 bID1 = 0;
		UINT8 i = 0;
		#if(GPS_MODULE == GPS_MODULE_NMEA0183)
		NMEAINFO *pInfo;
		pInfo =(NMEAINFO *)GPS_Information();
		#elif (GPS_MODULE == GPS_MODULE_GMC1030)
		GPSRADARINFO *pInfo;
		pInfo =(GPSRADARINFO *)GPSRadar_Information();
		#endif
		OSDDraw_EnterDrawing(&bID0, &bID1);

		OSDDraw_ClearOvlDrawBuffer(bID0);

		// Enable alpha blending
		OSDDraw_SetAlphaBlending(bID0, AHC_TRUE);
		OSDDraw_SetAlphaBlending(bID1, AHC_TRUE);

	#ifdef ENABLE_GUI_SUPPORT_MULTITASK
		AHC_OSDSetColor(bID0, OSD_COLOR_BLACK);
		AHC_OSDSetColor(bID1, OSD_COLOR_BLACK);
	#else
		AHC_OSDSetColor(OSD_COLOR_BLACK);
	#endif
		AHC_OSDDrawFillRect(bID0, 0, 0, 320 ,240);
	#ifdef ENABLE_GUI_SUPPORT_MULTITASK
		AHC_OSDSetColor(bID0, OSD_COLOR_WHITE);
		AHC_OSDSetColor(bID1, OSD_COLOR_WHITE);
	#else
		AHC_OSDSetColor(OSD_COLOR_WHITE);
	#endif

	#ifdef ENABLE_GUI_SUPPORT_MULTITASK
		AHC_OSDSetPenSize(bID0, 3);
		AHC_OSDSetPenSize(bID1, 3);
	#else
		AHC_OSDSetPenSize(3);
	#endif
		//AHC_OSDDrawText(bID0, (UINT8 *)"GPS : ", 30, 60, sizeof("GPS : "));
		//AHC_OSDDrawBitmap(bID0, &bmIcon_GPSSigs, 30, 30);
		if (GPSCtrl_GPS_IsValidValue())
		{
			//AHC_OSDSetColor(OSD_COLOR_GREEN);
			//AHC_OSDDrawText(bID0, (UINT8 *)"OK", 80, 60, sizeof("OK"));
		}
		else
		{
			//AHC_OSDDrawBitmap(bID0, &bmIcon_GPSSigs, 30, 30);
		#ifdef ENABLE_GUI_SUPPORT_MULTITASK
			AHC_OSDSetPenSize(bID0, 5);
			AHC_OSDSetPenSize(bID1, 5);
			AHC_OSDSetColor(bID0, OSD_COLOR_RED);
			AHC_OSDSetColor(bID1, OSD_COLOR_RED);
		#else
			AHC_OSDSetPenSize(5);
			AHC_OSDSetColor(OSD_COLOR_RED);
		#endif
			AHC_OSDDrawLine(bID0, 60, 80, 60, 80);
			AHC_OSDDrawLine(bID0, 60, 80, 80, 60);
		#ifdef ENABLE_GUI_SUPPORT_MULTITASK
			AHC_OSDSetPenSize(bID0, 3);
			AHC_OSDSetPenSize(bID1, 3);
		#else
			AHC_OSDSetPenSize(3);
		#endif
			//AHC_OSDSetColor(OSD_COLOR_RED);
			//AHC_OSDDrawText(bID0, (UINT8 *)"FAIL", 80, 60, sizeof("FAIL"));
		}
	#ifdef ENABLE_GUI_SUPPORT_MULTITASK
		AHC_OSDSetColor(bID0, OSD_COLOR_WHITE);
		AHC_OSDSetColor(bID1, OSD_COLOR_WHITE);
	#else
		AHC_OSDSetColor(OSD_COLOR_WHITE);
	#endif
		AHC_OSDDrawText(bID0,(UINT8 *)"LAT : ", 160, 20, sizeof("LAT : "));
		if (GPSCtrl_GPS_IsValidValue())
		{
			if (pInfo->dwLat > 0)
				AHC_OSDDrawText(bID0, (UINT8 *)"N ", 200, 20, sizeof("N "));
			else
				AHC_OSDDrawText(bID0, (UINT8 *)"S ", 200, 20, sizeof("S "));

			AHC_OSDDrawFloat(bID0, GPS_ABS(pInfo->dwLat/100), 8);
		}
		else
		{
			AHC_OSDDrawFloat(bID0, 0, 8);
		}

		AHC_OSDDrawText(bID0, (UINT8 *)"LON : ", 160, 50, sizeof("LON : "));
		if (GPSCtrl_GPS_IsValidValue())
		{
			if (pInfo->dwLon > 0)
				AHC_OSDDrawText(bID0, (UINT8 *)"E ", 200, 50, sizeof("E "));
			else
				AHC_OSDDrawText(bID0, (UINT8 *)"W ", 200, 50, sizeof("W "));

			AHC_OSDDrawFloat(bID0, GPS_ABS(pInfo->dwLon/100),8);
		}
		else
		{
			AHC_OSDDrawFloat(bID0, 0, 8);
		}

		AHC_OSDDrawText(bID0, (UINT8 *)"HEI : ", 160, 80, sizeof("HEI : "));
		if (GPSCtrl_GPS_IsValidValue())
			AHC_OSDDrawFloat(bID0, pInfo->dwElv, 10);
		else
			AHC_OSDDrawFloat(bID0, 0, 8);

		AHC_OSDDrawText(bID0, (UINT8 *)"m", 270, 80, sizeof("m"));

		#if (GPS_MODULE == GPS_MODULE_NMEA0183)
		for (i = 0; i < 12; i++)
		{
			AHC_OSDDrawRect(bID0, 16+i*24, 120, 16+(i+1)*24-4, 220);
		}
		for (i = 0; i < 12; i++)
		{
			AHC_OSDDrawDec(bID0, pInfo->sSatinfo_GPS.sSat[i].iId, 16+i*24+4, 225, 2);
			if (pInfo->sSatinfo_GPS.sSat[i].iIn_use)
			{
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
				AHC_OSDSetColor(bID0, OSD_COLOR_GREEN);
				AHC_OSDSetColor(bID1, OSD_COLOR_GREEN);
			#else
				AHC_OSDSetColor(OSD_COLOR_GREEN);
			#endif
			}
			else
			{
			#ifdef ENABLE_GUI_SUPPORT_MULTITASK
				AHC_OSDSetColor(bID0, OSD_COLOR_GRAY);
				AHC_OSDSetColor(bID1, OSD_COLOR_GRAY);
			#else
				AHC_OSDSetColor(OSD_COLOR_GRAY);
			#endif
			}

			AHC_OSDDrawFillRect(bID0, 16+i*24+1, 220-pInfo->sSatinfo_GPS.sSat[i].iSig, 16+(i+1)*24-5, 219);
			
		#ifdef ENABLE_GUI_SUPPORT_MULTITASK
			AHC_OSDSetColor(bID0, OSD_COLOR_WHITE);
			AHC_OSDSetColor(bID1, OSD_COLOR_WHITE);
		#else
			AHC_OSDSetColor(OSD_COLOR_WHITE);
		#endif
			AHC_OSDDrawDec(bID0,pInfo->sSatinfo_GPS.sSat[i].iSig,16+i*24+4,170,2);
		}
		#endif

		OSDDraw_ExitDrawing(&bID0, &bID1);
	}
	else
	{
		printc("Support no GPS module in this project\r\n");
	}
}

#if (EDOG_ENABLE == 1)
void UartCmd_EDOG_Operation( char* szParam )
{
	unsigned int i, j, k, l, m, n;
//	#if (EDOG_DB_LITETYPE == 0)
//	double dLockLat, dLockLon;
//	#else
//	float dLockLat, dLockLon;
//	#endif
	MMP_BOOL bEncounter;
	MMP_UBYTE ubSpeedLimit,POItype, DirType;
	MMP_USHORT usDistance;
	MMP_ULONG ulreadback;
	POSITIONINFO  *pInfo;

    pInfo = (POSITIONINFO *)EDOGCtrl_Information();
	sscanfl( szParam, "%d %d %d %d %d %d", &i, &j, &k, &l, &m, &n);
	switch(i)
	{
		case 0:
		EDOGCtrl_Initial();
		break;
		case 1:
		EDOGCtrl_ListAllCameraInfo();
		break;
		case 2: 
		{
		MANUALSPEEDCAMERA* Temp;
		UINT32 ulTotalIndex;

		if ((j == 0) || (j > 5))
			j = 1;

		while(j) {
			EDOGCtrl_AddPOI_Manual();
			EDOGCtrl_GetTotalIndex(&ulTotalIndex);
			
			Temp = (MANUALSPEEDCAMERA*)EDOGCtrl_GetPOI_Manual(ulTotalIndex-1);
			//EDOGCtrl_UpdatePOIArray_Manual();
			printc("%d: dwLat = %f  dwLon = %f  uwYear = %d \r\n", ulTotalIndex -1, Temp->dwLat, Temp->dwLon, Temp->sRTC.uwYear);
			j--;
		}	
		} 
		break; 
		case 3:
		EDOGCtrl_RestoesPOItoFile_Manual();
		break;
		case 4:
		EDOGCtrl_ClearAllManualSetting();
		break;
		case 5:
		EDOGCtrl_ParseHeader();
		break;
		case 6:
		//EDOGCtrl_CheckSpeedCamera(&bEncounter, &ubSpeedLimit, &POItype, &DirType, &usDistance, &dLockLat, &dLockLon);
		EDOGCtrl_DeletPOI_Manual(j);
		break;
		case 7:
		{
		//EDOGCtrl_UpdatePositionInfo(j,k);
		float lat = 25.055269;
		float lon = 121.617302; 
		EDOGCtrl_UpdatePositionInfo(lat, lon);
		//EDOGCtrl_ReadPOIfromFile_Manual();
		}
		break;
		case 8:
		EDOGCtrl_UpdateSpeedCameraArray_BLOCK(j,k,0,&ulreadback);
		break;		
		case 9:
		EDOGCtrl_UpdateSpeedCameraArray_ALL();
		break;
		case 10:
		pInfo->bEncounter = j ;
		pInfo->ubSpeedLimit = k;
		pInfo->ubPOItype = l;
		pInfo->ubDirType =  m;
		pInfo->usDistance = n;
		if(pInfo->bEncounter == 1)
		{
		extern MMP_BOOL bSpeedCamStopSound; 
		pInfo->ubStatus = SPEEDCAM_STATUS_ENCOUNTER;
		bSpeedCamStopSound = MMP_TRUE;
	
		}
		else if(pInfo->ubStatus == SPEEDCAM_STATUS_ENCOUNTER)
		pInfo->ubStatus = SPEEDCAM_STATUS_STOP_ALERT;
		else
		pInfo->ubStatus = SPEEDCAM_STATUS_NO_ENCOUNTER;	
		printc("ubSpeedLimit : %d\r\n",pInfo->ubSpeedLimit);
		printc("usDistance : %d\r\n", pInfo->usDistance );
		printc("pInfo->ubStatus : %d\r\n",pInfo->ubStatus);
		break;
		case 11:
		EDOGCtrl_TestCode();
		break;
		case 12:
		pInfo->bEncounter = 1 ;
		pInfo->ubSpeedLimit = 100;
		pInfo->ubPOItype = 5;
		pInfo->ubDirType =  2;
		pInfo->usDistance = 200;
		pInfo->ubStatus = SPEEDCAM_STATUS_ENCOUNTER;
		break;
		case 13:
		pInfo->bEncounter = 1 ;
		pInfo->ubSpeedLimit = 100;
		pInfo->ubPOItype = 5;
		pInfo->ubDirType =  2;
		pInfo->usDistance = 200;
		pInfo->ubStatus = SPEEDCAM_STATUS_APPROACH;
		
		break;
		case 14:
		pInfo->bEncounter = 1 ;
		pInfo->ubSpeedLimit = 100;
		pInfo->ubPOItype = 5;
		pInfo->ubDirType =  2;
		pInfo->usDistance = 30;
		pInfo->ubStatus = SPEEDCAM_STATUS_STOP_ALERT;
		break;
		case 15:
		pInfo->bEncounter = 0 ;
		pInfo->ubSpeedLimit = 100;
		pInfo->ubPOItype = 5;
		pInfo->ubDirType =  2;
		pInfo->usDistance = 30;
		pInfo->ubStatus = SPEEDCAM_STATUS_NO_ENCOUNTER;
		break;
		default:
		break;
	}
}
#endif // (EDOG_ENABLE == 1)

void UartCmd_GPS_Operation(char* szParam)
{
	if (AHC_GPS_Module_Attached())
	{
		unsigned int 	i,j,k;
		#if (GPS_MODULE == GPS_MODULE_NMEA0183)
		NMEAINFO 		*pInfo;
		#elif (GPS_MODULE == GPS_MODULE_GMC1030)
		GPSRADARINFO 	*pInfo;
		#endif

		sscanfl(szParam, "%d %d %d", &i, &j, &k);
		switch (i)
		{
			case 0:
			printc("GPS_Initialize\r\n");
			GPSCtrl_Initial();
			break;
			case 1:
			printc("Uart 1 Rx on/off\r\n");
			GPSCtrl_ControlGPSPath(j);
			break;
			case 2:
			printc("Show GPS Information:\r\n");
			#if (GPS_MODULE == GPS_MODULE_NMEA0183)
			pInfo = (NMEAINFO *)GPS_Information();
			GPSCtrl_DubugMessageInfo(pInfo);
			#elif (GPS_MODULE == GPS_MODULE_GMC1030)
			pInfo = (GPSRADARINFO *)GPSRadar_Information();
			GPSCtrl_DubugMessageInfo(pInfo);
			#endif
			break;
			case 3:
			printc("Draw GPS Information\r\n");
			GPS_DrawInformationPage();
			break;		
			#if (GPS_CONFIG_NMEA_FILE)
			case 4:
			GPSCtrl_Verification();
			break;
			#endif
			case 5:
			#if (GPS_MODULE == GPS_MODULE_NMEA0183)
			GPS_InitPathUART_E_DOG();
			#endif
			break;
			case 6:
			#if (GPS_MODULE == GPS_MODULE_GMC1030)
			GPSRadar_SetCommand_GMC1030(j,k);
			#endif
			#if (GPS_MODULE == GPS_MODULE_NMEA0183)
			GPS_SetCommand_NMEA0183((NMEACOMMAND_TYPE)j);
			#endif
			break;
			case 7:
			printc("GPS_UnInitial\r\n");
			GPSCtrl_UnInitial();
			break;
			case 8:
			GPSCtrl_GetFirstLocationTime(NULL);
			break;
			case 9:
			{
				GPS_LOG sGPSlog={0};
				
				sGPSlog.ulLogID = 0x55AA55AA;
				sGPSlog.psDateTime.uwYear = 1900;
				sGPSlog.psDateTime.uwMonth = 01;
				sGPSlog.psDateTime.uwDay = 01;
				sGPSlog.psDateTime.uwHour = 01;
				sGPSlog.psDateTime.uwMinute = 01;
				sGPSlog.psDateTime.uwSecond = 01;
				
				GPSCtrl_SetFirstLocationTime(&sGPSlog);
			}
			break;
			
			
		}
	}
	else
	{
		printc("Support no GPS module in this project\r\n");
	}
}

#if (GPS_MODULE == GPS_MODULE_NMEA0183)
extern unsigned int	dump_nmeaflag;

#define	NEAM_PREFIX_NUM			5

int strcmpi(char *s1, char *s2);

static char	*nmea_pre[] = {"?", "RMC", "GGA", "GSA", "GSV", "VTG"};
/*
 * Command NMEA: NMEA {? | RMC | GGA | GSA | GSV | VTG}*
 * Ex:	help - NMEA ?<enter>
 *		Dump all of NMEA	NMEA<enter>
 *		Disable dump		NMEA<enter>
 *		Dump RMC of NMEA	NMEA RMC<enter>
 *		Dump RMC and GGA	NMEA RMC GGA<enter>
 */
#endif

void UartCmd_NMEA_Info(char *param)
{
	if (AHC_GPS_Module_Attached())
	{
		#if (GPS_MODULE == GPS_MODULE_NMEA0183)
		int 	i;
		char 	*ptr;
		char 	nmea[NEAM_PREFIX_NUM][8];

		ptr = param;
		SKIP_SPACE(ptr);
		memset(nmea, 0, NEAM_PREFIX_NUM * 8);
		if (strlen(ptr) >= NEAM_PREFIX_NUM * 8)
		{
			// protect buffer, but...
			goto HELP_NMEA;
		}
		i = sscanfl(ptr, "%s %s %s %s %s", nmea[0], nmea[1], nmea[2], nmea[3], nmea[4]);
		if (i == 0)
		{
			if (dump_nmeaflag)
				dump_nmeaflag = 0;
			else
				dump_nmeaflag = D_RMC | D_GGA | D_GSA | D_GSV | D_VTG;
			return;
		}
		dump_nmeaflag = 0;
		for (; i >= 0 ; i--)
		{
			int j;

			for (j = 0; j < (sizeof(nmea_pre) / sizeof(char*)); j++)
			{
				if (strcmpi(nmea[i], nmea_pre[j]) == 0)
				{
					if (j == 0)
					{
						goto HELP_NMEA;
					}
					dump_nmeaflag |= (1 << (j - 1));
					break;
				}
			}
		}
		return;
	HELP_NMEA:
		printc("EX: NMEA {? | RMC | GGA | GSA | GSV | VTG}*\r\n");
		#endif
		return;
	}
	else
	{
		printc("Support no GPS module in this project\r\n");
	}
}
#endif // (GPS_CONNECT_ENABLE)

#if GSENSOR_CONNECT_ENABLE
#include "GSensor_ctrl.h"
extern AHC_BOOL  dump_GValues;
void UartCmd_Gsensor_Test( char* szParam )
{
	if(AHC_Gsensor_Module_Attached())
	{
		UINT8           i;
		UINT16          ubvalue;
		UINT16          ubReg, ubRegValue;
		
		sscanfl( szParam, "%d, %x, %x", &i, &ubReg, &ubRegValue);
		switch(i)
		{
		case 0:
			AHC_Gsensor_IOControl(GSNR_CMD_RESET, NULL);
		break;
		case 1:
			AHC_Gsensor_Initial();
		break;
		case 2:
			AHC_Gsensor_WriteRegister(ubReg,ubRegValue);
			AHC_Gsensor_ReadRegister(ubReg,&ubvalue);
			printc("Set Gsensor Reg : 0x%x, Value: 0x%x",ubReg, ubvalue);
		break;
		case 3:
			AHC_Gsensor_ReadRegister(ubReg,&ubvalue);
			printc("Read Gsensor Reg : 0x%x, Value: 0x%x",ubReg, ubvalue);
		break;
		case 4:
			if(dump_GValues)
			dump_GValues = AHC_FALSE;
			else
			dump_GValues = AHC_TRUE;
		break;
		case 5:
			//AHC_Gsensor_Register();
			break;
		case 6:
			//AHC_Gsensor_UnRegister();
			break;
		}
	}else
	{
		printc("Support no Gsensor module in this project!\r\n");
	}
	
	
}	
#endif

#if (GYROSENSOR_CONNECT_ENABLE)
#include "mmpf_gyrosensor.h"
#include "mmpf_scaler.h"
#if (SUPPORT_EIS)
void EIS_test(char* szParam)
{
	MMP_ULONG st, end;
	MMP_USHORT  a = 0, b = 0;
	char str[16] = {0};
	INT32 x, y, t;

	sscanfl(szParam, "%s, %d, %d", str, &a, &b);
	if (strcmpi(str, "vif") == 0) {
		MMP_USHORT 	usVifPixelStart;
		MMP_USHORT 	usVifPixelEnd;
		MMP_USHORT 	usVifLineStart;
		MMP_USHORT 	usVifLineEnd;
	
		MMPF_VIF_GetGrabPosition(0,
                             &usVifPixelStart, 
    						 &usVifPixelEnd,
    						 &usVifLineStart,
    						 &usVifLineEnd );
		printc("VIF window=%d,%d,%d,%d\r\n", 
			usVifPixelStart, usVifPixelEnd, usVifLineStart, usVifLineEnd);
	} else if (strcmpi(str, "r_gyro") == 0) {
		MMPF_3RDParty_Gyrosensor_ReadRegister((MMP_UBYTE)a, (MMP_UBYTE *)&b);
		printc("Gyro reg[0x%x] = 0x%x\r\n", a, b&0xFF);
	} else if (strcmpi(str, "w_gyro") == 0) {		
		MMPF_3RDParty_Gyrosensor_WriteRegister((MMP_UBYTE)a, (MMP_UBYTE)b);
	} else if (strcmpi(str, "r_xyt") == 0) {
		st = MMPF_OsCounterGetUs();
		MMPF_3RDParty_Gyrosensor_ReadXYT(&x, &y, &t);
		end = MMPF_OsCounterGetUs();
		printc("Gyro x = %d, y = %d, t = %d, time=%d\r\n", x, y, t, end-st);
	} else if (strcmpi(str, "r_xy") == 0) {		
		st = MMPF_OsCounterGetUs();
		MMPF_3RDParty_Gyrosensor_ReadXY(&x, &y);
		end = MMPF_OsCounterGetUs();
		printc("Gyro x = %d, y = %d, time=%d\r\n", x, y, end-st);
	} else if (strcmpi(str, "log") == 0) {
		static UINT32 log_cnt = 0;
		char fn[64] = "SD:0:\\log_";
		gyro_log_t g_log = {0};
		
		sprintf(fn + strlen(fn), "%04u.bin", log_cnt);

		if (!a)
			a = 10; // sec
		g_log.ndata = a;
		MMPF_EIS_start_gyro_log(GYRO_LOG_TEST, &g_log, fn);
		log_cnt ++;
		if (log_cnt == 10000)
			log_cnt = 0;
	} else if (strcmpi(str, "getg") == 0) {		
		UINT16 grab_st_x0, grab_end_x0, grab_st_y0, grab_end_y0;
		MMPF_Scaler_GetGrabPosition(a, MMP_SCAL_GRAB_STAGE_LPF, &grab_st_x0, &grab_end_x0, &grab_st_y0, &grab_end_y0); 
		printc("pipe %d,ori pos=(%d,%d,%d,%d)\r\n", (MMP_SHORT)a,grab_st_x0,grab_end_x0,grab_st_y0,grab_end_y0);
	} else if (strcmpi(str, "setg") == 0) {
		extern UINT16 grab_st_x0, grab_end_x0, grab_st_y0, grab_end_y0;
		printc("pipe %d,mov window x=%d,y=%d,ori pos=(%d,%d,%d,%d)\r\n", (MMP_SHORT)a, (MMP_SHORT)b, (MMP_SHORT)b,grab_st_x0,grab_end_x0,grab_st_y0,grab_end_y0);
		MMPF_Scaler_SetGrabPosition(a,
									MMP_SCAL_GRAB_STAGE_LPF,
									grab_st_x0+(MMP_SHORT)b, grab_end_x0+(MMP_SHORT)b,
									grab_st_y0+(MMP_SHORT)b, grab_end_y0+(MMP_SHORT)b);	
	} else if (strcmpi(str, "on") == 0) {
		MMPF_EIS_enable(1);
	} else if (strcmpi(str, "off") == 0) {
		MMPF_EIS_enable(0);
	}
}
#endif
void UartCmd_Gyrosensor_Test( char* szParam )
{
#if 0	
	UINT8           i;
	UINT8           ubvalue;
	UINT8           ubReg, ubRegValue;
	
	sscanfl( szParam, "%d, %x, %x", &i, &ubReg, &ubRegValue);
	switch(i)
	{
	case 0:
		Gyrosensor_Initial();
	break;
	case 1:
		Gyrosensor_WriteReg(ubReg,ubRegValue);
		Gyrosensor_ReadReg(ubReg,&ubvalue);
	break;
	case 2:
		Gyrosensor_ReadReg(ubReg,&ubvalue);
	break;
	case 3:
	break;
	}
	
#endif	
}	
#endif

void UartCmd_PlaysoundTest( char* szParam )
{
    unsigned int i;
	sscanfl( szParam, "%d %d", &i);

    if( i >= AHC_SOUNDEFFECT_MAX_NUM )
    {
        i %= AHC_SOUNDEFFECT_MAX_NUM;
        printc("sound id max is %d\n", AHC_SOUNDEFFECT_MAX_NUM );
    }
    
    AHC_PlaySoundEffect(i);
}

#if (MOTION_DETECTION_EN)
AHC_BOOL 	AHC_GetMotionDtcSensitivity(UINT8 *pubMvTh, UINT8 *pubCntTh);
int 		AHC_SetMotionDtcSensitivity(unsigned char mvth,  unsigned char cnth);

void UartCmd_MDP(char *param)
{
	char 			*ptr;
	unsigned char 	a1, a2;

	ptr = param;
	SKIP_SPACE(ptr);
	if (sscanfl(ptr, "%d %d", &a1, &a2) == 2)
	{
		AHC_SetMotionDtcSensitivity(a1, a2);
		printc("Set OK\r\n");
	}
	else
	{
		AHC_GetMotionDtcSensitivity(&a1, &a2);
		printc("MVth %d, CNth %d\r\n", a1, a2);
	}
}
#endif // (MOTION_DETECTION_EN)

void UartCmd_LowBatterySim(char *szParam)
{
#if !defined(CAR_DV)
	AHC_BOOL Enable;

	sscanfl(szParam, "%d", &Enable);
	if (Enable)
		printc("Start Low Battery Test\r\n");
	else
		printc("Stop Low Battery Test\r\n");
	ubLowBatteryTest = Enable;
#endif
}

void UartCmd_Test2( char* szParam )
{
    AHC_IsCalibrationMode();
}

#if (MSDC_SUPPORT_SECRECY_LOCK)
void UartCmd_Set_MSDC_Lock( char* szParam )
{
	MMP_UBYTE ubEnable;
	
	sscanfl( szParam, "%d", &ubEnable);	

	#if (MSDC_SUPPORT_SECRECY_LOCK)	
	AHC_SetMsdcSecrecyLock(ubEnable);
	#endif
}
#endif

#include "mmpf_i2cm.h"
#if 0
static MMP_I2CM_ATTR  m_TouchPanelI2c = {MMP_I2CM1,     //MMPF_I2CM_ID i2cmID;             //MMP_I2CM0 ~ MMP_I2CM2 stand for HW I2CM                                                                
                                               0x4D>>1,             //MMP_UBYTE ubSlaveAddr;                                                                                                                              
                                               0,                   //MMP_UBYTE ubRegLen;              //Indicate register as the 8 bit mode or 16 bit mode.                                                              
                                               8,                   //MMP_UBYTE ubDataLen;             //Indicate data as the 8 bit mode or 16 bit mode.                                                                  
                                               0x20,                //MMP_UBYTE ubDelayTime;           //The delay time after each ACK/NACK, which is used in SW I2CM (i2cmID = MMP_I2CM_GPIO or MMP_I2CM_SNR)
                                               MMP_FALSE,           //MMP_BOOL  bDelayWaitEn;          //HW feature, to set delay between each I2CM accessing set                                                         
                                               MMP_FALSE,           //MMP_BOOL  bInputFilterEn;        //HW feature, to filter input noise                                                                                
                                               MMP_FALSE,           //MMP_BOOL  b10BitModeEn;          //HW I2CM supports 10 bit slave address, the bit8 and bit9 are in ubSlaveAddr1                                     
                                               MMP_FALSE,           //MMP_BOOL  bClkStretchEn;         //HW support stretch clock                                                                                         
                                               0x0,                 //MMP_UBYTE ubSlaveAddr1;          //10 bit slave address support used.                                                                               
                                               0x0,                 //MMP_UBYTE ubDelayCycle;          //When bDelayWaitEn enable, set the delay cycle after each 8 bit transmission                                      
                                                //3
                                               0x5,                 //MMP_UBYTE ubPadNum;              //HW pad map, the relate pad definition, please refer global register spec.                                        
                                               100000 /*100KHZ*/,   //MMP_ULONG ulI2cmSpeed;           //SW and HW I2CM speed control, the unit is HZ.                                                                    
                                               MMP_TRUE,            //MMP_BOOL  bOsProtectEn;          //Enable: I2CM driver with OS semaphore protect.                                                                   
                                               NULL,                //MMP_GPIO_PIN sw_clk_pin;         //Used in SW I2CM (i2cmID = MMP_I2CM_GPIO only), indicate the clock pin                                          
                                               NULL,                //MMP_GPIO_PIN sw_data_pin;        //Used in SW I2CM (i2cmID = MMP_I2CM_GPIO only), indicate the data pin                                           
                                               MMP_TRUE,            //MMP_BOOL  bRfclModeEn;           //Used in read from current location mode. Read data without send register address.                                
                                               MMP_TRUE};           //MMP_BOOL  bWfclModeEn;           //Used in write from current location mode. Write data without send register address.                              
                                                                    
#else
static MMP_I2CM_ATTR  m_TouchPanelI2c = {MMP_I2CM_GPIO,     //MMPF_I2CM_ID i2cmID;             //MMP_I2CM0 ~ MMP_I2CM2 stand for HW I2CM                                                                
                                               0x4C,             //MMP_UBYTE ubSlaveAddr;                                                                                                                              
                                               0,                   //MMP_UBYTE ubRegLen;              //Indicate register as the 8 bit mode or 16 bit mode.                                                              
                                               8,                   //MMP_UBYTE ubDataLen;             //Indicate data as the 8 bit mode or 16 bit mode.                                                                  
                                               10,                 //MMP_UBYTE ubDelayTime;           //The delay time after each ACK/NACK, which is used in SW I2CM (i2cmID = MMP_I2CM_GPIO or MMP_I2CM_SNR)
                                               MMP_FALSE,           //MMP_BOOL  bDelayWaitEn;          //HW feature, to set delay between each I2CM accessing set                                                         
                                               MMP_FALSE,           //MMP_BOOL  bInputFilterEn;        //HW feature, to filter input noise                                                                                
                                               MMP_FALSE,           //MMP_BOOL  b10BitModeEn;          //HW I2CM supports 10 bit slave address, the bit8 and bit9 are in ubSlaveAddr1                                     
                                               MMP_FALSE,           //MMP_BOOL  bClkStretchEn;         //HW support stretch clock                                                                                         
                                               0x0,                 //MMP_UBYTE ubSlaveAddr1;          //10 bit slave address support used.                                                                               
                                               0x0,                 //MMP_UBYTE ubDelayCycle;          //When bDelayWaitEn enable, set the delay cycle after each 8 bit transmission                                      
                                               0x3,                 //MMP_UBYTE ubPadNum;              //HW pad map, the relate pad definition, please refer global register spec.                                        
                                               50000 /*100KHZ*/,   //MMP_ULONG ulI2cmSpeed;           //SW and HW I2CM speed control, the unit is HZ.                                                                    
                                               MMP_FALSE,            //MMP_BOOL  bOsProtectEn;          //Enable: I2CM driver with OS semaphore protect.                                                                   
                                                MMP_GPIO38,                //MMP_GPIO_PIN sw_clk_pin;         //Used in SW I2CM (i2cmID = MMP_I2CM_GPIO only), indicate the clock pin                                          
                                                MMP_GPIO39,                //MMP_GPIO_PIN sw_data_pin;        //Used in SW I2CM (i2cmID = MMP_I2CM_GPIO only), indicate the data pin                                           

//                                               MMP_GPIO16,                //MMP_GPIO_PIN sw_clk_pin;         //Used in SW I2CM (i2cmID = MMP_I2CM_GPIO only), indicate the clock pin                                          
//                                               MMP_GPIO17,                //MMP_GPIO_PIN sw_data_pin;        //Used in SW I2CM (i2cmID = MMP_I2CM_GPIO only), indicate the data pin                                           
                                               MMP_TRUE,            //MMP_BOOL  bRfclModeEn;           //Used in read from current location mode. Read data without send register address.                                
                                               MMP_TRUE};           //MMP_BOOL  bWfclModeEn; 
#endif                                               

USHORT usReadData[64]={0};

BYTE Calculate_8BitsChecksum( USHORT *msg, int s32Length )
{
	int s32Checksum = 0;
	int i;

	for ( i = 0 ; i < s32Length; i++ )
	{
		s32Checksum += msg[i];
	}
	return (BYTE)( ( -s32Checksum ) & 0xFF );
}

typedef struct tagTouchPoint
{
	int x;
	int y;
} TPoint;

static int bTpDebug = 0;

static BOOL TouchPanelGetPos( USHORT Buf[8], TPoint* pPt1, TPoint* pPt2 )
{

	TPoint pt1={0},pt2={0};
	int Fingers=0;
	if(Buf[0]==0x52 &&Buf[7] == Calculate_8BitsChecksum( Buf, 7))
	{
		pt1.x=((Buf[1] & 0xF0)<<4)|Buf[2];
		pt1.y=((Buf[1] & 0x0F)<<8)|Buf[3];
		pt2.x=((Buf[4] & 0xF0)<<4)|Buf[5];
		pt2.y=((Buf[4] & 0x0F)<<8)|Buf[6];

		if((pt2.x) & 0x0800)
		{
			pt2.x |= 0xF000;
		}
		if((pt2.y) & 0x0800)
		{
			pt2.y |= 0xF000;
		}

		pt2.x+=pt1.x;
		pt2.y+=pt1.y;

		if(Buf[1]== 0xFF&& Buf[2]== 0xFF&& Buf[3]== 0xFF)
		{
			Fingers = 0;//Touch End
		}
		else if((pt1.x == pt2.x) && (pt1.y == pt2.y))
		{
			Fingers = 1;
		}
		else
		{
			Fingers = 2;
		}

        *pPt1 = pt1;
        *pPt2 = pt2;

       	printc( "tp %d=(%d,%d),(%d,%d) \n", Fingers, pt1.x, pt1.y, pt2.x, pt2.y );

	}
    else if( bTpDebug)
    {
        printc( "tp %d=(%d,%d),(%d,%d) \n", Fingers, pt1.x, pt1.y, pt2.x, pt2.y );
    }

//  Last time
    return TRUE;
}

static void TOUCH_ISR(MMP_GPIO_PIN piopin)
{
    MMP_UBYTE  tempValue = 0;
    MMP_ULONG  ulNow;    
    TPoint pt1, pt2;

    printc("ti\n");
    MMPF_PIO_GetData( piopin, &tempValue);
    MMPF_OS_GetTime(&ulNow); 
    //MMPF_I2cm_ReadBurstDataWithDelay(&m_TouchPanelI2c, NULL, usReadData, 8, 210); //Rogers:***
    if( bTpDebug)
    {
        MemoryDump((char*)usReadData, 0x16);
    }
    TouchPanelGetPos(usReadData, &pt1, &pt2 );

}

static void InitTouchGpio( MMP_GPIO_PIN piopin, GpioCallBackFunc* CallBackFunc  )
{
    if(piopin == MMP_GPIO_MAX)
		return;

    //Set GPIO as input mode
    MMPF_PIO_EnableOutputMode(piopin, MMP_FALSE, MMP_TRUE);

    // Set the trigger mode.
    MMPF_PIO_EnableTrigMode(piopin, GPIO_H2L_EDGE_TRIG, MMP_TRUE, MMP_TRUE);
//    MMPF_PIO_EnableTrigMode(piopin, GPIO_L2H_EDGE_TRIG, MMP_TRUE, MMP_TRUE);
    
    //Enable Interrupt
    MMPF_PIO_EnableInterrupt(piopin, MMP_TRUE, 0, (GpioCallBackFunc *)CallBackFunc, MMP_TRUE);
}

int TouchPanel_Init0(void)
{
	if(TOUCH_RESET_GPIO != 0xFFF)
	{
		AHC_ConfigGPIO(MMP_GPIO50, AHC_TRUE);	
		AHC_SetGPIO(MMP_GPIO50, AHC_TRUE);
	}
    MMPF_OS_Sleep_MS(100);

    InitTouchGpio(MMP_GPIO40, (GpioCallBackFunc*) TOUCH_ISR );

    MMPF_PIO_EnableOutputMode(MMP_GPIO38, MMP_FALSE, MMP_TRUE );
    MMPF_PIO_EnableOutputMode(MMP_GPIO39, MMP_FALSE, MMP_TRUE );

    // Write PD0 = 0, to enable interrupt pin.
    return 1;
}

void UART_TouchPanel0(char* szParam)
{
    sscanfl(szParam, "%d", &bTpDebug);


    TouchPanel_Init0();
}

void UART_TouchPanel1(char* szParam)
{
    printc("UART_TouchPanel1\n");
    //TouchPanel_Init();
}

void UART_TouchPanel2(char* szParam)
{

    MMPF_I2cm_ReadBurstData(&m_TouchPanelI2c, NULL, usReadData, 0x64);

}

void UART_GPIO(char* szParam)
{
    int gpio =0xFFF;
    int output =0;
    int value =0;

    sscanfl(szParam, "%d %d %d", &gpio, &output, &value);


    MMPF_PIO_EnableOutputMode(gpio, output, MMP_TRUE );

    AHC_ConfigGPIO(gpio, output);   

    if( output )
    {
		AHC_SetGPIO(gpio, value);        
        printc("Set GPIO%d = %d\n", gpio, value);

    }
    else
    {
        UINT8 ubVal;
		AHC_GetGPIO(gpio, &ubVal);
        printc("Read GPIO%d = %d\n", gpio, ubVal);
        
    }

}

extern void RTNA_LCD_Init(void);
void UART_LCD_INIT(char* szParam)
{
    RTNA_LCD_Init();
}


void VideoRecordCbMotionDtc1(void)
{
    //printc(" ## Motion ##\r\n");
    //OSD_Draw_TestMessage(100,10,4," ===motion detected===");//set
    printc("111\n");
}

void UartCmd_SetRecordGain(char* szParam)
{
	UINT8 RAgain, RDgain;
	AHC_BOOL  RBoosterOn;
	
    UINT8 ubOldAgain;
    UINT8 ubOldDgain;
    AHC_BOOL  ubOldBoosterOn;
	
	sscanfl( szParam, "%X %X %d", &RDgain, &RAgain, &RBoosterOn);
	
	printc("The original settings : \r\n");
	AHC_GetVRVolumeParam(&ubOldDgain, &ubOldAgain, &ubOldBoosterOn);
	
	printc("D gain : 0x%x\r\n",ubOldDgain);
	printc("A gain : 0x%x\r\n",ubOldAgain);	
	printc("Booster : %d\r\n" ,ubOldBoosterOn);

	
	printc("Your settings : \r\n");
	printc("D gain : 0x%x\r\n",RDgain);
	printc("A gain : 0x%x\r\n",RAgain);	
	printc("Booster : %d\r\n" ,RBoosterOn);
			
	AHC_SetVRVolumeParam(RDgain, RAgain, RBoosterOn);
	
}

void UartCmd_GetRecordGain(char* szParam)
{
    ULONG iDGain;
    ULONG iLAGain;
    ULONG iRAGain;
	AHC_BOOL  bBoosterOn;
	AHC_GetVRVolume(&iDGain, &iLAGain, &iRAGain, &bBoosterOn);

	return;
}

void UartCmd_PrintBatteryLevel(char* szParam)
{
#if !defined(CAR_DV)
	if (ubStartPrintBattery)
		ubStartPrintBattery = AHC_FALSE;
	else
		ubStartPrintBattery = AHC_TRUE;
#endif
}

void UartCmd_SetSpeaker(char* szParam)
{
    UINT32 uiOnOff;
	
	sscanfl( szParam, "%d", &uiOnOff);
	
    if(uiOnOff == 1){
        printc("Speaker On\n");
        AHC_SpeakerEnable(SPEAKER_ENABLE_GPIO,AHC_TRUE);    
    }else{
    
        printc("Speaker Off\n");
        AHC_SpeakerEnable(SPEAKER_ENABLE_GPIO,AHC_FALSE);    
    }

}

void UartCmd_repeatPlay(char* szParam)
{
#if 0  //mark because Mio project compiler error  //lucas
    UINT32 ustatus;
    UINT32      ObjSelect   = 0;
    UINT32      MaxObjIdx   = 0;
    AHC_BOOL ahc_ret = AHC_TRUE;

    printc("[repeatPlay]\n");


    AHC_UF_GetTotalFileCount(&MaxObjIdx);

    if(MaxObjIdx != 0){

        AHC_UF_GetCurrentIndex(&ObjSelect);

        if(ObjSelect != -1)
        {
            if(!AHC_CheckCurSysMode(AHC_MODE_THUMB_BROWSER))
            {
                printc("[repeatPlay]  no in browser mode \n");
            }
            else
            {
                ahc_ret = AHC_SetMode(AHC_MODE_IDLE);
                 SetCurrentOpMode(MOVPB_MODE);
//                ahc_ret = AHC_SetMode(AHC_MODE_PLAYBACK);

                 MovPlaybackParamReset();
                 MovPBFunc_CheckLCDstatus();

                 MediaPlaybackConfig(PLAYBACK_CURRENT);
                 MovPlayback_Play();
                 MovPBFunc_ResetPlaySpeed();
                 //MovPBTimer2_Start(200);
//                 printc("[repeatPlay]   3\n");
            }

        }
    }
#endif
}

void UartCmd_AE_Mio(char* szParam)//for Mio AE table debug,ex: m 300
{
	int stillcnt;
	sscanfl( szParam, "%d,",&stillcnt);
	ISP_IF_AE_SetEVTargetOffset(stillcnt);
}

void UartCmd_CopyAll(char* szParam)
{
	AHC_UF_CopyOneCardFiles(AHC_MEDIA_MMC, AHC_MEDIA_MMC1);
}

void UartCmd_LDWS_Enable(char* szParam)//for Mio AE table debug,ex: m 300
{
	AHC_BOOL bEnable;
	sscanfl( szParam, "%d,",&bEnable);
	//ISP_IF_AE_SetEVTargetOffset(stillcnt);
	AHC_EnableADAS(bEnable);
}

/*******************************************************************************
 *
 *   UART COMMAND LIST SAMPLE
 *
*******************************************************************************/

UARTCOMMAND sUartCommandSample2[] =
{
    { "mode",         " Mode ",            "AHC_SetMode",               UartCmdMode },
    { "mount",        " Mount ",           "AHC_MountStorageMedia",     UartCmdMount },
	{ "esd",           "",                 "ESD Simulation",            UartCmdESD },	
	{ "ver",           "",                 "print version",             UartCmdPrintVersion },
    { "format",        " id ",             "format media",              UartCmdFormat },
    { "chkstk",        "",                 "Check task stack",          UartCmdCheckTaskStack },    
    { "tt",            "",                 "Print all task",            UartCmdTaskTable },    
    { "rt",            "",                 "Print ready Task",          UartCmdReadyTable },    
    { "ct",            "",                 "Print current task",        UartCmdCurrentTask },    
    { "key",           "",                 "Send Key event",            UartCmd_KeyDef},

    {"lcdinit"               , "",   "", UART_LCD_INIT },

    {"gpio"               , "gpio out val",   "read write gpio", UART_GPIO },

    {"tp0"               , "sound_id",   "playback sound effect", UART_TouchPanel0 },
    {"tp1"               , "sound_id",   "playback sound effect", UART_TouchPanel1 },        
    {"tp2"               , "sound_id",   "playback sound effect", UART_TouchPanel2 },
    
    {"test2"               , "sound_id",   "playback sound effect", UartCmd_Test2 },

    {"snd"                 , "sound_id",   "playback sound effect", UartCmd_PlaysoundTest },
    {"movz"                 , "dir steps",   "move zoom motor", UartCmd_MotorZoomMove },
    {"movf"                 , "dir steps",   "move focus motor", UartCmd_MotorFocusMove },        
    {"mt"                 , "",   "", UartCmd_MotorTest },

    {"motor_reg_read"                 , "ch reg ch_rd bitsize",   "motor reg read", UartCmd_MotorRegRead },
    {"motor_reg_write"                , "ch reg wdata",   "motor reg write", UartCmd_MotorRegWrite },
    {"power_off"                 , "",   "power off device", UartCmd_PowerOff },
    {"dump_dcf"                  , "dump dcf db",   "Dump dcf database", UartCmd_DcfDumpDb },

    {"vif_delay_cell"                  , "dDelayCell",   "Set VIF delay cell, the dDelayCell value is 0 ~ 3", UartCmd_SensorSetDelayCell },
    {"rk"                  , "",   "UartCmdSensorPsenCtrl",UartCmdReadKey     },

//    {"psen"                  , "",   "UartCmdSensorPsenCtrl",UartCmdSensorPsenCtrl     },
    {"sr"                  , "reg-X",          "UartCmdReadSensorI2c",UartCmdReadSensorI2c     },
    {"sw"                  , "reg-X data-X",   "UartCmdWriteSensorI2c",UartCmdWriteSensorI2c     },

    {"hdat"                  , "",   "UartCmdReadZFOUT",UartCmdReadZFOUT     },
    {"pi"                  , " device enable",   "Enable PI    ",UartCmdEnablePi     },

    {"osdst"                  , " id enable type weight",   "UartOSDSetSemiTransparent    ",UartOSDSetSemiTransparent     },
    {"osdte"                , " id enable color ",   "UartOSDSetTransparentEnable  ",UartOSDSetTransparentEnable   },
    {"osdal"                     , " id enable ",   "UartOSDSetAlphaBlendingEnable",UartOSDSetAlphaBlendingEnable },
    {"osdrot"                       , "                ",   "UartOSDSetRotate             ",UartOSDSetRotate              },
    {"osdmirr"                      , "                ",   "UartOSDSetMirror             ",UartOSDSetMirror              },
    {"osdinit"                      , " w h colorformat",   "UartOSDInit                  ",UartOSDInit                   },
    {"osduninit"                      , "",   "UartOSDUninit                  ",UartOSDUninit                   },
    {"osdcbuf"                     , "                ",   "UartOSDCreateBuffer          ",UartOSDCreateBuffer           },
    {"osdgcd"					, " 			   ",	"UartOSDGetCurrentDisplay	  ",UartOSDGetCurrentDisplay	  },
    {"osdscd"                   , "                ",   "UartOSDSetCurrentDisplay     ",UartOSDSetCurrentDisplay      },
    {"osdgatt"					, " 			   ",	"UartOSDGetDisplayAttr	  ",UartOSDGetDisplayAttr	  },
    {"osdrf"                   , "                ",   "UartOSDRefresh               ",UartOSDRefresh                },
    {"osda"                         , "                ",   "UartOSDSetSetActive          ",UartOSDSetSetActive           },
    {"osdcls"                       , "                ",   "UartOSDSetClearBuffer        ",UartOSDSetClearBuffer         },
    {"osddelbuf"                   , "                ",   "UartOSDDestroyBuffer         ",UartOSDDestroyBuffer          },
    {"osdsc"                  , "                ",   "UartOSDSetColor              ",UartOSDSetColor               },
    {"osdp"                        , "                ",   "UartOSDDrawPixel             ",UartOSDDrawPixel              },
    {"osdrect"                     , "                ",   "UartOSDDrawRect              ",UartOSDDrawRect               },
    {"osdfillroundrect"                , "                ",   "UartOSDDrawRoundedRect       ",UartOSDDrawFillRoundedRect        },
    {"osdfrect"                    , "                ",   "UartOSDDrawFillRect          ",UartOSDDrawFillRect           },
    {"osdirect"                    , "                ",   "UartOSDDrawInvertRect        ",UartOSDDrawInvertRect         },
    {"osdtext"                     , "                ",   "UartOSDDrawText              ",UartOSDDrawText               },
    {"osdjpeg"                     , "                ",   "UartOSDDrawJpeg              ",UartOSDDrawJpeg               },
    {"sdfmt"                     , "                ",   "UartFormatSD              ",UartFormatSD               },
    {"ocg"                     , "                ",   "OsCounterGet              ",UartCounterGet               },    
    {"oci"                     , "                ",   "OsCounterInit              ",UartCounterInit               },
    #if (SUPPORT_TIMING_MARK == 1)
    {"tmi"                     , "                ",   "OsCounterInit              ",UartTimingMarkInit          },
    {"tm"                     , "                ",   "OsCounterInit              ",UartTimingMark               },
    {"tmd"                     , "                ",   "OsCounterInit              ",UartTimingMarkDump          },
    #endif
    {"dump_adas"               , "dump ADAS para  ","Dump ADAS Init params         ",Uartcmd_DumpADASPara        },
	{"chg"                     , "                ",   "UartCmdChargerOperation 0xFF-detect\r\n 0-100mA\r\n 1-500mA\r\n 2-1.5A\r\n 3-Suspend",UartCmdChargerOperation          },
	{0,0,0,0}
};
//******************************************************************************
#if (WIFI_PORT == 1)
void UartCmd_NETCommands(char* szParam);
void UartCmd_WifiCommands(char* szParam);
void UartCmd_V4l(char* szParam)
{
#if 0//Andy Liu TBD    
    void dbg_dump_v4l(MMP_M_STREAMCB_CODEC codec);
    dbg_dump_v4l(0/*JPEG*/);//take szParam as parameter later
#endif    
}
#endif
//******************************************************************************

// CarDV TY Miao
void UartCmd_TV_Test( char* szParam )
{
    MMP_TV_TYPE tvType;
    MMP_BOOL turnOn;
    UINT32 type, on, barType;

    sscanfl( szParam, "%d, %d, %d", &on, &type, &barType);
    tvType = (type == 0) ? MMP_TV_TYPE_NTSC : MMP_TV_TYPE_PAL;
    turnOn = (MMP_BOOL) on;
    barType &= 0x01;

    MMPD_System_TVColorBar(tvType, turnOn, (MMP_UBYTE) barType);
}

void UartCmd_TV_GetBrightness( char* szParam )
{
    MMP_UBYTE ubLevel;
    
    MMPD_TV_GetBrightLevel(&ubLevel);
    
    printc("TV Beightness level is 0x%02X\r\n", ubLevel);
}

void UartCmd_TV_SetBrightness( char* szParam )
{
    MMP_UBYTE ubLevel;
    
    sscanfl( szParam, "%X", &ubLevel);
    printc("New TV Brightness = 0x%X\r\n", ubLevel);
    MMPD_TV_SetBrightLevel(ubLevel);
}

void UartCmd_TV_GetContrast( char* szParam )
{
    MMP_USHORT usLevel;

    usLevel &= 0x01FF;
    
    MMPD_TV_GetContrast(&usLevel);
    
    printc("TV Contrast level is 0x%04X\r\n", usLevel);
}

void UartCmd_TV_SetContrast( char* szParam )
{
    MMP_USHORT usLevel;
    
    sscanfl( szParam, "%X", &usLevel);
    printc("New TV Contrast = 0x%X\r\n", usLevel);
    MMPD_TV_SetContrast(usLevel);
}

void UartCmd_TV_GetSaturation( char* szParam )
{
    MMP_UBYTE ubULevel, ubVLevel;
    
    MMPD_TV_GetSaturation(&ubULevel, &ubVLevel);
    
    printc("TV Saturation level is 0x%02X, 0x%02X\r\n", ubULevel, ubVLevel);
}

void UartCmd_TV_SetSaturation( char* szParam )
{
    MMP_DISPLAY_OUTPUT_SEL displayDevice;
    MMP_UBYTE ubULevel, ubVLevel;
    MMP_LONG ulRatio;

    MMPS_Display_GetOutputPanel(MMP_DISPLAY_PRM_CTL, &displayDevice);
    
    sscanfl( szParam, "%X", &ubULevel);

    if (MMP_DISPLAY_SEL_NTSC_TV == displayDevice) {
        ulRatio = ((MMP_LONG) ubULevel) * 1000 / 0x40;      // default is 0x40            
        ubVLevel = ulRatio * 0x5A / 1000;                   // default is 0x5A
    }
    else if (MMP_DISPLAY_SEL_PAL_TV == displayDevice) {
        ulRatio = ((MMP_LONG) ubULevel) * 1000 / 0x45;      // default is 0x45            
        ubVLevel = ulRatio * 0x62 / 1000;                   // default is 0x62
    }
    else {
        return;
    }

    printc("New TV Saturation U=0x%X, V=0x%X\r\n", ubULevel, ubVLevel);

    MMPD_TV_SetSaturation(ubULevel, ubVLevel);
}

void UartCmd_TV_SetGamma( char* szParam )
{
    MMP_SHORT          		param0,param1,param2,
                            param3,param4,param5,
                            param6,param7,param8;
    MMP_DISPLAY_TV_GAMMA DSPY_TVGamma;
    printc("Gamma value 0~4096\r\n");
	sscanfl( szParam, "%d %d %d %d %d %d %d %d %d",
	                    &(param0),
	                    &(param1),
	                    &(param2),
	                    &(param3),
	                    &param4,
	                    &param5,                        
	                    &param6,                        
	                    &param7,                        
	                    &param8                        
	                    );
	DSPY_TVGamma.usGamma0 = param0;
	DSPY_TVGamma.usGamma1 = param1;
	DSPY_TVGamma.usGamma2 = param2;
	DSPY_TVGamma.usGamma3 = param3;
	DSPY_TVGamma.usGamma4 = param4;
	DSPY_TVGamma.usGamma5 = param5;
	DSPY_TVGamma.usGamma6 = param6;
	DSPY_TVGamma.usGamma7 = param7;
	DSPY_TVGamma.usGamma8 = param8;
	                    
    printc("DSPY_TVGamma.usGamma0 = %d\r\n",DSPY_TVGamma.usGamma0);
    printc("DSPY_TVGamma.usGamma1 = %d\r\n",DSPY_TVGamma.usGamma1);
    printc("DSPY_TVGamma.usGamma2 = %d\r\n",DSPY_TVGamma.usGamma2);
    printc("DSPY_TVGamma.usGamma3 = %d\r\n",DSPY_TVGamma.usGamma3);
    printc("DSPY_TVGamma.usGamma4 = %d\r\n",DSPY_TVGamma.usGamma4);
    printc("DSPY_TVGamma.usGamma5 = %d\r\n",DSPY_TVGamma.usGamma5);
    printc("DSPY_TVGamma.usGamma6 = %d\r\n",DSPY_TVGamma.usGamma6);
    printc("DSPY_TVGamma.usGamma7 = %d\r\n",DSPY_TVGamma.usGamma7);
    printc("DSPY_TVGamma.usGamma8 = %d\r\n",DSPY_TVGamma.usGamma8);
    AIHC_Display_SetTVGamma(DSPY_TVGamma);
}


void UartCmd_TV_GetGamma( char* szParam )
{
    MMP_DISPLAY_TV_GAMMA DSPY_TVGamma;
    AIHC_Display_GetTVGamma(&DSPY_TVGamma);
    printc("TVGamma0 = %d\r\n",DSPY_TVGamma.usGamma0);
    printc("TVGamma1 = %d\r\n",DSPY_TVGamma.usGamma1);
    printc("TVGamma2 = %d\r\n",DSPY_TVGamma.usGamma2);
    printc("TVGamma3 = %d\r\n",DSPY_TVGamma.usGamma3);
    printc("TVGamma4 = %d\r\n",DSPY_TVGamma.usGamma4);
    printc("TVGamma5 = %d\r\n",DSPY_TVGamma.usGamma5);
    printc("TVGamma6 = %d\r\n",DSPY_TVGamma.usGamma6);
    printc("TVGamma7 = %d\r\n",DSPY_TVGamma.usGamma7);
    printc("TVGamma8 = %d\r\n",DSPY_TVGamma.usGamma8);
}
void UartCmd_SetDspyColorMatrix( char* szParam )
{
    MMP_SHORT          		param0,param1,param2,param3,param4,param5;
    MMP_DISPLAY_WIN_ID      winID = MMP_DISPLAY_WIN_PIP;
    MMP_DISPLAY_WIN_COLRMTX DspyColrMtx;
    MMP_BOOL                bApplyColMtx = MMP_TRUE;

	sscanfl( szParam, "%d %d %d %d %d %d",
	                    &(param0),
	                    &(param1),
	                    &(param2),
	                    &(param3),
	                    &param4,
	                    &param5                        
	                    );
	DspyColrMtx.sUVGainFactMtx[0][0] = param0;
	DspyColrMtx.sUVGainFactMtx[0][1] = param1;
	DspyColrMtx.sUVGainFactMtx[1][0] = param2;
	DspyColrMtx.sUVGainFactMtx[1][1] = param3;
	DspyColrMtx.ubRGBGAIN = param4;
	DspyColrMtx.ubRGBOFST = param5;
	                    
    printc("g11 = %d\r\n",DspyColrMtx.sUVGainFactMtx[0][0]);
    printc("g12 = %d\r\n",DspyColrMtx.sUVGainFactMtx[0][1]);
    printc("g21 = %d\r\n",DspyColrMtx.sUVGainFactMtx[1][0]);
    printc("g22 = %d\r\n",DspyColrMtx.sUVGainFactMtx[1][1]);
    printc("RGB gain = %d\r\n",DspyColrMtx.ubRGBGAIN);
    printc("RGB offset = %d\r\n",DspyColrMtx.ubRGBOFST);
    MMPS_Display_AdjustWinColorMatrix(winID, &DspyColrMtx, bApplyColMtx);
}



void UartCmd_DDOSD ( char* szParam )
{
#if (DDOSD)
	UINT8  	bID0 = 0;

	OSDDraw_GetLastOvlDrawBuffer(&bID0);
	
	AHC_DDOSD_Init();

	AHC_DDOSD_AddIcon("Icon_Btn_TestBut.bin", STRLEN("Icon_Btn_TestBut.bin"));
    
    AHC_DDOSD_DrawBitmap(bID0, (char *)"bmIcon_Btn_TestBut", 130, 90);	
#endif	
}

void UartCmd_FormatFree( char* szParam )
{
#if (FS_FORMAT_FREE_ENABLE)
    UINT16 uiItem   = 0;
    UINT16 uiParam1 = 0;
    UINT16 uiParam2 = 0;
    AHC_BOOL bOK = AHC_FALSE;
    
	sscanfl( szParam, "%d %d %d",&uiItem, &uiParam1, &uiParam2);

    switch( uiItem ) 
    {
        case 0: 
            bOK = AHC_CheckMedia_FormatFree(uiParam1);
            printc("AHC_CheckMedia_FormatFree = 0x%d\r\n", bOK);
            break;
            
        case 1: 
            bOK = AHC_FormatStorageMedia_FormatFree(uiParam1);
            printc("AHC_FormatStorageMedia_FormatFree = 0x%d\r\n", bOK);
            break;
                
        case 2: 
            break;
    }
#endif	
}


#include "aitu_ringbuf.h"
#define USER_DEFINE_SAMPLE_CNT (512)
#define LIVE_PCM_BUFF_MAX_CNT (2048*50)
MMP_SHORT LivePCMTmpBuff[LIVE_PCM_BUFF_MAX_CNT] = {0};
MMP_ULONG LivePCMRdIdx = 0;  

void LivePCMReadOut(AUTL_RINGBUF pPCMOutRing,MMP_SHORT *target, MMP_ULONG samples) 
{    
    MMP_BYTE *ring_data;
    MMP_ULONG  ring_end_ofst;

    ring_data = (MMP_BYTE *)pPCMOutRing.buf + pPCMOutRing.ptr.rd;
    ring_end_ofst = pPCMOutRing.size - pPCMOutRing.ptr.rd;

    if (ring_end_ofst >= samples) {
        MEMCPY(target, ring_data, samples << 1);
    }
    else {
        MEMCPY(target, ring_data, ring_end_ofst << 1);
        samples  -= ring_end_ofst;
        target   += ring_end_ofst;
        ring_data = (MMP_BYTE *)pPCMOutRing.buf;
        MEMCPY(target, ring_data, samples << 1);
    }

}

MMP_ULONG LivePCMTransferCB(AUTL_RINGBUF *pPCMOutRing, MMP_ULONG ulUnReadSampleCnt) 
{   

    printc("LivePCMTransferCB: %d (0x%x)\r\n", ulUnReadSampleCnt, pPCMOutRing);
    
    if(pPCMOutRing == NULL) {
        return  0;
    }
    
    if((ulUnReadSampleCnt > 0) && (ulUnReadSampleCnt >= USER_DEFINE_SAMPLE_CNT)) {
        if(LivePCMRdIdx+USER_DEFINE_SAMPLE_CNT <= LIVE_PCM_BUFF_MAX_CNT){                
            LivePCMReadOut(*pPCMOutRing, &LivePCMTmpBuff[LivePCMRdIdx], USER_DEFINE_SAMPLE_CNT);  
            LivePCMRdIdx+=USER_DEFINE_SAMPLE_CNT;
            return  USER_DEFINE_SAMPLE_CNT;
        }
        else {
            RTNA_DBG_Str0("Debug Live PCM buffer full \r\n");
            RTNA_DBG_Str0("Total samples: ");
            RTNA_DBG_Long0(LivePCMRdIdx);
            RTNA_DBG_Str0("\r\n");
        }
    }
    
    return  0;
}


void UartCmd_LiveAudio( char* szParam )
{

    UINT16 uiItem   = 0;
    UINT16 uiParam1 = 0;
    UINT16 uiParam2 = 0;
    MMP_ULONG ulAdcSampleRate = 16000;
    
	sscanfl( szParam, "%d %d %d",&uiItem, &uiParam1, &uiParam2);

    switch( uiItem ) 
    {
        case 1:
            if( uiParam1 > 16000 )
            {
                ulAdcSampleRate = (MMP_ULONG)uiParam1;
            }
            printc("1. Initial Live PCM Transfer setting: %d Hz\r\n", ulAdcSampleRate);
            MMPS_AUDIO_InitLiveRecord(MMPS_AUDIO_PCM_ENCODE, 0, ulAdcSampleRate, (MMP_LivePCMCB)LivePCMTransferCB);
            break;
            
        case 2: 
            printc("2. Start Live PCM Transfer\r\n");
            MMPS_LiveAudio_StartRecord(); 
            break;
                
        case 3: 
            printc("3. Stop  Live PCM Transfer\r\n");
            MMPS_LiveAudio_StopRecord(); 
            break;
    }

}




UARTCOMMAND sUartCommandSample3[] =
{
	//
	{ "aelogstart", 	"",		   				" Start AE log to file",      	UartCmd_AE_Log_Start },
	{ "aelogend", 		"",		   				" Save AE log to file",      	UartCmd_Save_AE_Log },
		
	{ "aflog", 			"",   					" Save AF log to file",      	UartCmd_Save_AF_Log },
	{ "acclog", 			"",   				" Save ACC log to file",      	UartCmd_Save_ACC_Log },
	{ "aewnd", 			"",   					" Get AE window size",      	UartCmd_AE_Get_Wnd_Size },

	//
	{ "setscn", 		"scn", 	  				" set scene mode", 				UartCmd_SetSceneMode },
	{ "getscn", 		"", 					" get scene mode",				UartCmd_GetSceneMode },

	{ "setie", 			"mode", 	  			" set image effect mode", 		UartCmd_SetImageEffectMode },
	{ "getie", 			"", 	  				" get image effect mode", 		UartCmd_GetImageEffectMode },
	{ "setsatlv", 		"mode", 	  			" set saturation level (-100~100)", 		UartCmd_SetSatLevel },

    //
	{ "ae", 			"",		 	  			" AE Enable/Disable",      		UartCmd_AE_Enable },
	{ "af", 			"",   					" AF Enable/Disable",      		UartCmd_AF_Enable },
	{ "awb", 			"",   					" AWB Enable/Disable",      	UartCmd_AWB_Enable },
	{ "fd", 			"",   					" Face Detection Enable/Disable",      	UartCmd_FD_Enable },
	{ "getfd", 			"",   					" Get Face Detection Result",      	UartCmd_GetFDResult},
	{ "afzt", 		"", 	  					" enable/disable af zoom track mode", 		UartCmd_AF_ZTModeEnable },
	//
	{ "getaeacc", 		" windowIndex ",   		" Get AE ACC by window ",      	UartCmd_Get_AE_WndACC },
	{ "getawbacc", 		" windowIndex ",   		" Get AWB ACC by window ",      UartCmd_Get_AWB_WndACC },
	{ "getacc", 		" windowIndex ",   		" Get AEAWB ACC by window ",    UartCmd_Get_WndACC },
	{ "afacc", 			" windowIndex ",   		" Get AF ACC by window", 		UartCmd_Get_AFACC },
	{ "getaewndsz", 	"",   					" Get AE wnd size ",      		UartCmd_Get_AE_WndDiv },
	//
	{ "preview", 		" 0/1 ",   				" DSC preview Enable/Disable", 	UartCmd_DSC_Preview },		
	{ "previewmode", 	" 0/1 ",   				" Preview mode: 1080p/720p", 	UartCmd_Preview_Mode },

	{ "setjpgq", 	"",   				" Set JPEG Quality", 	UartCmd_SetJpegQuality },
		
	{ "res", 			"",   					" get preview resolution", 		UartCmd_Preview_Get_Resolution },
	{ "setres", 		"",   					" set preview resolution", 		UartCmd_Preview_Set_Resolution },
	//
	{ "scres",			"", 					" get still capture resolution",		UartCmd_StillCapture_Get_Resolution },
	{ "setscres", 		"", 					" set still capture resolution",		UartCmd_StillCapture_Set_Resolution },
	
	{ "setaemode", 		"",   					" Switch AE mode(0:Auto 1:ISO_PRIORITY)", 		UartCmd_SetAeMode },
	{ "getaemode", 		"",   					" Get AE mode(0:Auto 1:ISO_PRIORITY)", 		UartCmd_GetAeMode },	

	{ "setaelockmode", 		"",   					" Switch AE Lock mode", 		UartCmd_SetAeLockMode },
	{ "getaelockmode", 		"",   					" Get AE Lock mode", 		UartCmd_GetAeLockMode },
	{ "setaeisomode", 		"",   					" Switch AE ISO mode", 		UartCmd_SetAeIsoMode },
	{ "getaeisomode", 		"",   					" Get AE ISO mode", 		UartCmd_GetAeIsoMode },
	{ "setaeevbiasmode", 		"",   					" Switch AE ev bias mode", 		UartCmd_SetAeEvBiasMode },
	{ "getaeevbiasmode", 		"",   					" Get AE ev bias mode", 		UartCmd_GetAeEvBiasMode },
	{ "setaemetermode", 		"",   					" Switch AE Metering mode", 		UartCmd_SetAeMeterMode },
	{ "getaemetermode", 		"",   					" Get AE Metering mode", 		UartCmd_GetAeMeterMode },
	{ "setis", 		"",   					" Switch Still Image Stablizer mode", 		UartCmd_SetAeSISMode },
	{ "getis", 		"",   					" Get Still Image Stablizer mode", 		UartCmd_GetAeSISMode },
		
	{ "getflk", 				"",   					" Get AE Flicker mode", 		UartCmd_GetAeFlickerMode },
	{ "setflk", 				"",   					" Set AE Flicker mode", 		UartCmd_SetAeFlickerMode },

	{ "gettrow", 				"",   					" Get Sensor T row", 		UartCmd_GetSnrTRow },
		
	{ "getaespd", 				"",   					" Get AE speed mode", 			UartCmd_GetAeSpeedMode },
	{ "setaespd", 				"",   					" Set AE speed mode", 			UartCmd_SetAeSpeedMode },
	{ "getaeslowshutter", 				"",   					" Get AE Slow shutter mode", 			UartCmd_GetAeSlowShutMode },
	{ "setaeslowshutter", 				"",   					" Set AE Slow shutter mode", 			UartCmd_SetAeSlowShutMode },
	{ "setaemaxagain", 			"", 					 "Set AE Max Again time(ex.1,2,3...)", 		UartCmd_AE_Set_MaxAgainMultiple },
	{ "getaemaxagain", 			"", 					 "Set AE Max Again time(ex.1,2,3...)", 		UartCmd_AE_Get_MaxAgainMultiple },
	{ "setaemaxdgain", 			"", 					 "Set AE Max Dgain time(ex.1,2,3...)", 		UartCmd_AE_Set_MaxDgainMultiple },
	{ "getaemaxdgain", 			"", 					 "Set AE Max Dgain time(ex.1,2,3...)", 		UartCmd_AE_Get_MaxDgainMultiple },
	{ "setaemaxtotalgain", 		"", 					 "Set AE Max Totalgain time(ex.1,2,3...,40)", 		UartCmd_AE_Set_MaxTotalGainMultiple },
	{ "getaemaxtotalgain", 		"", 					 "Set AE Max Totalgain time(ex.1,2,3...,40)", 		UartCmd_AE_Get_MaxTotalGainMultiple },
	
	//manual AE
	{ "setaetv", 		"",   					" Set AE Tv", 		UartCmd_AE_SetTv },
	{ "setaesv", 		"",   					" Set AE Sv", 		UartCmd_AE_SetSv },
	{ "getaetv", 		"",   					" Get AE Tv", 		UartCmd_AE_GetTv },
	{ "getaesv", 		"",   					" Get AE Sv", 		UartCmd_AE_GetSv },
	{ "getshuttermode", 		"",   			" Get AE shutter mode", 		UartCmd_AE_GetShutterMode },
	{ "setshuttermode", 		"",   			" Set AE shutter mode", 		UartCmd_AE_SetShutterMode },
	{ "setaemanualagain", 	" gain ",   		" set manual sensor AGain", 			UartCmd_Set_AE_Manual_AGain },
	{ "setaemanualdgain", 	" gain ",   		" set manual sensor DGain", 			UartCmd_Set_AE_Manual_DGain },

	{ "getaemanualexptime", 		"",   			" Get AE shutter mode", 		UartCmd_Get_AE_Manual_ExpTime },
	{ "setaemanualexptime", 		"",   			" Set AE shutter mode", 		UartCmd_Set_AE_Manual_ExpTime },
	{ "getaeggain", 		"",   			" Get AE gamma gain parameters", 		UartCmd_Get_AE_GGainParm },
	{ "setaeggain", 		"",   			" Set AE gamma gain parameters", 		UartCmd_Set_AE_GGainParm },
	{ "getaemaxsvtype", 		"",   			" Get AE max sv type", 		UartCmd_Get_AE_MaxSvType },
	{ "setaemaxsvtype", 		"",   			" Set AE max sv type", 		UartCmd_Set_AE_MaxSvType },

	{ "setawbmode", 		"",   					" Switch AWB mode", 		UartCmd_SetAWBMode },
	{ "getawbmode", 		"",   					" Get AWB mode", 		UartCmd_GetAWBMode },
	{ "setwb1pt", 		"",   					   " Set WB One Puse Trigger ", 		UartCmd_SetWBOnePushTrig },
	//
	{ "afpos", 			" pos ",   				" move af motor to target pos", UartCmd_AFMotor_Move_To },
	{ "cfp", 			" pos ",   				" Current focus position", UartCmd_CurrFocusPosi },
	{ "zoompos", 		" pos ",   				" move zoom motor to target pos", UartCmd_ZoomMotor_Move_To },
	{ "czp", 		" pos ",   				" Current zoom position", UartCmd_CurrZoomPosi },
	{ "stillaf", 		"", 	  				" still af operation ", 		UartCmd_AF_Still_Opr },
	{ "getafinfpos", 		"", 	  				" get af inf position", 		UartCmd_AF_GetInfPos },
	{ "setafinfpos", 		"", 	  				" set af inf position", 		UartCmd_AF_SetInfPos },
	{ "getafcurr2infpos", 		"", 	  				" get af curr to inf position", 	UartCmd_AF_GetCurr2InfPos },
	{ "setafcurr2infpos", 		"", 	  				" set af curr inf position", 		UartCmd_AF_SetCurr2InfPos },
	{ "getafstyle", 		"", 	  				" get af style", 		UartCmd_AF_GetStyle },
	{ "setafstyle", 		"", 	  				" set af style", 		UartCmd_AF_SetStyle },
	{ "getafmovietype", 		"", 	  				" get af movie type", 		UartCmd_AF_GetMovieType },
	{ "setafmovietype", 		"", 	  				" set af movie type", 		UartCmd_AF_SetMovieType },
	{ "getafmanrge", 		"", 	  				" get af manual range mode", 		UartCmd_AF_GetManRgeMode },
	{ "setafmanrge", 		"", 	  				" set af manual range mode", 		UartCmd_AF_SetManRgeMode },
	{ "afmanpos", 		"", 	  				" set af manual position", 		UartCmd_AF_SetManAfPos },
	{ "getafmovparm", 		"", 	  				" get af movie parameters", 		UartCmd_AF_GetAitMOVParms },
	{ "setafmovparm", 		"", 	  				" set af movie parameters", 		UartCmd_AF_SetAitMOVParms },
	{ "setafactspt", 		"", 	  				" set af active spot", 		UartCmd_AF_SetActiveSpot },

	{ "getiqparm", 		"", 	  				" get IQ tuning parameters", 		UartCmd_AF_GetAitIQTuningParms },
	{ "setiqparm", 		"", 	  				" set IQ tuning parameters", 		UartCmd_AF_SetAitIQTuningParms },

	{ "setviflch", 		"", 	  				" set VIF Latch Byte", 		UartCmd_SetVifLatchByte },
	{ "setsnrreg", 		"", 	  				" set Sensor I2C Register", 		UartCmd_SetSnrReg },
	{ "setcolorid",		"", 					" set color ID", 		UartCmd_SetISPColorID },

	//
	{ "ispdgain", 		" gain ",   			" set isp digital gain", 		UartCmd_Set_ISP_DGain },
	{ "setexptime", 	" mSec ",   			" set exposure time", 			UartCmd_Set_ExpTime },
	{ "getexptime", 	" mSec ",   			" get exposure time", 			UartCmd_Get_ExpTime },
	{ "setaeagain", 	" gain ",   			" set sensor AGain", 			UartCmd_Set_AE_AGain },
	{ "setaedgain", 	" gain ",   			" set sensor DGain", 			UartCmd_Set_AE_DGain },
	{ "mtinit", 	    " mt ",   			" motor init",              UartCmd_Motor_Init},
	{ "zofd", 	        " mt ",   			" motor forward", 			UartCmd_Motor_Forward },
	{ "zobd", 	        " mt ",   			" motor backward", 			UartCmd_Motor_Backward },
	{ "zostop", 	        " mt ",   			" motor Stop", 			UartCmd_Motor_Stop },
	{ "zohome", 	        " mt ",   			" motor Home", 			UartCmd_Zoom_Home },
	{ "zotest", 	        " mt ",   			" motor test", 			UartCmd_ZoomMotor_Selftest},
	{ "fotest", 	        " mt ",   			" motor test", 			UartCmd_FocusMotor_Selftest},
	{ "foset", 	        " mt ",   			" motor test", 			UartCmd_Motor_SetAF},
	{ "fohome", 	        " mt ",   			" motor Home", 			UartCmd_Focus_Home },
	{ "fostop", 	        " mt ",   			" motor Home", 			UartCmd_Focus_Stop },
	{ "foext", 	        " mt ",   			" ExciteCtrl", 			UartCmdMotorExciteCtrl },
	{ "fostat", 	        " mt ",   			" ExciteCtrl", 			UartCmdMotorStatus },
	{ "switch", 	        "media",   			" switch media", 			UartCmd_Media_Switch },
	{ "nandspa", 	        "nand",   			" nand operation r/w, reg", UartCmd_NAND_Operation },
	{ "ps", 	        "sound",   			" play sound effect in NAND", UartCmd_PlaySound_Operation },
	{ "lds", 	        "sound",   			" load sound effect into Dram", UartCmd_LoadSound_Operation },
	{ "sv", 	        "sound",   			" Set volume in DB", UartCmd_SetAudioVolun_DB_Operation},
	{ "initISPvalue", 	    "Calibration",   			" Write default value to disk", UartCmd_Init_ISP_Value_Operation},
	{ "wISPvalue", 	        "Calibration",   			" Write default value from disk", UartCmd_Write_ISP_Value_Operation},
	{ "rISPvalue", 	        "Calibration",   			" Read default value to disk", UartCmd_Read_ISP_Value_Operation},
	{ "wMenuvalue", 	        "Menu",   			" Write Menu settings value to disk", UartCmd_Write_Menu_Value_Operation},
	{ "rMenuvalue", 	        "Menu",   			" Read Menu settings value from disk", UartCmd_Read_Menu_Value_Operation},
	{ "wSharpnessC",        "Calibration",             " Write sharpness center", UartCmd_Write_Sharpness_Center},
    { "wSharpness",        "Calibration",             " Write sharpness Level", UartCmd_Write_Sharpness_Level},
	{ "wGammaC",             "Calibration",             " Write gamma center", UartCmd_Write_Gamma_Center},
	{ "wGamma",             "Calibration",             " Write gamma Level", UartCmd_Write_Gamma_Level},
	{ "wContrastC",          "Calibration",             " Write contrast center", UartCmd_Write_Contrast_Center},
	{ "wContrast",          "Calibration",             " Write contrast Level", UartCmd_Write_Contrast_Level},
	{ "wSaturateC",          "Calibration",             " Write Saturate center", UartCmd_Write_Saturate_Center},
	{ "wSaturate",        "Calibration",             " Write Saturate Level", UartCmd_Write_Saturate_Level},
	{ "createFact", 	        "Menu",   			" Create Factory Menu settings to disk", UartCmd_Create_Factory_Settings_Operation},
	{ "rn", 	        "NAND",   			" Read NAND value ", UartCmd_ReadNAND_Operation},
	{ "wn", 	        "NAND",   			" Writh NAND value", UartCmd_WriteNAND_Operation},
	{ "lcdcolmtx", 	        "LCD",   			" Set LCD color matrix", UartCmd_SetDspyColorMatrix},
	{ "lcdbri", 	        "LCD",   			" Set LCD brightness, 0~255 default 64", UartCmd_SetLCDBrightness_Operation},
	{ "lcdcont", 	        "LCD",   			" Set LCD contrast, 0~255 default 64", UartCmd_SetLCDContrast_Operation},
	{ "lcdbri_r", 	        "LCD",   			" Set LCD Red brightness, 0~127 default 64", UartCmd_SetLCDBrightness_R_Operation},
	{ "lcdcont_r", 	        "LCD",   			" Set LCD Red contrast, 0~127 default 64", UartCmd_SetLCDContrast_R_Operation},
	{ "lcdbri_b", 	        "LCD",   			" Set LCD Blue brightness, 0~127 default 64", UartCmd_SetLCDBrightness_B_Operation},
	{ "lcdcont_b", 	        "LCD",   			" Set LCD Blue contrast, 0~127 default 64", UartCmd_SetLCDContrast_B_Operation},
	{ "lcdinv", 	        "LCD",   			" Invert LCD", UartCmd_LCD_Direction_Operation},
	{ "lcdwr", 	        "LCD",   			" Write LCD register", UartCmd_WriteLCDReg_Operation},
	{ "lcddotclk", 	        "LCD",   			" Get RGB dot clock", UartOSDGetRGBDotClk},
        
	{ "setrtc", 	        "RTC",   			" SetRTCValue", UartCmd_SetRTCValue_Operation},
	{ "getrtc", 	        "RTC",   			" GetRTCValue", UartCmd_GetRTCValue_Operation},
	{ "2003lenst", 			"PMU", 	  			    " Get The ADC value of lens temperature", 		UartCmd_ADX2003_ADC_Measure_Lens_Temp },
	{ "2003poweroff", 			"PMU", 	  			    " Disable DCDC and LDO to powerdown system", 		UartCmd_ADX2003_PowerOff},	
	{ "sleepmode", 			"PMU", 	  			    " Enable/Disable slppemode", 		UartCmd_SleepMode},	
	{ "wrPMU", 			"PMU", 	  			    " Write reg of PMU", 		UartCmd_PMU_ADC_WriteRegister },
	{ "rrPMU", 			"PMU", 	  			    " red reg from PMU", 		UartCmd_PMU_ADC_ReadRegister },
	{ "getawbgainwhiteblock", 	"", 	  				" get awb R G B gain",		 				UartCmd_AWB_GetRGB_Gain_WhiteBlkCnt },
	{ "afgetresult", 			"", 	  				" get af result", 							UartCmd_AF_GetResult },
	{ "stillafpos", 			"", 	  				" get stillaf pos",		 					UartCmd_AF_GetStillafPos },
	{ "lscsraw", 				"", 	  				" LS and CS calibration", 					UartCmd_LSCS_Raw },

	{ "ispmod", 				"", 	  				"ISP Module switch", 					UartCmd_ISPModuleSwitch },
	{ "sdctest", 				"", 	  				"SDC test", 					UartCmd_SDCTest },
    { "wdr", 					"", 	  				"WDR", 					UartCmd_WDR },

	// calibration related UART command ------------------------------
	// add by casio

	{ "afinfposcali", 			"", 	 " af infinity position calibration", 	UartCmd_AF_Inf_Pos_Cali },
	{ "lscscali", 				"", 	 " Save Raw after LS and CS shading", 	UartCmd_LSCS_Cali },
	{ "aeawbcali", 				"", 	 " AE and AWB1 Calibration", 		UartCmd_AEAWB_Cali },
	{ "awb0cali", 				"", 	 " AWB0 Calibration", 		UartCmd_AWBHiLo_Cali },
	{ "awbcaldata", 			"", 	 " AWB Calculate data", 		UartCmd_AWBCalcData },
	{ "getawbxy", 				"", 	 " Get AWB XY value", 		UartCmd_GetAWBXY_Cali },
	{ "getawbrgb", 				"", 	 " Get AWB RGB value", 		UartCmd_GetAWBRgb_Cali },
	{ "getid", 					"", 	 " Get ISP condtion id and Again,Dgain,Exptime", 		UartCmd_ISP_Get_ID },
	{ "aecali", 				"", 	 " Save Raw after LS and CS shading and calibration data for AE Calibration", 		UartCmd_AE_Cali },
	{ "aemingainchk", 			"", 	 " Check AE minimum gain check", 		UartCmd_AE_MinGainChk },
	{ "setlscsfromsd", 			"", 	 " Set LS CS table from AitOutBin.bin from SD card", 		UartCmd_LSCS_SetFromSD },
	{ "getraw", 				"", 	 " Get Raw after off shading", 		UartCmd_Raw_beforeISP },
	{ "getraw2",           	    "",      " Get raw data", 				    UartCmd_GetRaw},
	{ "getcsraw", 				"", 	 " Get Raw after Luma/Chroma shading", 		UartCmd_Raw_AfterCS },
	{ "setcontrast", 			"", 	 " Set contrast", 					UartCmd_SetContrast },
	{ "getcontrast", 			"", 	 " Get contrast", 					UartCmd_GetContrast },
	{ "setsharpness", 			"", 	 " Set sharpness", 					UartCmd_SetSharpness },
	{ "getsharpness", 			"", 	 " Get sharpness", 					UartCmd_GetSharpness },
	{ "getjpg", 				"", 	 " Get capture jpeg", 				UartCmd_GetJPG },
	{ "setcancelflick", 		"", 	 " Set cancel flicker mode", 		UartCmd_SetCancelFlickMode },
	{ "getcancelflick", 		"", 	 " Get cancel flicker mode", 		UartCmd_SetCancelFlickMode },
	{ "setdbbrk",               "",      " Set dbg break",                  UartCmdSetDebugBreak },
	{ "getdbbrk",               "",      " Get dbg break",                  UartCmdGetDebugBreak },
	
	{ "Burnin", 	        " mt ",   			" motor test", 			UartCmd_ZoomMotor_Burnin},

	{ "checkispbin", 			"", 	  			" Check calibration bin data", 	UartCmd_CheckCaliBin },
	{ "genispbin", 			"", 	  				" Read calibration bin data and generate isp bin", 	UartCmd_ReadCaliBinToSD },
	{ "rdcalibin", 			"", 	  				" Read calibration bin data and write it to flash", 	UartCmd_ReadCaliBinToFlash },
	{ "rstcalibin", 			"", 	  			" Reset calibration flash data to uncalibrated", 		UartCmd_ResetCaliBinToFlash },
	{ "dbg_l",       " dbg_level ",      "set dbg level",       UartCmdSetDebugLevel },
	{ "fm",          "",                 "Show function menu",  UartCmdFunctionMenu  },
	{ "usbmode" , " var1 "      , "Set usb mode"  , UartCmdUsbSetMode  },	
	 
	// HDMI UART command ------------------------------
	// add by rogers
	{ "hdmi", 			"", 	  			    " HDMI output", 		UartCmd_HDMI },
	{ "tv", 			"", 	  			    " TV", 		        UartCmd_TV },
	{ "t", 			    "", 	  			    " Test", 		        UartCmd_Test },
	{ "sdm", 			"", 	  			    " SetDisplayMode", 		UartCmd_SetDisplayMode },
	{ "rf", 			"", 	  			    " DisplayRefresh",      UartCmd_DisplayRefresh },
	{ "bl", 			"", 	  			    " Backlight",               UartCmd_Backlight },
	{ "errormsg", 	    "", 	  			    " Error message", 		UartCmd_ErrorMSG },
	{ "lensmsg", 	    "", 	  			    " Lens Error message",  UartCmd_ErrorMSG_Lens },
	{ "vrp", 			"", 	  			    " Video Record Pause",  UartCmd_VR_Pause },
	{ "vrr", 			"", 	  			    " Video Record Resume",  UartCmd_VR_Resume },
	{ "ui", 			"", 	  			    " UI test",             UartCmd_UI },
	{ "swp", 			"", 					" SetWinPriority", 			UartCmd_SetWinPriority },


    //Message
    { "canh", 			"", 	  			    " HDMI Get Event Enable", 		UartCmd_CanSendHDMIEvent },
    { "sendh", 			"", 	  			    " HDMI Send Event Enable", 		UartCmd_HDMISendEventEnable },
	{ "sendm", 			"", 	  			    " Send AHL Message Enable", 	UartCmd_SendAHLMessageEnable },
    
	// strobe
	{ "strobeinit", 			"",   " UartCmd_StrobeInit",         UartCmd_StrobeInit},
	{ "strobecharge", 			"",   " UartCmd_StrobeCharge",       UartCmd_StrobeCharge},
	{ "strobeready", 			"",   " UartCmd_StrobeReady",        UartCmd_StrobeReady},
	{ "strobetriggerinit", 		"",   " UartCmd_StrobeTriggerInit",  UartCmd_StrobeTriggerInit},
	{ "strobetrigger", 			"",   " UartCmd_StrobeTrigger",      UartCmd_StrobeTrigger},
	
	{ "setgain", 			"<Dgain> <Again> <Booster>", 	"Video record Gain", 					UartCmd_SetRecordGain },
	{ "getgain", 			"<Dgain> <Again> <Booster>", 	"Video record Gain", 					UartCmd_GetRecordGain },
	{ "battery", 			"", 							"Enable/Disable print battery level", 	UartCmd_PrintBatteryLevel },
	{ "speaker", 			"", 							"Enable/Disable speaker", 				UartCmd_SetSpeaker },
	{ "m", 					"", 							"set evtarget offset", 					UartCmd_AE_Mio }, // for Mio AE debug
	
	{ "uis",           		"",                     		" Show Current UI State", UartCmd_UIS         },
	#if 1//lucas add for Mark test
	{ "repeatplay", 			"",   "repeat Play current video file",      UartCmd_repeatPlay},
	#endif
	
	#if (GPS_CONNECT_ENABLE)
	{ "GPSOP", 				"", 							"GPS related Operation", 				UartCmd_GPS_Operation },
	{ "NMEA", 				"", 							"GPS NMEA Info.", 						UartCmd_NMEA_Info },
	#endif
	#if (EDOG_ENABLE == 1 && GPS_CONNECT_ENABLE)
	{ "EDOG", 			"",   " EDOG related Operation",      UartCmd_EDOG_Operation},
	#endif
	#if (GSENSOR_CONNECT_ENABLE)
	{ "GsensorTest", 		"", 							"G-Sensor test Operation", 				UartCmd_Gsensor_Test },
	#endif
	#if (GYROSENSOR_CONNECT_ENABLE)
	{ "GyrosensorTest", 	"", 							" GyroSensor test Operation", 			UartCmd_Gyrosensor_Test },
    #if (SUPPORT_EIS)
	{ "eis", 				"",                             " EIS",                                 EIS_test},
	#endif
	#endif		
	#if (MOTION_DETECTION_EN)
	{ "vmd",			"",						"Motion Detection Parm",UartCmd_MDP				 },
	#endif
	{ "lb", 				"", 							"Low Battery Test", 					UartCmd_LowBatterySim },
//    { "nfc",           "",                     " NFC test",         MonitorNfcFunc },
#if (WIFI_PORT == 1)
    { "net",   	"",				           "perform NETWORK commands",  UartCmd_NETCommands},
    { "wifi",  	"",				           "perform WIFI commands",     UartCmd_WifiCommands},
	{ "v4l",    "",                        "v4l debugging",             UartCmd_V4l},
#endif
	{ "cpa",           "",                     " Copy All", UartCmd_CopyAll        },
	{ "ldws",           "",                     " LDWS switch", UartCmd_LDWS_Enable        },
    { "tvtest",      "",                        "Test TV Colorbar, Param-1: 0:Off, 1:On; Param-2: 0:NTSC, 1:PAL; Param-3: 0:8-bar, 1:8-bar+3 gray + 2 strip",  UartCmd_TV_Test},		// TY Miao

    { "rtvbright",   "",                        "Get TV Brightness",  UartCmd_TV_GetBrightness},		            // TY Miao
    { "wtvbright",   "",                        "Set TV Brightness, 0~255",  UartCmd_TV_SetBrightness},		// TY Miao
    { "rtvcontrast", "",                        "Get TV Contrast",  UartCmd_TV_GetContrast},		                // TY Miao
    { "wtvcontrast", "",                        "Set TV Contrast 0~511",  UartCmd_TV_SetContrast},		        // TY Miao
    { "rtvsaturation","",                       "Get TV saturation", UartCmd_TV_GetSaturation},		                // TY Miao
    { "wtvsaturation","",                       "Set TV Saturation 0~255", UartCmd_TV_SetSaturation},		    // TY Miao
    { "wtvgamma","",                            "Set TV Gamma 0~4096", UartCmd_TV_SetGamma},		    // TY Miao
    { "rtvgamma","",                            "Get TV Gamma", UartCmd_TV_GetGamma},		    // TY Miao
	{ "ddosd",	"",								"Dynamic Download OSD", UartCmd_DDOSD},			// TY Miao
	{ "aff",	"",								"AIT Format Free", UartCmd_FormatFree},			
#if (MSDC_SUPPORT_SECRECY_LOCK)
	{ "setmsdclock",	"", 	  				"", 					UartCmd_Set_MSDC_Lock	 },
#endif
	{ "laud",	"",								"Get Live ausio", UartCmd_LiveAudio},
	{ "pipswp",            "",                     " swap front/rear cam preview",          UartCmd_PIPswp },//lucas
	{0,0,0,0}
};

#if defined(MSB2531_CMD_CTRL)
UARTCOMMAND sUartCommandSample4[] =
{
	//
	{ "cmswpb", 	    "",		   				" switch to play back mode",      	UartCmd_MSB2531_SwMode },
    { "cmswrec",        "",                     " switch to record mode",          UartCmd_MSB2531_SwMode },
    { "cmswcap",        "",                     " switch to capture mode",          UartCmd_MSB2531_SwMode },

    { "cmrecstart", 	"",		   				" start record mov file",      	UartCmd_MSB2531_SwMode },
    { "cmrecend",       "",                     " stop record",          UartCmd_MSB2531_SwMode },
		
	{ "cmsetbri", 		"",   					" set brightness value",      	UartCmd_MSB2531_SwMode },
	{ "cmsetsat", 		"",   				    " set saturation value",      	UartCmd_MSB2531_SwMode },
	{ "cmsetgam", 		"",   					" set gamma value",      	UartCmd_MSB2531_SwMode },
    { "cmsetshp",       "",                     " set sharpness value",          UartCmd_MSB2531_SwMode },
    { "cmsetresv",      "",                     " set resolution(video)",          UartCmd_MSB2531_SwMode },
    { "cmsetresp",      "",                     " set resolution(picture)",          UartCmd_MSB2531_SwMode },

    { "cmcapture",      "",                    " to capture a photo",          UartCmd_MSB2531_SwMode },

    { "cmgetpbtime",    "",                     " Get current playback time",          UartCmd_MSB2531_SwMode },
    { "cmgetfwver",     "",                     " Get ait code version",          UartCmd_MSB2531_SwMode },

    { "cmctrlnext",     "",                     " nex page",          UartCmd_MSB2531_SwMode },
    { "cmctrlpre",      "",                     " pre page",          UartCmd_MSB2531_SwMode },

	{0,0,0,0}
};
#endif

//void RegisterUartCmdSample(void);

void RegisterUartCmdSample2(void)
{
	UartRegisterUartCmdList(sUartCommandSample2);
	UartRegisterUartCmdList(sUartCommandSample3);
    #if defined(MSB2531_CMD_CTRL)
    UartRegisterUartCmdList(sUartCommandSample4);
    #endif
}

void RegisterUartCmdSample(void);

#if (WIFI_PORT == 1)
void AHC_Net_UartCommand_Init(void);
#endif

void UartCommandInit(void)
{
	UartRegisterDefaultCmds();
	//RegisterUartCmdSample();
	RegisterUartCmdSample2();
#if (WIFI_PORT == 1)
	AHC_Net_UartCommand_Init();
#endif
}
#endif
